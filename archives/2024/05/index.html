<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />
  <title>文章归档：2024/5 - 卷不过没事了</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

    <!-- Site Verification -->
    <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />

  <link rel="shortcut icon" href="/images/head/head.jpg" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="卷不过没事了">
<meta property="og:url" content="http://example.com/archives/2024/05/index.html">
<meta property="og:site_name" content="卷不过没事了">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Talita">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://lib.baomitu.com/highlight.js/9.15.8/styles/atom-one-dark.min.css" crossorigin>
  <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css">
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css">
  <link rel="stylesheet" href="/lib/fancybox/css/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://lib.baomitu.com/justifiedGallery/3.8.1/css/justifiedGallery.min.css">
  
    <link rel="stylesheet" href="//at.alicdn.com/t/font_2421060_8z08qcz5sq3.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1721141826480">
<meta name="generator" content="Hexo 7.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/background/xiaomai.png)"></div>
    <div class="nexmoe-small" style="background-image: url(/images/background/lihui.png)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Talita" class="mdui-btn mdui-btn-icon"><img src="/images/head/me.jpeg" alt="Talita"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Talita">
            <img src="/images/head/me.jpeg" alt="Talita" alt="Talita">
        </a>
    </div>
    <div class="nexmoe-count">
        <div class="nexmoe-count-item"><span>文章</span>8 <div class="item-radius"></div><div class="item-radius item-right"></div> </div>
        <div class="nexmoe-count-item"><span>标签</span>6<div class="item-radius"></div><div class="item-radius item-right"></div></div>
        <div class="nexmoe-count-item"><span>分类</span>6<div class="item-radius"></div><div class="item-radius item-right"></div></div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="首页">
            <i class="mdui-list-item-icon nexmoefont icon-meishi"></i>
            <div class="mdui-list-item-content">
                首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives.html" title="归档">
            <i class="mdui-list-item-icon nexmoefont icon-hanbao1"></i>
            <div class="mdui-list-item-content">
                归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于">
            <i class="mdui-list-item-icon nexmoefont icon-jiubei1"></i>
            <div class="mdui-list-item-content">
                关于
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/friend.html" title="友链">
            <i class="mdui-list-item-icon nexmoefont icon-cola"></i>
            <div class="mdui-list-item-content">
                友链
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/download.html" title="下载中心">
            <i class="mdui-list-item-icon nexmoefont icon-tangguo"></i>
            <div class="mdui-list-item-content">
                下载中心
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  
<!-- 站内搜索 -->

<div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search" >
        <form id="search-form">
            <label><input type="text" id="local-search-input" name="q" results="0" placeholder="站内搜索" class="input form-control" autocomplete="off" autocorrect="off"/></label>
            <!-- 清空/重置搜索框 -->
            <i class="fa fa-times" onclick="resetSearch()"></i>
        </form>
    </div>
    <div id="local-search-result"></div> <!-- 搜索结果区 -->
    <!-- <p class='no-result'></p> 无匹配时显示，注意在 CSS 中设置默认隐藏 -->
</div>


  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=2120252100&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(64, 196, 255);background-color: rgba(64, 196, 255, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="mailto:tangyuxian@vip.qq.com" target="_blank" mdui-tooltip="{content: 'mail'}" style="color: rgb(249,8,8);background-color: rgba(249,8,8,.1);">
            <i class="nexmoefont icon-mail-fill"></i>
        </a><a class="mdui-ripple" href="https://blog.csdn.net/qq_40621378?type=blog" target="_blank" mdui-tooltip="{content: 'CSDN'}" style="color: rgb(199,29,35);background-color: rgba(199,29,35,.1);">
            <i class="nexmoefont icon-csdn"></i>
        </a><a class="mdui-ripple" href="https://www.cnblogs.com/lovetangyuxian/" target="_blank" mdui-tooltip="{content: '博客园'}" style="color: rgb(66, 214, 29);background-color: rgba(66, 214, 29, .1);">
            <i class="nexmoefont icon-bokeyuan"></i>
        </a><a class="mdui-ripple" href="https://github.com/tangyuxian/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://gitee.com/tangyuxian" target="_blank" mdui-tooltip="{content: 'gitee'}" style="color: rgb(255, 255, 255);background-color: rgb(199,29,35);">
            <i class="nexmoefont icon-mayun"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JavaScript/">JavaScript</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Node-js/">Node.js</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/TypeScript/">TypeScript</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/react/">react</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/代码管理/">代码管理</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/浏览器/">浏览器</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/node/" style="font-size: 20px;">node</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2024 Talita
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/tangyuxian/hexo-theme-tangyuxian" target="_blank">Tangyuxian</a><br/>
        <a href="http://beian.miit.gov.cn" target="_blank">辽ICP备2021002341号</a><br/>
        
        <div style="font-size: 12px">
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            本站总访问量  <a id="busuanzi_value_site_pv"></a> 次<br />
            本站访客数<a id="busuanzi_value_site_uv"></a>人次
        </div>
        
        
    </div>

</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2024/05/28/T1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/TypeScript.png" data-sizes="auto" alt="TypeScript" class="lazyload">
                    <h1>TypeScript</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 21 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol>
<li>ts编译器</li>
</ol>
<p>js引擎运行ts代码需要先经过tsc编译器编译为可识别的的js代码，tsc基本用法：</p>
<ol>
<li>tsc：默认使用 tsconfig.json 的配置</li>
<li>tsc <name>.ts：只编译<name>.ts</li>
<li>tsc *.ts：编译所有ts文件</li>
<li>tsc –project tsconfig.production.json：指定配置文件</li>
<li>tsc index.js –declaration 或 -d –emitDeclarationOnly：只生成类型声明文件，不生成js代码</li>
<li>tsc app.ts util.ts –target esnext –outfile index.js –outDir dist：target指定生成的js代码版本，outfile指定输出文件，outDir指定输出位置</li>
<li>tsc app.ts <code>-noEmitOnError</code>：一旦报错就停止编译，不生成编译产物。</li>
<li>tsc app.ts  <code>-noEmit</code>：只检查类型是否正确，不生成 js 文件。</li>
</ol>
<p><code>tsconfig.json</code>的具体配置项参见<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-tsconfig.json.md">https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-tsconfig.json.md</a>。</p>
<ol>
<li>终端运行ts</li>
</ol>
<p><code>npm install -g ts-node</code>全局安装该模块，<code>ts-node script.ts</code> 编译并运行ts文件，退出环境Ctrl + d</p>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>一共8种：<code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>、<code>undefined</code>、<code>null</code></p>
<p>小写类型用于类型判断，大写类型为内置对象，一般是用来调用该对象方法的。例如，<code>Number.parseInt()</code>、<code>Number.parseFloat()</code>、<code>Number.isNaN()</code>。</p>
<p>number：64位浮点数</p>
<p>bigint：超出number的计算范围，要求编译参数<code>target</code>不低于<code>es2020</code></p>
<p>boolean：任意类型转boolean只要加!!即可</p>
<p>string：JSON字符串必须用双引号</p>
<p>undefined 和 null ：是所有类型的子类型，分别表示未定义和空</p>
<p><strong>object：</strong>大写Object和{}包含所有类型，小写object仅包含引用类型，即<strong>对象、数组和函数。</strong>如果声明某个对象类型为object，ts只会推断它拥有原生object的属性和方法，因此一般不用。</p>
<pre><code class="jsx">const o1:Object = &#123; foo: 0 &#125;;
const o2:object = &#123; foo: 0 &#125;;

o1.toString()// 正确
o1.foo// 报错

o2.toString()// 正确
o2.foo// 报错
</code></pre>
<p>为了给一个对象添加属性并让 TypeScript 知道这些属性，你可以使用接口（Interface）或类型别名（Type Alias）来明确地定义对象的结构。</p>
<ol>
<li><p>使用接口</p>
<pre><code class="tsx">interface MyObject &#123;
  foo: number;
&#125;

const o1: MyObject = &#123; foo: 0 &#125;;
console.log(o1.foo); // 正确
</code></pre>
</li>
<li><p>使用类型别名</p>
<pre><code class="tsx">type MyObject = &#123;
  foo: number;
&#125;;

const o1: MyObject = &#123; foo: 0 &#125;;
console.log(o1.foo); // 正确
</code></pre>
</li>
<li><p>使用类型断言</p>
<pre><code class="tsx">const o1 = &#123; foo: 0 &#125; as &#123; foo: number &#125;;
console.log(o1.foo); // 正确
</code></pre>
</li>
<li><p>使用索引签名</p>
<pre><code class="tsx">interface MyObject &#123;
  [key: string]: number;
&#125;

const o1: MyObject = &#123; foo: 0 &#125;;
console.log(o1.foo); // 正确
o1.bar = 1; // 正确
</code></pre>
</li>
</ol>
<p>Symbol：用于创建一个唯一标识，可以传入字符串作为描述信息。</p>
<ol>
<li><p><strong>作为对象属性名：</strong>需要写在[]里</p>
<pre><code class="tsx">const PROP_NAME = Symbol()
const PROP_AGE = Symbol()

let obj = &#123;
  [PROP_NAME]: &quot;一斤代码&quot;
&#125;
obj[PROP_AGE] = 18
obj[PROP_NAME]// &#39;一斤代码&#39;
obj[PROP_AGE]// 18
</code></pre>
</li>
<li><p>替代常量</p>
<pre><code class="jsx">// const TYPE_IMAGE = &#39;IMAGE&#39;
const TYPE_IMAGE = Symbol()
</code></pre>
</li>
</ol>
<h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><p><strong>any</strong></p>
<p><strong>顶层类型</strong>，会关闭类型检查。</p>
<p>赋值给其他变量时，其他变量也会变成any。</p>
<p>如果不显式声明并且ts推断不出来时，会被认定为any，打开编译项<code>noImplicitAny</code> ，被推断为any时会报错。</p>
<p>使用<code>let</code>和<code>var</code>时如果不赋值，也没有指定类型，ts 会推断它们的类型为<code>any</code>。即使打开了<code>noImplicitAny</code>也不会报错。</p>
<p><strong>unknown（更加推荐）</strong></p>
<p>any的安全类型，它让变量不能赋值给其他变量，并且变为<code>private</code>，不能被直接调用，除非使用类型断言和类型守卫</p>
<ol>
<li><p>类型断言</p>
<pre><code class="tsx">let value: unknown = &quot;Hello, world!&quot;;

// 使用类型断言
(value as string).length; // 正确
</code></pre>
</li>
<li><p>类型守卫（类型缩小）</p>
<pre><code class="tsx">let value: unknown = &quot;Hello, world!&quot;;

if (typeof value === &quot;string&quot;) &#123;
  console.log(value.length); // 正确，因为在这个分支内，value 的类型被缩小为 string
&#125;
</code></pre>
</li>
</ol>
<h3 id="Never类型"><a href="#Never类型" class="headerlink" title="Never类型"></a>Never类型</h3><p><code>never</code>等同于空集，不可能赋给它任何值，否则都会报错。</p>
<p><code>never</code>类型的使用场景：</p>
<ol>
<li><p>在一些类型运算之中，保证类型运算的完整性</p>
</li>
<li><p>不可能返回值的函数，返回值的类型就可以写成<code>never</code></p>
<pre><code class="tsx">function f():never &#123;
  throw new Error(&#39;Error&#39;);
&#125;

let v1:number = f();// 不报错let v2:string = f();// 不报错let v3:boolean = f();// 不报错
</code></pre>
</li>
<li><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。处理完所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p>
<pre><code class="tsx">function fn(x:string|number) &#123;
  if (typeof x === &#39;string&#39;) &#123;
    *// ...*
  &#125; else if (typeof x === &#39;number&#39;) &#123;
    *// ...*
  &#125; else &#123;
    x; *// never 类型*
  &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h3><p>注意：接口用作对象的模版，对象必须和接口的格式保持一致。</p>
<p>对象属性：</p>
<ol>
<li>可选属性：<code>？</code></li>
<li>只读属性：<code>readonly</code></li>
<li>属性索引：<code>[prop: 类型]: 类型</code></li>
</ol>
<pre><code class="tsx">interface myObj &#123;
  title?: string;
  readonly name: string;
  [prop: number]: number;
&#125;
const obj: myObj = &#123;
  name: &quot;xmm&quot;,
  123: 234,
&#125;;
</code></pre>
<p>对象方法：允许函数重载</p>
<pre><code class="tsx">interface myObj &#123;
  f(x: number): boolean;
  f(x: number, y: number): boolean;
&#125;
// 使用变量作为属性名
const functionName = &quot;myFn&quot;;
interface myObj &#123;
  [functionName](x: number): boolean;
&#125;
</code></pre>
<p>使用：</p>
<ol>
<li>属性名为表达式时，可以使用<code>[]</code></li>
<li>接口允许使用<code>extends</code>继承，且多重继承，但不允许有冲突</li>
<li>接口可以继承的对象包括 <code>interface、class、type</code></li>
<li>同名接口会被合并，且后者生效</li>
<li>type允许类型映射，interface不允许</li>
</ol>
<h3 id="数组和元祖"><a href="#数组和元祖" class="headerlink" title="数组和元祖"></a>数组和元祖</h3><p>数组两种写法：</p>
<ol>
<li><p><code>type[]</code></p>
<pre><code class="tsx">let arr:number[] = [1, 2, 3];
</code></pre>
</li>
<li><p><code>Array&lt;type&gt;</code></p>
<pre><code class="tsx">let arr: Array&lt;number&gt; = [1, 2, 3];
</code></pre>
</li>
</ol>
<p>any数组：可以存放任意类型</p>
<p>类数组<code>IArguments</code>：ts自己定义的一个接口，格式如下：</p>
<pre><code class="tsx">interface IArguments &#123;
    [index: number]: any;
    length: number;
    callee: Function;
&#125;
</code></pre>
<p>它在函数被调用时自动创建，第一项为函数参数列表，第二项为数组长度</p>
<p>因此，它的使用方法为：</p>
<ol>
<li>可以用索引访问</li>
<li>具有length属性</li>
<li>但不能调用真正的数组方法，除非使用<code>Array.from(arguments)</code> 或者扩展运算符将它转化为真正的数组</li>
</ol>
<pre><code class="jsx">function abc(a:number,b:number)&#123;
  // const arr = Array.from(arguments)
  const arr = [...arguments]
  arr.push(32)
&#125;
abc(12,22)
</code></pre>
<p>比起<code>arguments</code> ，更推荐使用剩余参数，原因如下：</p>
<ol>
<li>剩余参数允许指定数据类型</li>
<li>剩余参数是一个真正的数组，允许使用数组方法</li>
<li>允许在不明确参数数量的时候使用</li>
</ol>
<pre><code class="tsx">function abc(...args:any[])&#123;
  args.push(&#39;xmm&#39;)
&#125;
abc(12,22,23,34)
</code></pre>
<p>元组把数组的每个元素都固定了类型：</p>
<pre><code class="tsx">let arr:[number,string] = [1,&#39;string&#39;]

let arr2: readonly [number,boolean,string,undefined] 
= [1,true,&#39;sring&#39;,undefined]
</code></pre>
<p>元祖的使用：</p>
<ol>
<li>元祖数量固定因此不允许越界，不允许使用push和pop等操作</li>
<li>元祖同样支持索引访问</li>
<li>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用</li>
</ol>
<pre><code class="tsx">type Color = [
  red: number,
  green: number,
  blue: number
];

const c:Color = [255, 255, 255];
</code></pre>
<h3 id="类型断言-联合类型-交叉类型"><a href="#类型断言-联合类型-交叉类型" class="headerlink" title="类型断言 | 联合类型 | 交叉类型"></a><strong>类型断言 | 联合类型 | 交叉类型</strong></h3><ol>
<li>联合类型<code>｜</code>：允许多种类型</li>
<li>交叉类型<code>&amp;</code> ：多种类型的集合，用于对象</li>
<li>类型断言<code>as</code> ；<ol>
<li>断言为其他类型：必须是相关类型，比如<code>string</code>断言为<code>object</code>或者<code>any</code>，如果是断言为完全无关的number，则需要断言两次<code>as unknown as number</code></li>
<li>as any临时断言：访问只读对象的属性</li>
<li>as const：把对象或者数组的长度和内容固定下来，变为只读的，不能再添加或修改，如果想改可以用临时断言。但如果赋值给预先声明类型的对象时，基本没啥用。</li>
</ol>
</li>
<li>非空断言<code>！</code> ：告诉编译器该变量不会空</li>
</ol>
<pre><code class="tsx">const obj = &#123;
  name: &quot;2&quot;,
  age: 1,
  gender: &quot;2&quot;,
&#125; as const;
(obj as any).name = &quot;xmm&quot;;
</code></pre>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>ECMAScript 的内置对象：<code>RegExp</code>、<code>Date</code>、<code>Error</code></p>
<p>DOM 和 BOM 的内置对象：<code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等</p>
<p><strong>RegExp：</strong></p>
<pre><code class="tsx">let regex = new RegExp(&quot;ab+c&quot;);  
let match = &quot;abc abcbbbc&quot;.match(regex);  
console.log(match); // 输出: [&quot;abbc&quot;]
</code></pre>
<ul>
<li><code>test(string)</code>: 测试字符串是否匹配正则表达式，返回布尔值</li>
<li><code>match(string)</code>: 在字符串中执行匹配，返回匹配项</li>
</ul>
<p><strong>Date：</strong></p>
<pre><code class="jsx">let now = new Date();  
console.log(now); // 输出当前日期和时间  
  
let specificDate = new Date(&quot;December 17, 1995 03:24:00&quot;);  
</code></pre>
<ul>
<li><code>getFullYear()</code>、<code>getMonth()</code>、<code>getDate()</code>: 获取年月日</li>
<li><code>getHours()</code>、<code>getMinutes()</code>、<code>getSeconds()</code>: 获取时分秒</li>
<li><code>setTime(milliseconds)</code>: 设置日期对象的毫秒数</li>
</ul>
<p><strong>Promise：</strong></p>
<p>函数定义返回<code>promise</code> 的语法规则：<code>Promise&lt;T&gt;</code></p>
<pre><code class="jsx">function promise():Promise&lt;number&gt; &#123;
  return new Promise(resolve=&gt;&#123;
    resolve(1)
  &#125;)
&#125;
</code></pre>
<p>代码雨案例：</p>
<pre><code class="tsx">let canvas = document.querySelector(&#39;#canvas&#39;) as HTMLCanvasElement
let ctx = canvas.getContext(&#39;2d&#39;) as CanvasRenderingContext2D
canvas.height = screen.availHeight; //可视区域的高度
canvas.width = screen.availWidth; //可视区域的宽度
let str: string[] = &#39;XMZSWSSBXMZSWSSBXMZSWSSBXMZSWSSBXMZSWSSB&#39;.split(&#39;&#39;)
let Arr = Array(Math.ceil(canvas.width / 10)).fill(0) //获取宽度例如1920 / 10 192
console.log(Arr);
 
const rain = () =&gt; &#123;
    ctx.fillStyle = &#39;rgba(0,0,0,0.05)&#39;//填充背景颜色
    ctx.fillRect(0, 0, canvas.width, canvas.height)//背景
    ctx.fillStyle = &quot;#0f0&quot;; //文字颜色
    Arr.forEach((item, index) =&gt; &#123;
        ctx.fillText(str[ Math.floor(Math.random() * str.length) ], index * 10, item + 10)
        Arr[index] = item &gt;= canvas.height || item &gt; 10000 *  Math.random() ? 0 : item + 10; //添加随机数让字符随机出现不至于那么平整
    &#125;)
    console.log(Arr);
    
&#125;
setInterval(rain, 40)
</code></pre>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><ol>
<li><p>数字枚举：如果不定义将自动增长</p>
</li>
<li><p>字符串枚举</p>
</li>
<li><p>异构枚举：多种字面量类型</p>
</li>
<li><p>接口枚举：在接口中声明一个值为枚举类型，具体实现时也必须是该枚举类型</p>
</li>
<li><p>const枚举（推荐）：常量枚举会被编译为常量，普通枚举会被编译为对象</p>
</li>
<li><p>反向映射：上面都是正向映射（ <code>name</code> -&gt; <code>value</code>），反向映射（ <code>value</code> -&gt; <code>name</code>）为：</p>
<pre><code class="tsx">enum Enum &#123;
   fall
&#125;
let a = Enum.fall; // 正向映射
let nameOfA = Enum[a]; //反向映射
console.log(nameOfA); //fall
</code></pre>
<p><em>但是不会</em>为字符串枚举成员生成反向映射，数字枚举成员可以作为索引项才能生成反向映射</p>
</li>
</ol>
<h3 id="类型别名-type"><a href="#类型别名-type" class="headerlink" title="类型别名 type"></a>类型别名 type</h3><ol>
<li>类型别名</li>
<li>函数别名</li>
<li>联合类型别名</li>
<li>值的别名</li>
</ol>
<pre><code class="tsx">type one = string
type two = (x:number)=&gt;Promise&lt;void&gt;
type three = string | number
type four = 1|&#39;xmm&#39;|boolean
</code></pre>
<p><strong>类型别名type跟interface的区别：</strong></p>
<ol>
<li>interface可以 extends 继承  type 只能通过 &amp; 合并</li>
<li>interface 遇到重名的会合并 type 不行</li>
</ol>
<p><strong>使用extends判断是否包含：</strong></p>
<pre><code class="tsx">type IsNumber&lt;T&gt; = T extends number ? &#39;yes&#39; : &#39;no&#39;;  
  
type Result1 = IsNumber&lt;1&gt;;  // 类型为 &#39;yes&#39;  
type Result2 = IsNumber&lt;string&gt;;  // 类型为 &#39;no&#39;
</code></pre>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>函数泛型：</strong></p>
<p>应用于当使用方式和参数数量一致，但是参数类型可能不同的时候</p>
<p>定义的时候用大写字母，调用的时候一般不用补充类型，只有存在多个类型的时候才需要额外指定：</p>
<pre><code class="tsx">function execute&lt;T&gt;(a:T,b:T):Array&lt;T&gt;&#123;
  return [a,b]
&#125;
const arr1=execute(2,3)
const arr2=execute(&#39;x&#39;,&#39;m&#39;)

function Sub&lt;T,U&gt;(a:T,b:U):Array&lt;T|U&gt; &#123;
    const params:Array&lt;T|U&gt; = [a,b]
    return params
&#125;
Sub&lt;Boolean,number&gt;(false,1)
</code></pre>
<p><strong>泛型接口：</strong></p>
<pre><code class="tsx">interface MyInter&lt;T&gt; &#123;
   (arg: T): T
&#125;
 
function fn&lt;T&gt;(arg: T): T &#123;
   return arg
&#125;
 
let result: MyInter&lt;number&gt; = fn
result(123)
</code></pre>
<p><strong>对象字面量泛型：</strong></p>
<pre><code class="tsx">let foo: &#123; &lt;T&gt;(arg: T): T &#125;
foo = function &lt;T&gt;(arg:T):T &#123;
   return arg
&#125;
foo(123)
</code></pre>
<p><strong>泛型约束：</strong></p>
<pre><code class="tsx">interface Len &#123;
   length:number
&#125;
function getLegnth&lt;T extends Len&gt;(arg:T) &#123;
  return arg.length
&#125;
 
getLegnth(&#39;123&#39;)
</code></pre>
<p><strong>使用keyof 约束对象：</strong></p>
<p>keyof操作符可以获取操作对象的所有键，这里表示K必须要是T的键</p>
<pre><code class="tsx">function prop&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;
   return obj[key]
&#125;
let o = &#123; a: 1, b: 2, c: 3 &#125;
 
prop(o, &#39;a&#39;) 
prop(o, &#39;d&#39;) //此时就会报错发现找不到
</code></pre>
<p><strong>Partial将所有属性变为可选，Required将所有可选属性变为必选：</strong></p>
<pre><code class="tsx">interface User &#123;
    name: string;
    age: number;
&#125;
type select = Partial&lt;User&gt;

interface User &#123;
    name?: string;
    age: number;
&#125;
type select = Required&lt;User&gt;
</code></pre>
<p><strong>Pick从一个类型中选取属性，Exclude和Omit从一个类型中排除属性</strong></p>
<pre><code class="tsx">interface User &#123;
  name: string;
  age: number;
&#125;
type test1 = Pick&lt;User,&#39;name&#39;&gt;
type test2 = Exclude&lt;User,&#39;age&#39;&gt;
type test3 = Omit&lt;User,&#39;age&#39;&gt;
</code></pre>
<p><strong>Record规定键的可选值和值的类型：</strong></p>
<pre><code class="tsx">// 定义一个Record类型，键是&#39;name&#39; | &#39;age&#39;，值是string  
type PersonRecord = Record&lt;&#39;name&#39; | &#39;age&#39;, string&gt;;  
  
// 使用这个类型  
let person: PersonRecord = &#123;  
    name: &#39;Alice&#39;,  
    age: &#39;30&#39; // 注意这里虽然用了字符串表示年龄，但在实际应用中可能会用number  
&#125;;  
  
// 尝试添加一个不在Record定义中的属性会报错  
person.height = &#39;170cm&#39;; 
// Type &#39;&quot;height&quot;&#39; is not assignable to type &#39;&quot;name&quot; | &quot;age&quot;&#39;.
</code></pre>
<p><strong>ReturnType用于获取函数的返回类型：</strong></p>
<pre><code class="tsx">function greet(name: string) &#123;  
  return `Hello, $&#123;name&#125;!`;  
&#125;  

// 获取greet函数的返回类型string
type rt = ReturnType&lt;typeof greet&gt;;  
 
let greeting: rt = greet(&#39;Bob&#39;); // 正确  
// greeting = 123; // 错误，因为rt是string类型
</code></pre>
<h3 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h3><p><strong>Set集合内元素唯一，且没有顺序概念，因此也不能用索引访问</strong></p>
<p>操作方法：</p>
<ul>
<li>add：增加元素，返回Set本身</li>
<li>delete：删除元素，返回布尔值</li>
<li>has：是否含有某元素，返回布尔值</li>
<li>clear：清空Set，无返回值</li>
<li>size：返回Set的数据长度</li>
</ul>
<p>遍历方法：</p>
<ul>
<li>for……of：直接遍历</li>
<li>entries和values方法返回迭代器，再使用for……of 遍历</li>
</ul>
<p><strong>Map是键值对的集合，各种类型的值都可以作为键，也不能用索引和属性访问</strong></p>
<p>操作方法：</p>
<ul>
<li>set：设置键值对</li>
<li>get：获取键对应的值</li>
<li>has：是否含有某键</li>
<li>delete：通过键删除某元素</li>
<li>size：返回Map的数据长度</li>
</ul>
<p>遍历方法：</p>
<ul>
<li>for……of：直接遍历</li>
<li>使用<code>keys()</code>、<code>values()</code>和<code>entries()</code>返回迭代器，再使用for……of 遍历</li>
<li>forEach遍历，传入回调接收参数value、key和map本身</li>
</ul>
<p><strong>WeakSet和WeakMap：</strong></p>
<ul>
<li>成员和键值必须是对象</li>
<li>成员对象是弱引用，一旦在其他地方没有被引用，将会被垃圾回收机制自动回收，可以防止内存泄漏</li>
<li>不可以遍历</li>
</ul>
<h3 id="proxy-Reflect"><a href="#proxy-Reflect" class="headerlink" title="proxy &amp; Reflect"></a><strong>proxy &amp; Reflect</strong></h3><p><strong>定义与功能</strong>：</p>
<ul>
<li><p>Proxy是一个内置的构造函数，用于创建一个对象的代理，通过代理可以拦截并自定义对象的基本操作（如属性查找、赋值、枚举、函数调用等）。</p>
</li>
<li><p>Proxy通过定义一个handler对象来指定拦截器（trap）的行为，这些拦截器会在代理对象上执行相应操作时触发。</p>
<pre><code class="tsx">let proxy = new Proxy(target, handler);  
let target = &#123;  
    foo: &#39;bar&#39;,  
    method() &#123;  
        return &#39;method called&#39;;  
    &#125;  
&#125;;  
  
let handler = &#123;  
    get(target, prop, receiver) &#123;  
        console.log(`getting $&#123;prop&#125; with receiver $&#123;receiver === proxy ? &#39;proxy&#39; : &#39;target prototype&#39;&#125;`);  
        return Reflect.get(...arguments);  
    &#125;,  
    set(target, prop, value, receiver) &#123;  
        console.log(`setting $&#123;prop&#125; to $&#123;value&#125; with receiver $&#123;receiver === proxy ? &#39;proxy&#39; : &#39;target prototype&#39;&#125;`);  
        return Reflect.set(...arguments);  
    &#125;  
&#125;; 
</code></pre>
<p>Proxy构造函数传入操作对象target和handler对象，prop为被操作属性，value为被设置的新值，receiver为代理本身</p>
</li>
<li><p>Reflect是一个内置的对象，提供了一系列静态方法，用于执行与对象相关的默认操作，如属性访问、方法调用等。</p>
</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ol>
<li><strong>属性访问控制</strong>：通过拦截属性的读取和设置操作，可以实现属性的访问控制，如私有属性的封装、属性的只读或只写等。</li>
<li><strong>性能监控</strong>：在访问或修改对象属性时，记录操作日志或执行性能分析，帮助开发者优化程序性能。</li>
<li><strong>数据绑定和观察者模式</strong>：结合Reflect，可以实现数据绑定的功能，当对象属性发生变化时，自动通知相关组件或函数进行更新。</li>
<li><strong>函数调用拦截</strong>：拦截函数的调用，执行额外的逻辑，如权限校验、参数校验等。</li>
</ol>
<pre><code class="tsx">let person = &#123; name: &#39;Alice&#39;, age: 25 &#125;;  
  
const handler = &#123;  
    get(target: any, prop: any, receiver: unknown) &#123;  
        console.log(`读取 $&#123;prop&#125; 属性`);  
        return Reflect.get(target, prop, receiver);  
    &#125;,  
    set(target: any, prop: any, value: any, receiver: any) &#123;  
        console.log(`设置 $&#123;prop&#125; 属性为 $&#123;value&#125;`);  
        return Reflect.set(target, prop, value, receiver);  
    &#125;  
&#125;;  
  
const proxyPerson = new Proxy(person, handler);  
  
console.log(proxyPerson.name); // 输出：读取 name 属性，Alice  
proxyPerson.age = 30; // 输出：设置 age 属性为 30
</code></pre>
<h3 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h3><p>在 TypeScript 中，类型守卫（Type Guards）是一种用于在运行时检查类型的机制。它们允许你在代码中执行特定的检查，以确定变量的类型，并在需要时执行相应的操作。</p>
<p>typeof：输出“string”、“number”、“boolean”、“symbol”、“undefined” 和 “object”</p>
<p>instanceof：检查某个对象是否是某个类的实例，输出true和false</p>
<p>自定义类型守卫：专门用于给any或联合类型的数据做类型检查，比如：</p>
<pre><code class="tsx">function isStr(value: any): value is string &#123;  
    return typeof value === &#39;string&#39;;  
&#125;
</code></pre>
<p>定义的<code>isStr</code>方法是一个类型谓词，它接收一个<code>any</code>类型的数据，如果是<code>typeof</code>返回<code>string</code>，函数就返回<code>true</code>，ts就可以通过<code>is string</code>知道可以安全的把<code>value</code>当作<code>string</code>处理，使用时：</p>
<pre><code class="tsx">let myValue: any = &quot;Hello, TypeScript!&quot;;  
  
if (isStr(myValue)) &#123;  
    // 在这里，TypeScript知道myValue是string类型  
    console.log(myValue.toUpperCase()); // 正确的操作，因为TypeScript认为myValue是字符串  
&#125; else &#123;  
    // 如果需要，你可以在这里处理非字符串的情况  
    console.log(&quot;myValue不是一个字符串&quot;);  
&#125;
</code></pre>
<h3 id="infer关键字"><a href="#infer关键字" class="headerlink" title="infer关键字"></a>infer关键字</h3><p>infer就是<strong>推导泛型参数，</strong>infer声明只能出现在extends子语句中</p>
<p>其中，T为引用类型，由a<T>可以推断出U</p>
<p><strong>获取数组的元素类型</strong></p>
<p>之前：</p>
<pre><code class="tsx">type a = number[]
type b =string[]
type Inf&lt;T&gt; = T extends a ? number : T extends b ? string : never

type atype = Inf&lt;a&gt;
type btype = Inf&lt;b&gt;
</code></pre>
<p>如果使用了infer，获取方式就很简单了：</p>
<pre><code class="tsx">type a&lt;T&gt; = T extends Array&lt;infer E&gt; ? E : never;
type arr = string[];
type atype = a&lt;arr&gt;
</code></pre>
<p><strong>获取对象的属性类型</strong></p>
<pre><code class="tsx">type Foo&lt;T&gt; = T extends &#123; a: infer U &#125; ? U : never;

type T10 = Foo&lt;&#123; a: string &#125;&gt;; // T10类型为 string
</code></pre>
<p><strong>推断联合类型</strong></p>
<pre><code class="tsx">type Foo&lt;T&gt; = T extends &#123; a: infer U; b: infer U &#125; ? U : never;

type T11 = Foo&lt;&#123; a: string; b: number &#125;&gt;; // T11类型为 string | number
</code></pre>
<p><strong>推断交叉类型</strong></p>
<pre><code class="tsx">type T1 = &#123;name: string&#125;;
type T2 = &#123;age: number&#125;;
interface Props &#123;
  a: (x: T1) =&gt; void;
  b: (x: T2) =&gt; void;
&#125;
type K2&lt;T&gt; = T extends &#123;a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void&#125; ? U : never;
type k3 = K2&lt;Props&gt;

let obj:k3= &#123;name: &#39;123&#39;, age: 12&#125;;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://xiaoman.blog.csdn.net/article/details/128691340">typescript封装LocalStorage并支持过期时间_typescript localstorage-CSDN博客</a></p>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/15/DB/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/JavaScript.png" data-sizes="auto" alt="DOM和BOM" class="lazyload">
                    <h1>DOM和BOM</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>8.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 35 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="Document-Object-Model"><a href="#Document-Object-Model" class="headerlink" title="Document Object Model"></a><strong>Document Object Model</strong></h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/15/DB/Untitled.png" alt="Untitled" class="lazyload"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>DOM</strong>，即文档对象模型。它是一种跨平台的、独立于编程语言的API，它把HTML、XHTML或XML文档当作一个树结构，而每个节点视为一个对象，这些对象可以被编程语言操作，进而改变文档的结构，映射到文档的显示。</p>
<p>简单来说，DOM就是我们为了方便编程语言对HTML等文档进行操作，把HTML文档中的节点全部视为一个个的对象，所有可用于操作和创建网页的属性、方法和事件都被组织到对象中，这些对象依照层级关系形成一棵树，这棵树就命名为DOM树。有了对象，编程就方便多了，只要一层层拿到对象就可以优雅地改变对象的属性进而动态地改变HTML等文档的展示。</p>
<p>例如，DOM 中指定下面代码中的 <code>querySelectorAll</code> 方法必须要返回文档中所有 <code>&lt;p&gt;</code> 元素组成的列表：</p>
<pre><code class="jsx">const paragraphs = document.querySelectorAll(&quot;p&quot;);
// paragraphs[0] 是第一个 &lt;p&gt; 元素
// paragraphs[1] 是第二个 &lt;p&gt; 元素，依此类推
alert(paragraphs[0].nodeName);
</code></pre>
<p><em><strong>DOM 不是一种编程语言，也不是 JavaScript 语言的一部分，而是用于建立网站的 Web API。DOM 被设计成与特定编程语言相独立，使文档的结构化表述可以通过单一，一致的 API 获得。</strong></em></p>
<h3 id="网页加载过程"><a href="#网页加载过程" class="headerlink" title="网页加载过程"></a>网页加载过程</h3><ol>
<li><strong>HTML下载到本地内存</strong>：当浏览器请求一个HTML页面时，会从服务器下载HTML文件并将其存储在本地内存中。这个过程是通过HTTP请求完成的，并且通常会遵循TCP&#x2F;IP协议</li>
<li><strong>解析成DOM树</strong>：浏览器会解析HTML文档，将HTML标签和属性转换为DOM树</li>
<li><strong>展示页面到屏幕</strong>：在构建DOM树的同时或之后，浏览器还会开始解析CSS并构建<code>CSSOM</code>（CSS对象模型）树。然后，它会将DOM树和CSSOM树合并成一个渲染树（<code>render tree</code>），这个渲染树包含了页面上需要显示的内容以及这些内容如何显示（例如颜色、字体大小等）。最后，浏览器会根据渲染树在屏幕上绘制页面</li>
<li><strong>DOM API 动态修改</strong>：DOM API允许JavaScript等网络编程语言动态地访问和更新HTML文档的内容、结构和样式。例如，你可以使用JavaScript来修改DOM树中的元素、添加或删除元素、更改元素的属性或样式等<ul>
<li><strong>在页面加载过程中</strong>：当浏览器接收到 HTML 文档并开始解析时，它会同时或随后构建一个 DOM 树。一旦 DOM 树构建完成，浏览器就可以开始渲染页面了，但此时页面可能还没有完全加载完成，比如可能还有 CSS 和 JavaScript 文件需要加载和执行。此时，JavaScript 可以使用 DOM API 来修改已经解析并添加到 DOM 树中的元素</li>
<li><strong>在页面加载完成后</strong>：一旦页面完全加载并渲染完成（例如，所有图片都已加载），JavaScript 可以使用 DOM API 来添加新元素、删除现有元素或执行其他操作。这通常通过监听 <code>DOMContentLoaded</code> 或 <code>load</code> 事件来实现，这些事件会在页面加载的不同阶段触发</li>
</ul>
</li>
<li><strong>网页加载优化</strong>：为了提高网页的加载性能，开发者可以采取一系列优化措施，如压缩HTML、CSS和JavaScript文件、使用CDN（内容分发网络）来加速资源的加载、通过异步加载和延迟加载来减少阻塞等</li>
</ol>
<h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><p>当浏览器载入 HTML 文档，浏览器会解析它并创建一个DOM树。在DOM树中，HTML文档中的每个元素都被表示为<strong>一个节点，</strong>根节点为 <strong><code>Document</code> 对象，</strong>使我们可以从脚本中对 HTML 页面中的所有元素进行访问。。这些节点具有属性和方法，允许你通过编程的方式与它们进行交互。</p>
<p>在 HTML DOM (Document Object Model) 中 ，每一个元素都是<strong>节点</strong>:</p>
<ul>
<li>文档是一个<strong>文档节点</strong>。</li>
<li>所有的HTML元素都是<strong>元素节点</strong>。</li>
<li>所有 HTML 属性都是<strong>属性节点</strong>。</li>
<li>文本插入到 HTML 元素是<strong>文本节点</strong>。</li>
<li>注释是<strong>注释节点</strong>。</li>
</ul>
<blockquote>
<p><code>Document</code> 对象是 <code>Window</code> 对象的一部分，可通过 <code>window.document</code>属性对其进行访问。</p>
</blockquote>
<p><strong>Document 对象属性和方法：</strong></p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<p><strong>常用DOM API：</strong></p>
<p><strong>（1）创建DOM对象</strong></p>
<pre><code class="jsx">var el2 = document.createElement(&#39;input&#39;);
var node = document.createTextNode(&#39;hello world!&#39;);
</code></pre>
<p><strong>（2）查找DOM对象</strong></p>
<pre><code class="jsx">*// 返回当前文档中第一个类名为 &quot;myclass&quot; 的元素*
var el = document.querySelector(&quot;.myclass&quot;);

*// 返回一个文档中所有的class为&quot;note&quot;或者 &quot;alert&quot;的div元素*
var els = document.querySelectorAll(&quot;div.note, div.alert&quot;);

*// 获取元素*
var el = document.getElementById(&#39;xxx&#39;);
var els = document.getElementsByClassName(&#39;highlight&#39;);
var els = document.getElementsByTagName(&#39;td&#39;);

// 获取父元素、父节点
var parent = ele.parentElement;
var parent = ele.parentNode;

// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断
var nodes = ele.children;    

// 查询子元素
var els = ele.getElementsByTagName(&#39;td&#39;);
var els = ele.getElementsByClassName(&#39;highlight&#39;);

// 当前元素的第一个/最后一个子元素节点
var el = ele.firstElementChild;
var el = ele.lastElementChild;

// 下一个/上一个兄弟元素节点
var el = ele.nextElementSibling;
var el = ele.previousElementSibling;
</code></pre>
<p><strong>（3）更改DOM对象</strong></p>
<pre><code class="jsx">*// 添加、删除子元素*
ele.appendChild(el);
ele.removeChild(el);

*// 替换子元素*
ele.replaceChild(el1, el2);

*// 插入子元素*
parentElement.insertBefore(newElement, referenceElement);
</code></pre>
<p><strong>（4）操作DOM对象的属性</strong></p>
<pre><code class="jsx">*// 获取一个&#123;name, value&#125;的数组*
var attrs = el.attributes;

*// 获取、设置属性*
var c = el.getAttribute(&#39;class&#39;);
el.setAttribute(&#39;class&#39;, &#39;highlight&#39;);

*// 判断、移除属性*
el.hasAttribute(&#39;class&#39;);
el.removeAttribute(&#39;class&#39;);

*// 是否有属性设置*
el.hasAttributes();
</code></pre>
<h3 id="元素对象"><a href="#元素对象" class="headerlink" title="元素对象"></a>元素对象</h3><p>以下是HTML中常见的元素节点类型及其分类列举：</p>
<ol>
<li><p><strong>文档结构元素</strong>：</p>
<ul>
<li><code>&lt;html&gt;</code>: 根元素，包含了整个HTML文档。</li>
<li><code>&lt;head&gt;</code>: 包含了文档的元（meta）数据，如<code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>等。</li>
<li><code>&lt;body&gt;</code>: 包含了所有可见的页面内容，如文本、图片、音频、视频等。</li>
</ul>
</li>
<li><p><strong>标题元素</strong>：</p>
<ul>
<li><code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code>: 定义标题或子标题，<code>&lt;h1&gt;</code>表示最高级别的标题。</li>
</ul>
</li>
<li><p><strong>段落元素</strong>：</p>
<ul>
<li><code>&lt;p&gt;</code>: 定义段落。</li>
</ul>
</li>
<li><p><strong>列表元素</strong>：</p>
<ul>
<li><code>&lt;ul&gt;</code>: 无序列表（unordered list）。</li>
<li><code>&lt;ol&gt;</code>: 有序列表（ordered list）。</li>
<li><code>&lt;li&gt;</code>: 列表项（list item）。</li>
</ul>
</li>
<li><p><strong>链接元素</strong>：</p>
<ul>
<li><p><code>&lt;a&gt;</code>: 定义超链接，可以链接到其他网页或同一网页的不同部分</p>
<ul>
<li><code>href</code>：指定链接的目标地址</li>
<li><code>target</code>：指定在何处打开链接的文档</li>
<li><code>rel</code>：定义当前文档与被链接文档之间的关系</li>
</ul>
<pre><code class="jsx">&lt;a href=&quot;https://example.com&quot; 
target=&quot;_blank&quot; 
rel=&quot;noopener noreferrer&quot;&gt;链接文本&lt;/a&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>图像元素</strong>：</p>
<ul>
<li><p><code>&lt;img&gt;</code>: 定义图像，通常与<code>src</code>、<code>alt</code>等属性一起使用</p>
<ul>
<li><code>src</code>：指定图像的来源</li>
<li><code>alt</code>：为图像提供替代文本，以便在图像无法显示时显示</li>
<li><code>width</code> 和 <code>height</code>：指定图像的宽度和高度</li>
</ul>
<pre><code class="jsx">&lt;img src=&quot;image.jpg&quot; alt=&quot;示例图片&quot; width=&quot;500&quot; height=&quot;600&quot;&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>表格元素</strong>：</p>
<ul>
<li><code>&lt;table&gt;</code>: 定义表格。</li>
<li><code>&lt;tr&gt;</code>: 定义表格行。</li>
<li><code>&lt;th&gt;</code>: 定义表格头部单元格。</li>
<li><code>&lt;td&gt;</code>: 定义表格数据单元格。</li>
</ul>
</li>
<li><p><strong>表单元素</strong>：</p>
<ul>
<li><code>&lt;form&gt;</code>: 定义HTML表单，用于用户输入。</li>
<li><code>&lt;input&gt;</code>: 定义输入字段，如文本框、密码框、单选框、复选框等<ul>
<li><code>type</code>、<code>name</code>、<code>value</code></li>
</ul>
</li>
<li><code>&lt;textarea&gt;</code>: 定义多行文本输入字段<ul>
<li><code>rows</code>、<code>cols</code></li>
</ul>
</li>
<li><code>&lt;button&gt;</code>: 定义点击按钮。</li>
<li><code>&lt;select&gt;</code>: 定义下拉选择列表<ul>
<li><code>name</code>、<code>value</code></li>
</ul>
</li>
<li><code>&lt;option&gt;</code>: 定义下拉选择列表中的选项<ul>
<li><code>name</code>、<code>value</code></li>
</ul>
</li>
</ul>
<pre><code class="jsx">&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;&gt;  
&lt;textarea rows=&quot;4&quot; cols=&quot;50&quot;&gt;默认文本&lt;/textarea&gt;  
&lt;select name=&quot;color&quot;&gt;  
  &lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;  
  &lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;  
&lt;/select&gt;
</code></pre>
</li>
<li><p><strong>分区和布局元素</strong>：</p>
<ul>
<li><code>&lt;div&gt;</code>: 定义一个区块或容器，通常与CSS一起使用来布局页面。</li>
<li><code>&lt;span&gt;</code>: 定义内联元素，通常用于对文本的一部分应用样式。</li>
<li><code>&lt;section&gt;</code>: 定义文档中的独立部分或章节。</li>
<li><code>&lt;article&gt;</code>: 定义独立的内容，如博客文章、论坛帖子等。</li>
<li><code>&lt;nav&gt;</code>: 定义导航链接的容器。</li>
<li><code>&lt;header&gt;</code>: 定义文档的页眉或区域页眉。</li>
<li><code>&lt;footer&gt;</code>: 定义文档的页脚或区域页脚。</li>
</ul>
</li>
<li><p><strong>媒体元素</strong>：</p>
<ul>
<li><code>&lt;audio&gt;</code>: 定义音频内容。</li>
<li><code>&lt;video&gt;</code>: 定义视频内容。</li>
</ul>
</li>
<li><p><strong>其他常见元素</strong>：</p>
<ul>
<li><code>&lt;br&gt;</code>: 插入一个简单的换行符。</li>
<li><code>&lt;hr&gt;</code>: 创建水平线。</li>
<li><code>&lt;meta&gt;</code>: 提供关于HTML文档的元信息。</li>
<li><code>&lt;link&gt;</code>: 定义文档与外部资源之间的关系。</li>
<li><code>&lt;style&gt;</code>: 定义内部样式信息。</li>
<li><code>&lt;script&gt;</code>: 定义客户端脚本，如JavaScript代码。</li>
</ul>
</li>
</ol>
<p>以下属性和方法可适用于所有 HTML 元素：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<blockquote>
<p><em>如果你只需要在特定的元素上监听事件，那么使用 <code>element.addEventListener()</code> 通常是更好的选择，因为它更具体，并且可以减少不必要的计算。然而，如果你需要在整个文档中监听某种类型的事件（例如，点击任何元素或键盘输入），那么使用 <code>document.addEventListener()</code> 可能是更合适的选择。</em></p>
</blockquote>
<h3 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h3><p>所有主流浏览器都支持 Attr 对象，以下是一些常见的属性对象的属性和方法：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>简单来讲，事件就是一个动作，而 HTML 为这些动作指定了特定的对象，和 DOM 对象一样，事件不属于任何一门语言，但是可以作为元素（DOM对象）的属性嵌入元素中，也就是指定该元素为触发对象，当在该元素中触发了指定的事件时，就可以执行该事件绑定在该元素上的JavaScript代码。</p>
<p><strong>DOM中的事件是如何触发的？</strong></p>
<ol>
<li><strong>事件源</strong>：事件的触发首先需要一个事件源，也就是引发事件的HTML元素。例如，当用户点击一个按钮时，这个按钮就是事件源。</li>
<li><strong>事件类型</strong>：每个事件都有一个类型，如“click”、“keydown”等。当事件源上发生与事件类型匹配的动作时，事件就会被触发。</li>
<li><strong>事件监听器</strong>：为了处理事件，需要在事件源上注册一个或多个事件监听器（也称为事件处理器）。事件监听器是一个函数，当事件被触发时，这个函数会被调用。在JavaScript中，通常使用<code>addEventListener()</code>方法为元素添加事件监听器。</li>
<li><strong>事件流</strong>：DOM事件流描述了事件从发生到被处理的过程。这个过程包括三个阶段：捕获阶段、目标阶段和冒泡阶段。<ul>
<li><strong>捕获阶段</strong>：从document对象开始，沿着DOM树向下传播，直到到达事件源。在捕获阶段，事件监听器可以被注册在DOM树的任何节点上，但默认情况下，事件监听器不会在捕获阶段被触发（除非在注册时特别指定）。</li>
<li><strong>目标阶段</strong>：当事件到达事件源时，会触发注册在该元素上的事件监听器。</li>
<li><strong>冒泡阶段</strong>：事件从事件源开始，沿着DOM树向上传播，直到回到document对象。在冒泡阶段，所有经过的节点（包括事件源本身）上注册的事件监听器都会被触发。<em>举个例子，两个元素A和B绑定了不同的点击事件，并且B元素在A元素的内部，那么在点击了B时，B事件会先发生，然后A事件发生。</em></li>
</ul>
</li>
<li><strong>事件处理</strong>：当事件监听器被触发时，会执行相应的函数。这个函数可以执行任何需要的操作，如修改页面内容、发送网络请求等。</li>
</ol>
<aside>
💡 *1. 不同浏览器对DOM事件的支持可能有所不同。例如，一些较旧的浏览器可能不支持某些事件类型或事件流特性。
2. DOM 0级事件（直接在HTML元素上添加事件监听器，如`element.onclick = function() {...};`）和DOM 2级事件（使用`addEventListener()`方法添加事件监听器）在事件处理机制上也有所不同。DOM 0级事件只能在事件的目标阶段处理事件，而DOM 2级事件则可以在捕获阶段、目标阶段和冒泡阶段处理事件。*


</aside>

<p>以下是一些常见的<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/dom-obj-event.html">DOM事件</a>：</p>
<ol>
<li><strong>鼠标事件</strong>：<ul>
<li><code>click</code>：当用户在元素上单击鼠标按钮时触发。</li>
<li><code>dblclick</code>：当用户在元素上双击鼠标按钮时触发。</li>
<li><code>mousedown</code>：当用户在元素上按下鼠标按钮时触发。</li>
<li><code>mouseup</code>：当用户在元素上释放鼠标按钮时触发。</li>
<li><code>mousemove</code>：当鼠标指针在元素内部移动时触发。</li>
<li><code>mouseover</code>：当鼠标指针从元素外部移动到元素内部时触发。</li>
<li><code>mouseout</code>：当鼠标指针从元素内部移动到元素外部时触发。</li>
<li><code>contextmenu</code>：当用户在元素上右键点击时触发（通常用于显示上下文菜单）。</li>
</ul>
</li>
<li><strong>键盘事件</strong>：<ul>
<li><code>keydown</code>：当用户在键盘上按下某个键时触发。</li>
<li><code>keyup</code>：当用户在键盘上释放某个键时触发。</li>
<li><code>keypress</code>：当用户在键盘上按下并释放一个键时触发（通常用于处理文本输入）。</li>
</ul>
</li>
<li><strong>表单事件</strong>：<ul>
<li><code>submit</code>：当表单提交时触发（常用于验证表单数据）。</li>
<li><code>reset</code>：当表单重置时触发。</li>
<li><code>focus</code>：当元素获得焦点时触发（例如，用户点击输入框）。</li>
<li><code>blur</code>：当元素失去焦点时触发（例如，用户离开输入框）。</li>
<li><code>change</code>：当元素的值发生变化且失去焦点时触发（常用于输入框和下拉列表）。</li>
</ul>
</li>
<li><strong>文档&#x2F;窗口事件</strong>：<ul>
<li><code>load</code>：当页面或图片加载完成时触发。</li>
<li><code>unload</code>：当用户离开页面时触发（例如，关闭页面或跳转到其他页面）。</li>
<li><code>scroll</code>：当用户滚动页面时触发。</li>
<li><code>resize</code>：当浏览器窗口大小发生变化时触发。</li>
</ul>
</li>
<li><strong>触摸事件</strong>（主要针对移动设备）：<ul>
<li><code>touchstart</code>：当用户触摸屏幕时触发。</li>
<li><code>touchmove</code>：当用户在屏幕上移动手指时触发。</li>
<li><code>touchend</code>：当用户从屏幕上移开手指时触发。</li>
<li><code>touchcancel</code>：当系统取消触摸事件时触发（例如，电话呼入）。</li>
</ul>
</li>
<li><strong>拖放事件</strong>：<ul>
<li><code>dragstart</code>：当用户开始拖动元素时触发。</li>
<li><code>drag</code>：当用户在拖动元素时触发。</li>
<li><code>dragend</code>：当用户结束拖动元素时触发。</li>
<li><code>dragenter</code>：当拖动的元素进入目标元素时触发。</li>
<li><code>dragover</code>：当拖动的元素在目标元素上移动时触发。</li>
<li><code>dragleave</code>：当拖动的元素离开目标元素时触发。</li>
<li><code>drop</code>：当用户在目标元素上释放拖动的元素时触发。</li>
</ul>
</li>
<li><strong>其他事件</strong>：<ul>
<li><code>error</code>：当发生错误时触发（例如，图片加载失败）。</li>
<li><code>abort</code>：当加载被中止时触发（例如，用户停止加载页面）。</li>
<li><code>beforeunload</code>：当页面即将卸载（关闭、刷新或跳转到其他页面）时触发。</li>
</ul>
</li>
</ol>
<h2 id="Browser-Object-Model"><a href="#Browser-Object-Model" class="headerlink" title="Browser Object Model"></a><strong>Browser Object Model</strong></h2><p>BOM是浏览器对象模型，DOM 是将HTML文档中的各个元素封装成一个对象（Document），而 <strong>BOM</strong> 则是将一个浏览器的各个组成部分封装成对象（Browser）供调用使用。</p>
<p>BOM的核心对象是<code>window</code>，它表示浏览器的一个实例（通常就是浏览器窗口或标签页）。由于<code>window</code>是BOM的顶层对象，其他BOM对象都是它的子对象或者方法。</p>
<h3 id="BOM的组成部分"><a href="#BOM的组成部分" class="headerlink" title="BOM的组成部分"></a>BOM的组成部分</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/15/DB/Untitled1.png" alt="Untitled" class="lazyload"></p>
<p>图中看出，BOM 对象大致包含五个部分：</p>
<ul>
<li>Window 对象：浏览器窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：浏览器所处客户端的显示器屏幕对象</li>
<li>History：浏览器当前窗口的访问历史记录对象</li>
<li>Location：浏览器当前窗口的地址栏对象</li>
</ul>
<h3 id="窗口对象window"><a href="#窗口对象window" class="headerlink" title="窗口对象window"></a><strong>窗口对象window</strong></h3><p>BOM 的核心是 <code>window</code> 窗口对象对象，表示浏览器的实例。<code>window</code> 对象在浏览器中有两重身份，一个是全局对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有对象、变量和函数都以 <code>window</code> 作为其 Global 对象，都可以访问其上定义全局方法。</p>
<p>window对象不需要创建可以直接使用，<code>window.方法名();</code>，甚至可以把window直接省略<code>方法名();</code></p>
<p>以下是一些常见的<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/obj-window.html">Window对象方法</a>：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<p>以下是一些常用的<code>window</code>属性：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<p>一些使用示例：</p>
<pre><code class="jsx">var userInput = window.confirm(&quot;你确定要继续吗?&quot;);  
if (userInput) &#123;  
  console.log(&quot;用户点击确定&quot;);  
&#125; else &#123;  
  console.log(&quot;用户点击取消或关闭&quot;);  
&#125;

var userName = window.prompt(&quot;请输入你的姓名:&quot;, &quot;默认姓名&quot;);  
if (userName != null) &#123;  
  console.log(&quot;你好，&quot; + userName + &quot;!&quot;);  
&#125; else &#123;  
  console.log(&quot;用户未输入姓名或点击了取消&quot;);  
&#125;

&lt;button id=&quot;openWindow&quot;&gt;打开窗口&lt;/button&gt;
&lt;button id=&quot;closeWindow&quot;&gt;关闭窗口&lt;/button&gt;
&lt;script&gt;
    var openWindow = document.getElementById(&quot;openWindow&quot;);
    var newWindow; //全局变量，对新创建的窗口进行操作
    openWindow.onclick = function()&#123;
        newWindow = open(&quot;https://www.baidu.com&quot;); //打开指定url的窗口
    &#125;
        
    var closeWindow = document.getElementById(&quot;closeWindow&quot;);
    closeWindow.onclick = function()&#123;
        newWindow.close(); //关闭调用它的窗口
    &#125;
&lt;/script&gt;

var myTimer = setTimeout(function() &#123;  
  console.log(&quot;Hello, World!&quot;);  
&#125;, 2000); // 2秒后执行  
  
// 取消定时器  
clearTimeout(myTimer);
</code></pre>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a><code>history</code></h3><p>该对象保存着用户上网的历史记录。出于安全方面的考虑，开发人员无法得知用户浏览过的URL，不过借由用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退前进</p>
<ul>
<li><code>length</code>：返回历史列表中的网址数</li>
<li><code>back()</code>：加载 <code>history</code> 列表中的前一个 URL</li>
<li><code>forward()</code>：加载 <code>history</code> 列表中的下一个 URL</li>
<li><code>go()</code>：加载 <code>history</code> 列表中的某个具体页面，负数表示向后跳转，正数表示向前跳转</li>
</ul>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a><code>location</code></h3><p>浏览器当前窗口的<strong>地址栏对象，</strong>通过<code>window.location</code>对象，可以解析URL、重定向浏览器到新的页面、重新加载当前页面等</p>
<ul>
<li><code>window.location.href</code>：获取或设置当前页面的完整URL。</li>
<li><code>window.location.protocol</code>：获取URL的协议部分（如 <code>&quot;http:&quot;</code> 或 <code>&quot;https:&quot;</code>）。</li>
<li><code>window.location.host</code>：获取URL的主机名和端口号（如果有）。</li>
<li><code>window.location.hostname</code>：获取URL的主机名。</li>
<li><code>window.location.pathname</code>：获取URL的路径名。</li>
<li><code>window.location.search</code>：获取URL的查询字符串部分（包括问号）。</li>
<li><code>window.location.hash</code>：获取URL的哈希（锚点）部分。</li>
</ul>
<p><strong>location对象中的方法：</strong></p>
<pre><code class="jsx">&lt;button&gt;跳转页面&lt;/button&gt;
&lt;button&gt;替换页面&lt;/button&gt;
&lt;button&gt;刷新页面&lt;/button&gt;
&lt;script&gt;
  var btn = document.getElementsByTagName(&#39;button&#39;);//返回值为一个类数组
  btn[0].onclick = function () &#123;
    location.assign(&#39;./test2.html&#39;)
  &#125;
  btn[1].onclick = function () &#123;
    location.replace(&#39;./test2.html&#39;)
  &#125;
  btn[2].onclick = function () &#123;
    location.reload()
  &#125;
&lt;/script&gt;
</code></pre>
<ul>
<li><code>assign()</code>：传递一个url参数，打开新url，替换当前页面，并在浏览记录中生成一条记录，页面替换后可以返回上一个页面</li>
<li><code>replace()</code>：参数为一个url，打开新url，替换当前页面，不会在历史记录中生成新记录，替换页面后无法再次返回之前页面</li>
<li><code>reload()</code>：重新加载当前显示的页面，参数可以为<code>boolean</code>类型，默认为<code>false</code>，表示以最有效方式重新加载，可能从缓存中直接加载。如果参数为<code>true</code>，强制从服务器中重新加载</li>
</ul>
<h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a><code>navigator</code></h3><p>浏览器对象，提供了与浏览器相关的信息和操作接口。在前端开发中，通常使用<code>Navigator</code>对象来获取用户浏览器的相关信息，例如浏览器的名称、版本、语言设置、设备类型、操作系统等。这些信息对于实现浏览器兼容性、设备适配等功能非常重要。<code>Navigator</code>对象还包含了一些方法和属性，用于获取当前设备的地理位置信息、访问设备的媒体设备等</p>
<ul>
<li><code>navigator.appName</code>：浏览器名称；注意：<code>“Netscape”</code>是 IE11、Chrome、Firefox 以及 Safari 的应用程序名称的统称；</li>
<li><code>navigator.appVersion</code>：浏览器版本；</li>
<li><code>navigator.appCodeName</code>：返回浏览器的应用程序代码名称</li>
<li><code>navigator.language</code>：浏览器设置的语言；</li>
<li><code>navigator.platform</code>：操作系统类型；</li>
<li><code>navigator.userAgent</code>：返回用户代理头的字符串表示（通常是浏览器类型、版本和操作系统信息）；</li>
<li><code>navigator.cookieEnabled</code>：返回一个布尔值，表示是否启用<code>cookie</code>；</li>
<li><code>navigator.product</code>：返回浏览器引擎的产品名称</li>
</ul>
<h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a><code>screen</code></h3><ul>
<li><code>screen.width</code>和<code>screen.height</code>：屏幕总宽度&#x2F;高度</li>
<li><code>screen.availWidth</code>和<code>screen.availHeight</code>：可用宽度&#x2F;高度，（即减去系统界面元素后的宽度和高度）</li>
<li><code>screen.colorDepth</code>：颜色深度</li>
<li><code>screen.pixelDepth</code>：颜色分辨率</li>
</ul>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/15/gongju/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/nodejs.png" data-sizes="auto" alt="Node常用工具模块" class="lazyload">
                    <h1>Node常用工具模块</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>单纯针对路径的操作，对文件没有关联，因此即使文件不存在也没关系</p>
<ul>
<li><code>path.basename(dir)</code> ：返回路径的最后一部分</li>
<li><code>path.dirname(dir)</code> ：返回路径除了最后一部分的部分</li>
<li><code>path.format(dir)</code> ：将对象解析为路径并返回</li>
<li><code>path.parse(dir)</code> ：将路径解析为对象并返回</li>
<li><code>path.resolve(dir)</code> ：将一个路径解析为绝对路径并返回</li>
<li><code>path.join(dir)</code>或<code>path.join([...paths])</code> ：将路径拼接并返回</li>
<li><code>path.extname(path)</code>：返回路径的扩展名</li>
</ul>
<p>两个全局变量：</p>
<ul>
<li><code>__dirname</code> ：当前文件的绝对路径</li>
<li><code>__filename</code> ：当前文件的绝对路径加文件名</li>
</ul>
<pre><code class="jsx">let path = require(&#39;path&#39;)
let demo = &#39;./src/a/b/c.js&#39;
console.log(path.basename(demo))
// 输出c.js
console.log(path.dirname(demo))
// 输出./src/a/b/c.js
console.log(path.parse(demo))
//输出&#123; root: &#39;&#39;, dir: &#39;./src/a/b&#39;, base: &#39;c.js&#39;, ext: &#39;.js&#39;, name: &#39;c&#39; &#125;
console.log(path.format(&#123; root: &#39;&#39;, dir: &#39;./src/a/b&#39;, base: &#39;c.js&#39;, ext: &#39;.js&#39;, name: &#39;c&#39; &#125;))
console.log(__dirname)
// 输出/Users/v/nodeStudy
console.log(__filename)
// 输出/Users/v/nodeStudy/code.js
console.log(path.resolve(__dirname,&#39;./do&#39;))
// 输出/Users/v/nodeStudy/do
console.log(path.resolve(&#39;../&#39;,&#39;./u&#39;))
// 输出/Users/v/u
console.log(path.join(&#39;./love&#39;,&#39;/me&#39;))
// 输出love/me
</code></pre>
<h2 id="process全局对象"><a href="#process全局对象" class="headerlink" title="process全局对象"></a>process全局对象</h2><p>在Node.js中，<code>process</code>是一个全局对象，提供了与当前Node.js进程互动的信息和功能</p>
<p>属性：</p>
<ul>
<li><p><code>env</code>：用户环境信息，比如webpack打包的时候，都是要读环境信息的</p>
<pre><code class="jsx">&#123;
  WEBIDE_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/webide.vmoptions&#39;,
  PHPSTORM_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/phpstorm.vmoptions&#39;,
  GATEWAY_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/gateway.vmoptions&#39;,
  STUDIO_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/studio.vmoptions&#39;,
  MallocNanoZone: &#39;0&#39;,
  USER: &#39;v&#39;,
  __CFBundleIdentifier: &#39;com.microsoft.VSCode&#39;,
  COMMAND_MODE: &#39;unix2003&#39;,
  DATAGRIP_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/datagrip.vmoptions&#39;,
  PATH: &#39;/Users/v/ML/Anaconda/anaconda3/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Library/TeX/texbin:/Applications/VMware Fusion.app/Contents/Public:/Users/v/ML/Anaconda/anaconda3/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/apache-maven-3.8.6/bin:/usr/local/mysql/bin:/Users/v/Library/Android/idk/emulator:/Users/v/Library/Android/idk/tools:/Users/v/Library/Android/idk/tools/bin:/Users/v/Library/Android/idk/platform-tools:/usr/local/apache-maven-3.8.6/bin:/usr/local/mysql/bin:/Users/v/Library/Android/idk/emulator:/Users/v/Library/Android/idk/tools:/Users/v/Library/Android/idk/tools/bin:/Users/v/Library/Android/idk/platform-tools&#39;,
  RUBYMINE_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/rubymine.vmoptions&#39;,
  DATASPELL_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/dataspell.vmoptions&#39;,
  LOGNAME: &#39;v&#39;,
  SSH_AUTH_SOCK: &#39;/private/tmp/com.apple.launchd.fvq04dfldB/Listeners&#39;,
  RIDER_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/rider.vmoptions&#39;,
  JETBRAINSCLIENT_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/jetbrainsclient.vmoptions&#39;,
  SHELL: &#39;/bin/zsh&#39;,
  JETBRAINS_CLIENT_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/jetbrains_client.vmoptions&#39;,
  APPCODE_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/appcode.vmoptions&#39;,
  HOME: &#39;/Users/v&#39;,
  DEVECOSTUDIO_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/devecostudio.vmoptions&#39;,
  CLION_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/clion.vmoptions&#39;,
  GOLAND_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/goland.vmoptions&#39;,
  PYCHARM_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/pycharm.vmoptions&#39;,
  WEBSTORM_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/webstorm.vmoptions&#39;,
  IDEA_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/idea.vmoptions&#39;,
  TMPDIR: &#39;/var/folders/ql/878t6sxs55zd1_l592j7ffxr0000gn/T/&#39;,
  __CF_USER_TEXT_ENCODING: &#39;0x1F5:0x19:0x34&#39;,
  XPC_SERVICE_NAME: &#39;0&#39;,
  XPC_FLAGS: &#39;0x0&#39;,
  ORIGINAL_XDG_CURRENT_DESKTOP: &#39;undefined&#39;,
  SHLVL: &#39;1&#39;,
  PWD: &#39;/Users/v/mywork/myNode&#39;,
  OLDPWD: &#39;/Users/v/mywork/myNode&#39;,
  HOMEBREW_BOTTLE_DOMAIN: &#39;https://mirrors.ustc.edu.cn/homebrew-bottles&#39;,
  HOMEBREW_PREFIX: &#39;/opt/homebrew&#39;,
  HOMEBREW_CELLAR: &#39;/opt/homebrew/Cellar&#39;,
  HOMEBREW_REPOSITORY: &#39;/opt/homebrew&#39;,
  MANPATH: &#39;/opt/homebrew/share/man:/usr/share/man:/usr/local/share/man:/Library/TeX/Distributions/.DefaultTeX/Contents/Man:/opt/homebrew/share/man::&#39;,
  INFOPATH: &#39;/opt/homebrew/share/info:/opt/homebrew/share/info:&#39;,
  M2_HOME: &#39;/usr/local/apache-maven-3.8.6&#39;,
  ANDROID_HOME: &#39;/Users/v/Library/Android/idk&#39;,
  TERM_PROGRAM: &#39;vscode&#39;,
  TERM_PROGRAM_VERSION: &#39;1.89.0&#39;,
  LANG: &#39;zh_CN.UTF-8&#39;,
  COLORTERM: &#39;truecolor&#39;,
  GIT_ASKPASS: &#39;/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh&#39;,
  VSCODE_GIT_ASKPASS_NODE: &#39;/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)&#39;,
  VSCODE_GIT_ASKPASS_EXTRA_ARGS: &#39;&#39;,
  VSCODE_GIT_ASKPASS_MAIN: &#39;/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js&#39;,
  VSCODE_GIT_IPC_HANDLE: &#39;/var/folders/ql/878t6sxs55zd1_l592j7ffxr0000gn/T/vscode-git-f81461131c.sock&#39;,
  VSCODE_INJECTION: &#39;1&#39;,
  ZDOTDIR: &#39;/Users/v&#39;,
  USER_ZDOTDIR: &#39;/Users/v&#39;,
  TERM: &#39;xterm-256color&#39;,
  _: &#39;/usr/local/bin/node&#39;
&#125;
</code></pre>
<p>该属性对象的最大作用是判断当前的驱动环境：注入不同的开发环境，在运行脚本时对环境进行判断，不同环境做不同的事情</p>
<pre><code class="jsx">console.log(process.env.MODE_ENV=&#39;script&#39;)
console.log(process.env.MODE_ENV)
</code></pre>
</li>
<li><p><code>argv</code>：启动node时的命令行参数，是用户自己定义的参数，写在末尾，比如webpack打包的时候，输入的<code>—help</code> 就是通过<code>argv</code>来读取的</p>
</li>
<li><p><code>execArgv</code>：node命令后的直接参数，是node自带的参数，写在node后面</p>
</li>
<li><p><code>stdout</code>和<code>stdin</code>：屏幕输出和输入对象</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li><p><code>cwd()</code> ：获取当前进程工作目录，该方法和<code>__dirname</code> 看似一样，但是当你<code>cd</code> 到上级目录后，<code>__dirname</code> 随之改变，但是工作进程目录是不变的，你的js文件在哪个目录，它就永远是哪个目录</p>
</li>
<li><p><code>exit()</code> ：退出进程</p>
</li>
<li><p><code>memoryUsage()</code> ：获取内存使用情况</p>
<pre><code class="jsx">&#123;
  rss: 31670272,
  heapTotal: 4227072,
  heapUsed: 2977752,
  external: 1080724,
  arrayBuffers: 10515
&#125;
</code></pre>
<p><code>rss</code>为node总内存，<code>heapTotal</code>为node堆内存，<code>heapUsed</code>为已使用内存，<code>external</code>为调用C++的额外内存，<code>arrayBuffers</code>是<code>buffer</code>内存</p>
</li>
</ul>
<p><strong>示例1：获取和修改环境变量</strong></p>
<pre><code class="jsx">// 获取环境变量  
const envVar = process.env.LOGNAME;  
console.log(envVar);  
  
// 修改环境变量（注意：这不会修改父进程或操作系统的环境变量，只会影响当前Node.js进程）  
process.env.LOGNAME = &#39;new value&#39;;  
console.log(process.env.LOGNAME); // 输出 &#39;new value&#39;
</code></pre>
<p><strong>示例2：监听进程事件</strong></p>
<pre><code class="jsx">// 监听退出事件  
process.on(&#39;exit&#39;, (code) =&gt; &#123;  
  console.log(`About to exit with code: $&#123;code&#125;`);  
&#125;);  
  
// 当Node.js接收到SIGTERM或SIGINT信号时，会触发&#39;exit&#39;事件  
process.kill(process.pid, &#39;SIGTERM&#39;); // 这将导致进程退出并触发&#39;exit&#39;事件  
  
// 监听未捕获的异常  
process.on(&#39;uncaughtException&#39;, (err) =&gt; &#123;  
  console.error(&#39;Uncaught Exception:&#39;, err);  
  process.exit(1); // 强制退出进程  
&#125;);  
  
// 抛出一个未捕获的异常来触发&#39;uncaughtException&#39;事件  
setTimeout(() =&gt; &#123;  
  throw new Error(&#39;This is an uncaught exception&#39;);  
&#125;, 100);
</code></pre>
<p><strong>示例3：获取进程信息</strong></p>
<pre><code class="jsx">// 获取当前进程的PID  
console.log(&#39;Process ID:&#39;, process.pid);  
  
// 获取当前进程的标题（可以通过process.title修改）  
console.log(&#39;Process title:&#39;, process.title);  
  
// 获取当前Node.js的版本  
console.log(&#39;Node.js version:&#39;, process.version);  
  
// 获取当前Node.js平台的架构  
console.log(&#39;Platform architecture:&#39;, process.arch);  
  
// 获取当前操作系统平台  
console.log(&#39;Operating system platform:&#39;, process.platform);
</code></pre>
<p><strong>示例4：发送信号给进程</strong></p>
<pre><code class="jsx">// 发送信号给当前进程（这通常不是一个好实践，但只是为了演示）  
process.kill(process.pid, &#39;SIGTERM&#39;); // 这将导致进程退出  
  
// 在实际中，你可能会发送信号给子进程或其他进程  
// 例如，使用child_process模块创建子进程后，可以使用process.kill发送信号
</code></pre>
<p><strong>示例5：获取工作台输入</strong></p>
<pre><code class="jsx">process.stdout.write(&#39;请输入一个数字&#39;)
process.stdin.on(&#39;data&#39;,res=&gt;&#123;
    console.log(res.toString())
        process.exit()
&#125;)
</code></pre>
<p>使用<code>on</code>对<code>stdin</code>进行监听，一旦获取到<code>data</code>，就执行回调函数，以实现和控制台的交互。比如vue-cli打包的时候，一直通过控制台和用户交互，用的就是这种方式</p>
<h2 id="util工具模块"><a href="#util工具模块" class="headerlink" title="util工具模块"></a>util工具模块</h2><p>该模块提供了许多实用的工具函数，使得开发者能够更便捷地进行各种常见的操作</p>
<p>类型判断：</p>
<ul>
<li><code>util.isArray(object)</code></li>
<li><code>util.isBoolean(object)</code></li>
<li><code>util.isNull(object)</code></li>
<li><code>util.isNullOrUndefined(object)</code></li>
<li><code>util.isNumber(object)</code></li>
<li><code>util.isString(object)</code></li>
<li><code>util.isSymbol(object)</code></li>
<li><code>util.isUndefined(object)</code></li>
<li><code>util.isObject(object)</code>：判断一个对象是否是一个对象（不是数组、null、undefined、字符串、数字、布尔值或 Symbol）</li>
<li><code>util.isPrimitive(object)</code>：判断一个对象是否是原始类型（字符串、数字、布尔值、Symbol 或 null）</li>
<li><code>util.isFunction(object)</code>：判断一个对象是否是一个函数</li>
<li><code>util.isRegExp(object)</code>：判断一个对象是否是一个正则表达式</li>
<li><code>util.isError(object)</code>：判断一个对象是否是一个 Error 对象</li>
<li><code>util.types</code>：这是一个对象，提供了各种用于检查对象类型的函数，如 <code>util.types.isBigInt64Array(object)</code>、<code>util.types.isBigUint64Array(object)</code> 等。</li>
</ul>
<p>回调转换：</p>
<ul>
<li><code>util.promisify(original)</code>：把异步函数包装为<code>promise</code>对象形式</li>
</ul>
<pre><code class="jsx">let util = require(&#39;util&#39;)
let fs = require(&#39;fs&#39;)

fs.readFile(&#39;./test.txt&#39;, (error, content) =&gt; &#123;
    console.log(content.toString())
&#125;)
//转换为Promise形式以后，可以使用then API了
const promiseReadFile = util.promisify(fs.readFile)
promiseReadFile(&#39;./test.txt&#39;).then(res =&gt; &#123;
    console.log(res.toString())
&#125;)
</code></pre>
<ul>
<li><code>util.callbackify(asyncFn)</code>：将一个返回值为<code>promise</code>的函数改为回调</li>
</ul>
<pre><code class="jsx">let util = require(&#39;util&#39;)
function f1() &#123;
    return new Promise(
        res =&gt; &#123;
            setTimeout(() =&gt; &#123;
                res(20)
                //回调产生一个值10
            &#125;, 2000)
        &#125;
    )
&#125;
const callbackf1 = util.callbackify(f1)
callbackf1(function (num) &#123;
    console.log(num)
&#125;)
</code></pre>
<h2 id="fs文件模块"><a href="#fs文件模块" class="headerlink" title="fs文件模块"></a>fs文件模块</h2><p><code>fs</code>模块是Node.js中用于与文件系统进行交互的核心模块之一</p>
<h3 id="常用文件操作"><a href="#常用文件操作" class="headerlink" title="常用文件操作"></a>常用文件操作</h3><ol>
<li><p>读取文件：<code>readFile</code></p>
<pre><code class="jsx">fs.readFile(&#39;example.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; &#123;  
  if (err) throw err;  
  console.log(data);  
&#125;);
</code></pre>
</li>
<li><p>写入并创建文件，如果文件已存在，已存在的文件将被覆盖：<code>writeFile</code></p>
<pre><code class="jsx">fs.writeFile(&#39;example.txt&#39;, &#39;Hello, World!&#39;, &#39;utf8&#39;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;The file has been saved!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>向文件末尾追加内容，如果文件不存在，它将被创建：<code>appendlink</code></p>
<pre><code class="jsx">fs.appendFile(&#39;example.txt&#39;, &#39;Appended text&#39;, &#39;utf8&#39;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;The &quot;data to append&quot; was appended to file!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>删除文件：<code>unlink</code></p>
</li>
<li><p>移动&#x2F;重命名文件：<code>rename</code></p>
</li>
<li><p>拷贝文件：<code>copyFile</code></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>所有文件方法都是异步操作，以一个回调函数作为最后的参数，路径作为第一个参数通常</li>
<li>所有文件方法都有一个同步版本，就是在原方法后加一个<code>Sync</code>，它不用回调函数作为参数，写入结果直接返回</li>
<li>需要注意的是，如果既有同步的文件操作，又有异步的文件操作，事件循环机制会使同步操作先执行，而导致异步操作的结果可能对同步结果进行覆盖</li>
</ul>
<h3 id="常用文件夹操作"><a href="#常用文件夹操作" class="headerlink" title="常用文件夹操作"></a>常用文件夹操作</h3><ol>
<li><p>读取文件夹目录中的文件：<code>readdir</code></p>
<pre><code class="jsx">fs.readdir(&#39;./&#39;, (err, files) =&gt; &#123;  
  files.forEach(file =&gt; &#123;  
    console.log(file);  
  &#125;);  
&#125;);
</code></pre>
</li>
<li><p>创建空文件夹：<code>mkdir</code></p>
<pre><code class="jsx">fs.mkdir(&#39;./newDir&#39;, &#123; recursive: true &#125;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;Directory has been created!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>删除（只有空文件夹可以删除）：<code>rmdir</code></p>
<pre><code class="jsx">fs.rmdir(&#39;./newDir&#39;, &#123; recursive: true &#125;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;Directory has been deleted!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>拷贝和移动：没有直接api，必须手动遍历</p>
<ul>
<li><em><strong>递归清空文件夹中的文件</strong></em></li>
</ul>
<pre><code class="jsx">const fs = require(&#39;fs&#39;)
const ph = require(&#39;path&#39;)

function empty(path) &#123;
    if (fs.existsSync(path)) &#123;
        const dir = fs.readdirSync(path)
        dir.forEach(item =&gt; &#123;
            const fullpath = ph.join(path, item)
            const _state = fs.statSync(fullpath)
            if (_state.isDirectory()) &#123;
                empty(fullpath)
            &#125; else &#123;
                fs.unlinkSync(fullpath)
            &#125;
        &#125;)
    &#125;
&#125;
empty(&#39;./testdir&#39;)
</code></pre>
<ul>
<li><em><strong>递归拷贝文件夹</strong></em></li>
</ul>
<pre><code class="jsx">const fs = require(&#39;fs&#39;)
const ph = require(&#39;path&#39;)

function copy(srcpath, targetpath) &#123;
    if (!fs.existsSync(targetpath)) &#123;
        fs.mkdirSync(targetpath)
    &#125;
    if (fs.existsSync(srcpath)) &#123;
        const dir = fs.readdirSync(srcpath)
        dir.forEach(item =&gt; &#123;
            const srcfullpath = ph.join(srcpath, item)
            const targetfullpath = ph.join(targetpath, item)
            const state = fs.statSync(srcfullpath)
            if (state.isDirectory()) &#123;
                copy(srcfullpath, targetfullpath)
            &#125; else &#123;
                fs.copyFileSync(srcfullpath,targetfullpath)
            &#125;
        &#125;)
    &#125;
&#125;
copy(&#39;./testdir&#39;, &#39;./dir&#39;)
</code></pre>
<p><em>注意：如果没使用同步函数并且没有加入回调函数作为参数，运行时就会报错</em></p>
</li>
<li><p>获取文件或目录的详细信息（如大小、创建时间等）：<code>stat()</code></p>
<pre><code class="jsx">fs.stat(&#39;example.txt&#39;, (err, stats) =&gt; &#123;  
  console.log(stats.isFile()); // 检查是否为文件  
  console.log(stats.size); // 文件大小（字节）  
&#125;);
</code></pre>
</li>
</ol>
<h3 id="常用检测文件夹方法"><a href="#常用检测文件夹方法" class="headerlink" title="常用检测文件夹方法"></a>常用检测文件夹方法</h3><ol>
<li>检查文件或文件夹是否存在：<code>exists</code></li>
<li>获取文件状态信息，判断是文件还是文件夹：<code>stat</code></li>
</ol>
<h3 id="其他文件操作"><a href="#其他文件操作" class="headerlink" title="其他文件操作"></a>其他文件操作</h3><ul>
<li><code>watch</code>：监听文件是否发生改变，一旦改变则出发回调。因为一直处于监听状态，所以程序不会退出</li>
<li><code>open</code>：打开后可以进行自由操作（基本不用了）<ul>
<li><code>read</code>：自由读取</li>
<li><code>write</code>：自由写入</li>
</ul>
</li>
<li><code>writeStream</code>和<code>readStream</code>：以流形式进行操作，创建写入流和读取流</li>
</ul>
<pre><code class="jsx">const fs=require(&#39;fs&#39;)
fs.watch(&#39;./copy.txt&#39;,(err,filename)=&gt;&#123;
    console.log(filename+&#39;文件发生改变&#39;)
    process.exit()
&#125;)
</code></pre>
<h3 id="好用的第三方库"><a href="#好用的第三方库" class="headerlink" title="好用的第三方库"></a>好用的第三方库</h3><aside>
💡 *注意：用之前先安装*


</aside>

<p><code>fs-extra</code> ：提供了一些操作文件的方法，如果开发过程中经常使用文件操作的话，最好引入这个包，功能比原生的<code>fs</code>模块更强大</p>
<ul>
<li><code>copy</code> ：可以拷贝文件，也可以拷贝文件夹</li>
<li><code>emptyDir</code> ：递归清空文件夹</li>
<li><code>remove</code> ：删除文件或者文件夹</li>
<li><code>move</code> ：移动文件或者文件夹</li>
<li><code>outputFile</code> ：向文件中添加内容，如果文件不存在，则自动创建</li>
</ul>
<pre><code class="jsx">const fs = require(&#39;fs-extra&#39;)
fs.copySync(&#39;./dir&#39;,&#39;./newdir&#39;)
fs.emptyDirSync(&#39;./dir&#39;)
fs.removeSync(&#39;./newdir&#39;)
fs.moveSync(&#39;./testdir&#39;,&#39;./dir/testdir&#39;)
fs.outputFileSync(&#39;./newcopy.txt&#39;,&#39;love u&#39;)
</code></pre>
<p><code>compressing</code> ：帮助制作文件压缩包和解压文件压缩包，因为文件夹是不能进行网络传输的，因此想要上传文件夹必须先压缩。这个包里的回调方法采用的是promise，而不是回调函数</p>
<ul>
<li><code>zip.compressDir</code> ：压缩文件夹</li>
<li><code>zip.uncompress</code> ：解压压缩包</li>
</ul>
<pre><code class="jsx">const cm = require(&#39;compressing&#39;)
cm.zip.compressDir(&#39;./dir&#39;,&#39;./dirzip.zip&#39;).then(res=&gt;&#123;
    console.log(&#39;压缩成功&#39;)
&#125;)
cm.zip.uncompress(&#39;./dirzip.zip&#39;,&#39;./zip&#39;).then(res=&gt;&#123;
    console.log(&#39;解压成功&#39;)
&#125;)
</code></pre>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/09/JavaScript-core-principle/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/JavaScript.png" data-sizes="auto" alt="JavaScript核心原理" class="lazyload">
                    <h1>JavaScript核心原理</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月09日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 20 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="JavaScript-执行机制"><a href="#JavaScript-执行机制" class="headerlink" title="JavaScript 执行机制"></a>JavaScript 执行机制</h2><p>JavaScript 的执行机制主要涉及到其单线程特性、事件循环以及任务队列等概念。下面详细解释这些概念以及它们如何共同影响 JavaScript 的执行。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a><strong>单线程</strong></h3><p>JavaScript 是单线程的，这意味着它一次只能执行一个任务。这确保了代码执行的顺序性和一致性，但同时也带来了一个问题：当遇到需要等待的操作（如 I&#x2F;O 操作、定时器、网络请求等）时，整个线程会被阻塞，直到该操作完成。</p>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a><strong>异步编程</strong></h3><p>为了解决这个问题，JavaScript 引入了异步编程的概念。异步编程允许 JavaScript 在等待某个操作完成的同时执行其他任务。但如果同步代码依赖的是异步任务执行完的结果，怎么办呢？</p>
<p>给出的解决方法就是回调函数，当你调用一个异步API并传递一个回调函数时，一旦异步操作完成，事件循环会收到通知，并自动将相应的回调函数推入任务队列。</p>
<p><strong>常见的异步任务有：</strong></p>
<ol>
<li>定时器：<code>setTimeout</code> 和 <code>setInterval</code></li>
<li>建立网络连接：<code>fetch</code> API 、 <code>XMLHttpReques</code>、 <code>http</code>、<code>https</code> 或其他第三方库（如 <code>axios</code>、<code>request</code>）</li>
<li>读取网络流数据</li>
<li>向文件写入数据：<code>fs</code></li>
<li>Ajax提交</li>
<li>请求数据库服务</li>
<li>动态import()</li>
</ol>
<p><strong>异步操作在Node.js中的执行环境：</strong></p>
<ol>
<li><strong>事件循环</strong>：与浏览器环境不同的是，Node.js的事件循环包括更多的阶段（如timers、pending callbacks、idle, prepare、poll、check、close callbacks等），这些阶段用于处理不同类型的异步任务。</li>
<li><strong>多线程</strong>：虽然JavaScript在Node.js中仍然是单线程执行的，但Node.js内部使用了多线程来处理某些类型的异步任务。这些线程由Node.js的底层库管理，当Node.js代码执行一个异步I&#x2F;O操作时，它会将任务委托给libuv库，然后立即返回并继续执行后续的代码。libuv库会根据操作系统的功能（例如，Linux的epoll、Windows的IOCP等）来高效地处理这些异步I&#x2F;O任务。当异步I&#x2F;O操作完成时，libuv库会通知Node.js，然后Node.js会将相应的回调函数放入事件循环的队列中等待执行。所以，虽然V8引擎是Node.js的核心部分，用于执行JavaScript代码，但异步I&#x2F;O操作是由libuv库和底层操作系统来处理的，而不是由V8引擎直接处理。这种设计使得Node.js能够高效地处理大量并发连接和异步操作，从而成为构建高性能网络应用的理想选择。</li>
</ol>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h3><p>在JavaScript中，宏任务（MacroTasks）和微任务（MicroTasks）是事件循环中处理异步操作的两类主要任务。</p>
<p><strong>宏任务</strong></p>
<ul>
<li><strong>script（全局任务）</strong>：这是代码的主入口，整个的script标签内都是宏任务。</li>
<li><strong>setTimeout</strong>：延迟一段时间后执行的任务。</li>
<li><strong>setInterval</strong>：每隔一段时间执行的任务。</li>
<li><strong>setImmediate</strong>（Node.js环境）：在I&#x2F;O事件后执行的任务，在Node.js中与setTimeout类似，但在浏览器中没有这个函数。</li>
<li><strong>I&#x2F;O操作</strong>：如Node.js中的文件读写、网络请求等。</li>
<li><strong>UI渲染</strong>（浏览器环境）：浏览器在空闲时会进行页面的渲染。</li>
</ul>
<p><strong>微任务</strong></p>
<ul>
<li><strong>Promise</strong>：Promise的回调函数是微任务。当Promise的状态改变（从pending变为fulfilled或rejected）时，其then或catch方法中的回调函数会被放入微任务队列。</li>
<li><strong>process.nextTick</strong>（Node.js环境）：Node.js特有的API，用于在当前执行栈的末尾立即执行回调。但如果在Vue.js中，则为DOM更新之后立即执行。</li>
<li><strong>MutationObserver</strong>（浏览器环境）：用于监视DOM更改的API，其回调函数也是微任务。</li>
</ul>
<p>当JavaScript代码执行时，如果是在浏览器环境中，会先执行script（或称为全局任务）中的同步代码，然后执行微任务队列中的回调，最后才执行宏任务队列中的回调。这个过程会一直重复，直到所有的任务都被执行完毕。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a><strong>事件循环</strong></h3><p>事件循环是 JavaScript 引擎处理异步任务和更新 UI 的主要方式。它的工作原理大致如下：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/09/JavaScript-core-principle/Untitled.png" alt="Untitled" class="lazyload"></p>
<ol>
<li><p><strong>执行栈（Call Stack）</strong>：JavaScript 引擎有一个执行栈，用于存储函数调用和返回的结果。当执行栈为空时，事件循环会查看任务队列和微任务队列。</p>
<ul>
<li>同步代码：立即放入JS引擎（主线程）执行，并原地等待结果</li>
<li>异步代码：先放入宿主环境（浏览器&#x2F;Node)，不必原地等待结果，并不阻塞主线程继续往下执行，回调函数在等到异步结果之后再执行</li>
</ul>
<p>于是，调用栈中放主线任务，宿主环境来执行异步任务，在执行完后会通知主线程，并自动把回调函数推送到任务队列中，等执行栈中任务空了，就会从任务队列中拿回调。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/09/JavaScript-core-principle/Untitled1.png" alt="Untitled" class="lazyload"></p>
<p>同样是异步任务的回调函数，有的回调是需要连贯执行的，为了优化这个体验，又分为了<strong>微任务（需要立即连贯执行）</strong>和<strong>宏任务（不需要立即连贯执行）</strong></p>
<p>事件循环中任务队列的过程可以分为先检查微任务队列，再检查宏任务队列</p>
</li>
<li><p><strong>检查微任务队列</strong>：在每次事件循环迭代中，JavaScript 引擎会首先查看微任务队列。如果微任务队列中有任务，它会执行这些任务，直到微任务队列为空。</p>
</li>
<li><p><strong>执行栈和微任务队列</strong>：在执行微任务的过程中，如果有新的微任务被添加到微任务队列，它们也会在当前事件循环迭代中被执行。只有当微任务队列完全为空时，JavaScript 引擎才会继续下一步。</p>
</li>
<li><p><strong>检查宏任务队列</strong>：当微任务队列为空时，JavaScript 引擎会查看宏任务队列。如果宏任务队列中有任务，它会取出第一个任务并将其推入执行栈中执行。这个过程会一直重复，直到任务队列为空。</p>
</li>
<li><p><strong>渲染</strong>：在执行完一个事件循环迭代中的所有任务后，浏览器会更新 UI 并进行渲染。</p>
</li>
<li><p><strong>下一轮事件循环</strong>：然后，事件循环会开始新一轮的迭代，再次检查微任务队列和任务队列中的任务。</p>
</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h2><p>当一个请求，它依赖于上一个请求的结果的时候，就需要来调用回调函数，如果这样的请求多了，就会变成这样：</p>
<pre><code class="jsx">请求1(function(res1)&#123;
    请求2(function(res2)&#123;
        请求3(function(res3)&#123;
            请求4(function(res4)&#123;
                ......
            &#125;)
        &#125;)
    &#125;)
&#125;)
</code></pre>
<p>这就是回调地狱，为了优雅的表示异步回调，便有了<code>Promise</code>。</p>
<p><code>Promise</code> 是 JavaScript 中的一个对象，它的构造函数为<code>new Promise(fn)</code>，<code>fn</code>为回调函数，它接收两个参数<code>resolve</code>和<code>reject</code>。</p>
<p>以下是 Promise 的一些基本概念和特性：</p>
<ol>
<li><p><strong>状态</strong>：Promise 有三种状态：</p>
<ul>
<li><code>pending</code>（待定）：初始状态，既不是成功，也不是失败状态。</li>
<li><code>fulfilled</code>（已实现）：意味着操作成功完成。</li>
<li><code>rejected</code>（已拒绝）：意味着操作失败。</li>
</ul>
</li>
<li><p><strong>执行器（Executor）</strong>：<code>Promise</code> 构造函数接受一个执行器函数作为参数，<strong>异步操作会放在该执行器函数内</strong>。执行器函数有两个参数：<code>resolve</code> 和 <code>reject</code>，它们是两个函数，分别用于将 Promise 的状态从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>。这两个函数为<code>Promise</code>对象的内置函数，无需自己定义。</p>
<pre><code class="jsx">const promise = new Promise((resolve, reject) =&gt; &#123;  
  // 假设这是一个异步操作，例如从服务器获取数据  
  setTimeout(() =&gt; &#123;  
    // 模拟异步操作成功，我们调用 resolve 函数，并传递一个值  
    const data = &#39;成功获取的数据&#39;;  
    resolve(data);  
  &#125;, 1000);  
  
  // 注意：在实际应用中，你可能需要在某个错误处理回调中调用 reject 函数  
  // 例如，网络请求失败时  
&#125;);  
</code></pre>
<p><code>**resolve</code> 函数被用来在异步操作成功时传递一个值给 Promise 的成功处理函数。这个值会成为 <code>then</code> 方法第一个回调函数的参数。**如果异步操作失败，你应该用 <code>reject</code> 函数，并传递一个表示错误原因的值给 Promise 的失败处理函数（即 <code>then</code> 方法的第二个参数，或者更常见的 <code>catch</code> 方法）。</p>
</li>
<li><p><strong>链式调用（Chaining）</strong>：<code>Promise</code> 提供了 <code>.then()</code> 和 <code>.catch()</code> 方法，用于注册成功和失败的回调函数。这两个方法都返回新的 Promise 对象，因此可以链式调用。</p>
<pre><code class="jsx">// 使用 then 方法处理 Promise 的结果  
promise.then(  
  value =&gt; &#123;  
    console.log(value); // 输出：成功获取的数据  
    // 在这里，你可以对获取到的数据做进一步的处理  
  &#125;,  
  error =&gt; &#123;  
    // 这个回调函数会在 Promise 被 reject 时调用  
    // 但在这个示例中，因为我们从未调用 reject，所以这个回调函数不会被执行  
    console.error(&#39;出现错误：&#39;, error);  
  &#125;  
);
</code></pre>
</li>
<li><p><strong>错误处理</strong>：每一步都写<code>reject</code>特别麻烦，为了简化任务需要，我们诞生了<code>catch</code>方法，来捕获<code>resolve</code>时的异常，这样就可以省略<code>reject</code>方法了。</p>
</li>
<li><p><strong><code>Promise</code> 链</strong>：多个 <code>.then()</code> 调用可以组成 <code>Promise</code> 链，每个 <code>.then()</code> 的回调函数都会接收前一个 <code>Promise</code> 的结果作为参数。</p>
</li>
<li><p><strong>静态方法</strong>：为了满足更多业务需要，又诞生了6个<code>promise</code>的静态方法。</p>
<ul>
<li><code>promise.all()</code>等待所有<code>Promise</code>执行成功，一个不成功都算失败</li>
<li><code>promise.allSettled()</code>等待所有<code>Promise</code>执行完成，无论成功还是失败</li>
<li><code>promise.any()</code>任意一个promise成功就行</li>
<li><code>promise.race()</code>等待第一个promise完成</li>
<li><code>promise.reject(reason)</code>返回一个状态为<code>rejected</code>的<code>Promise</code>对象</li>
<li><code>Promise.resolve()</code>它会接受四种类型的参数：<ol>
<li>一个<code>promise</code>实例——直接返回</li>
<li>具有<code>then</code>方法的对象——转为<code>promise</code>对象，并立即执行<code>then</code>方法</li>
<li>普通对象或不是对象——返回一个新的<code>promise</code>对象，将参数传给下一个<code>then</code></li>
<li>不带任何参数——状态为<code>resolved</code>的<code>promise</code>对象</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>下面是一个简单的 Promise 示例：</p>
<pre><code class="jsx">function fetchData() &#123;  
  return new Promise((resolve, reject) =&gt; &#123;  
    // 模拟异步操作，例如 AJAX 请求  
    setTimeout(() =&gt; &#123;  
      // 模拟成功获取数据  
      const data = &#39;Hello, World!&#39;;  
      resolve(data); // 将 Promise 状态设置为 fulfilled，并传递数据  
    &#125;, 1000);  
  
    // 如果发生错误，可以调用 reject 函数  
    // reject(new Error(&#39;Failed to fetch data&#39;));  
  &#125;);  
&#125;  
  
// 使用 Promise  
fetchData()  
  .then(data =&gt; &#123;  
    console.log(data); // 输出 &#39;Hello, World!&#39;  
    // 返回新的 Promise 或值，可以继续链式调用  
    return &#39;Another data point&#39;;  
  &#125;)  
  .then(data =&gt; &#123;  
    console.log(data); // 输出 &#39;Another data point&#39;  
  &#125;)  
  .catch(error =&gt; &#123;  
    console.error(&#39;An error occurred:&#39;, error);  
  &#125;);
</code></pre>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a><code>async</code> 和 <code>await</code></h2><p><code>async</code> 和 <code>await</code> 是 JavaScript 中用于处理异步操作的关键字，它们主要用在 <code>Promise</code> 和基于 <code>Promise</code> 的技术中。使得异步代码能够以更直观、更易于理解的同步代码风格来编写。</p>
<p><strong>async</strong></p>
<ul>
<li><code>async</code> 函数是声明一个函数是异步的。</li>
<li>异步函数总是返回一个 <code>Promise</code>。</li>
<li>如果 <code>async</code> 函数中有 <code>return</code> 语句，返回的值将被包装在一个 <code>Promise</code> 中。</li>
<li>如果 <code>async</code> 函数中没有 <code>return</code> 语句，则返回的 <code>Promise</code> 将解析为 <code>undefined</code>。</li>
</ul>
<p><strong>await</strong></p>
<ul>
<li><code>await</code> 关键字只能在 <code>async</code> 函数内部使用。</li>
<li><code>await</code> 会卡在当前的异步操作中等待 <code>Promise</code> 完成并返回结果，然后继续往下执行。</li>
<li>如果等待的 Promise 被拒绝，<code>await</code> 表达式会抛出一个错误。</li>
</ul>
<p>示例：</p>
<pre><code class="jsx">async function fetchData() &#123;  
  let response = await fetch(&#39;https://api.example.com/data&#39;);  
  let data = await response.json();  
  return data;  
&#125;  
  
fetchData().then(data =&gt; &#123;  
  console.log(data);  
&#125;).catch(error =&gt; &#123;  
  console.error(&#39;Error:&#39;, error);  
&#125;);
</code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>不要在非 <code>async</code> 函数中使用 <code>await</code>，否则会导致语法错误。</li>
<li>当你需要处理一系列的异步操作，可以使用 <code>async/await</code> 的连续调用。</li>
<li>尽管 <code>async/await</code> 使得代码更易于阅读和理解，但在某些情况下（如需要并行处理多个异步操作时），使用 Promise 的链式调用或 <code>Promise.all()</code> 可能更有效率。</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在JavaScript中，作用域（Scope）是代码执行上下文中的一个重要概念，它决定了变量、函数和表达式的可访问性和生命周期。作用域决定了在何处以及如何查找变量（标识符）的引用。</p>
<h3 id="作用域类型"><a href="#作用域类型" class="headerlink" title="作用域类型"></a><strong>作用域类型</strong></h3><p>JavaScript中有两种主要的作用域类型：</p>
<ol>
<li><strong>全局作用域</strong>：不在任何函数内部的变量或函数，也就是定义在windows下的变量范围，在任何地方都可以访问。容易导致全局污染，命名冲突，对bug查找不利。</li>
<li><strong>局部作用域</strong>：只在函数内部定义的变量范围。<ul>
<li><strong>函数作用域</strong>：在ES6之前，JavaScript只有函数作用域，这意味着变量在函数内部是局部的，在函数外部是不可见的。</li>
<li><strong>块级作用域（Block Scope）</strong>：ES6引入了<code>let</code>和<code>const</code>关键字，它们提供了块级作用域。在<code>&#123;&#125;</code>中声明的变量或常量仅在该块内部是可访问的。</li>
</ul>
</li>
</ol>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><p>作用域链就是由最内部的作用域往最外部查找变量的过程，形成的链条就是作用域链。</p>
<p>作用域链是一种数据结构，它保存了当前执行上下文中所有变量和函数引用的有序列表。这个列表从当前作用域开始，然后是其父级作用域，然后是更高级别的父级作用域，直到全局作用域。如果变量未在任何作用域中找到，那么将抛出一个引用错误（ReferenceError）。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（Closure）允许函数记住并访问其所在的词法环境，即使在函数执行完毕并返回后，这些词法环境中的数据仍然可以被闭包内部的代码所访问。闭包有几个主要的应用场景：</p>
<ol>
<li><p><strong>数据封装和私有变量</strong>：</p>
<p>闭包可以用来封装数据，并通过特定的接口（函数）来访问这些数据，从而实现数据的私有性。</p>
<pre><code class="jsx">function createCounter() &#123;  
    let count = 0; // 私有变量，不通过return暴露  
    return &#123;  
        increment: function() &#123;  
            count++;  
        &#125;,  
        getCount: function() &#123;  
            return count;  
        &#125;  
    &#125;;  
&#125;  
const counter = createCounter();  
counter.increment();  
console.log(counter.getCount()); // 输出：1
</code></pre>
</li>
<li><p><strong>回调函数和高阶函数</strong>：</p>
<p>闭包经常作为回调函数使用，因为它们可以记住自己的词法环境，包括this、变量等。在高阶函数中，闭包也非常有用，因为它们可以接收函数作为参数，并返回函数作为结果。</p>
<pre><code class="jsx">function greet(name) &#123;  
    return function(greeting) &#123;  
        console.log(greeting + &#39;, &#39; + name);  
    &#125;;  
&#125;  

const helloJohn = greet(&#39;John&#39;);  
helloJohn(&#39;Hello&#39;); // 输出：Hello, John
</code></pre>
</li>
<li><p><strong>实现装饰器&#x2F;函数修饰器</strong>：</p>
<p>闭包可以用来创建装饰器，它们可以修改或增强函数的行为。</p>
<pre><code class="jsx">function logCalls(func) &#123;  
    return function() &#123;  
        console.log(&#39;Calling: &#39; + func.name);  
        func.apply(this, arguments);  
    &#125;;  
&#125;  
const originalFunc = function() &#123;  
    console.log(&#39;Inside original function&#39;);  
&#125;;  
const loggedFunc = logCalls(originalFunc);  
loggedFunc(); // 输出：Calling: originalFunc, Inside original function
</code></pre>
</li>
<li><p><strong>实现模块模式</strong>：</p>
<p>闭包可以用来模拟私有属性和方法，从而创建模块。这有助于避免全局命名空间的污染，并提供了一种组织代码的方式。</p>
<pre><code class="jsx">var myModule = (function() &#123;  
    var privateVar = &#39;Hello&#39;;  
    function privateFunc() &#123;  
        return privateVar;  
    &#125;  
    return &#123;  
        publicFunc: function() &#123;  
            return privateFunc();  
        &#125;  
    &#125;;  
&#125;)();  
console.log(myModule.publicFunc()); // 输出：Hello
</code></pre>
</li>
<li><p><strong>事件监听器</strong>：</p>
<p>在事件驱动的编程中，闭包经常被用作事件监听器的回调函数，因为它们可以记住与特定事件相关的数据或状态。</p>
<pre><code class="jsx">button.addEventListener(&#39;click&#39;, function() &#123;  
    // 这个匿名函数是一个闭包，它可以访问外部变量  
    console.log(&#39;Button clicked!&#39;);  
&#125;);
</code></pre>
</li>
</ol>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>在 JavaScript 中，每个函数都有一个 <code>prototype</code> 属性，这个属性是一个指针，指向一个对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，可以通过 <code>Object.getPrototypeOf()</code> 访问。</p>
<p>当你创建一个函数（即一个类构造函数）时，JavaScript 会自动为这个函数添加一个 <code>prototype</code> 属性，这个属性是一个对象，通常被称为该函数的原型对象。</p>
<pre><code class="jsx">function Person(name) &#123;  
    this.name = name;  
&#125;  
Person.prototype.sayHello = function() &#123;  
    console.log(`Hello, my name is $&#123;this.name&#125;`);  
&#125;;    
const person1 = new Person(&#39;Alice&#39;);  
person1.sayHello(); // 输出: Hello, my name is Alice
</code></pre>
<p>在这个例子中，<code>Person.prototype</code> 就是 <code>Person</code> 构造函数的原型对象，而 <code>sayHello</code> 方法就定义在这个原型对象上。因此，当我们使用 <code>new Person(&#39;Alice&#39;)</code> 创建一个 <code>Person</code> 的实例时，这个实例（即 <code>person1</code>）可以访问到定义在 <code>Person.prototype</code> 上的 <code>sayHello</code> 方法。</p>
<p>原型链是 JavaScript 中实现继承的一种方式。当一个对象试图访问其某个属性或方法时，JavaScript 会首先在该对象自身的属性中查找，如果找不到，则会沿着该对象的原型链向上查找，直到找到为止（或者直到到达原型链的末尾，即 <code>Object.prototype</code>，此时如果还未找到，则返回 <code>undefined</code>）。</p>
<p>在上面的例子中，<code>person1</code> 对象并没有直接定义 <code>sayHello</code> 方法，但是它可以访问到 <code>Person.prototype</code> 上的 <code>sayHello</code> 方法，这就是因为 <code>person1</code> 的原型链中包含了 <code>Person.prototype</code>。</p>
<p>更具体地说，当我们使用 <code>new</code> 关键字创建一个新的对象时，JavaScript 会做以下几件事情：</p>
<ol>
<li>创建一个新的空对象。</li>
<li>将这个新对象的 <code>__proto__</code>指向构造函数的 <code>prototype</code> 对象。</li>
<li>将这个新对象作为 <code>this</code> 上下文传入构造函数并执行，从而设置新对象的属性。</li>
<li>返回这个新对象。</li>
</ol>
<p>因此，当我们说 <code>person1.sayHello()</code> 时，JavaScript 首先在 <code>person1</code> 对象自身上查找 <code>sayHello</code> 属性，由于没找到，所以会沿着原型链（即 <code>person1.__proto__</code>，也就是 <code>Person.prototype</code>）继续查找，最终在 <code>Person.prototype</code> 上找到了 <code>sayHello</code> 方法并执行。</p>
<p>需要注意的是，虽然 <code>__proto__</code> 属性在大多数现代浏览器中都可以访问，但它并不是 JavaScript 语言规范的一部分，而是某些浏览器为了实现原型链而提供的。在编写可移植的代码时，应该使用符合JavaScript 语言规范的 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 方法来访问和修改对象的原型。</p>

             -->
        </article>
    </div>
    
</section>


        <div class="nexmoe-post-right">
          
            <div class="nexmoe-fixed">
              <div class="nexmoe-tool">
                <a href="#" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
              </div>
            </div>
          
        </div>
    </div>
  </div>
  <div id="nexmoe-pendant">
    <div class="nexmoe-drawer mdui-drawer nexmoe-pd" id="drawer">
        
            <div class="nexmoe-pd-item">
                <div class="clock">
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="needle" id="hours"></div>
        <div class="needle" id="minutes"></div>
        <div class="needle" id="seconds"></div>
        <div class="clock_logo">

        </div>

    </div>
<style>
    .clock {
        background-color: #ffffff;
        width: 70vw;
        height: 70vw;
        max-width: 70vh;
        max-height: 70vh;
        border: solid 2.8vw #242424;
        position: relative;
        overflow: hidden;
        border-radius: 50%;
        box-sizing: border-box;
        box-shadow: 0 1.4vw 2.8vw rgba(0, 0, 0, 0.8);
        zoom:0.2
    }

    .memory {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .memory:nth-child(1) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(0deg) translateY(-520%);
    }

    .memory:nth-child(2) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(6deg) translateY(-1461%);
    }

    .memory:nth-child(3) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(12deg) translateY(-1461%);
    }

    .memory:nth-child(4) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(18deg) translateY(-1461%);
    }

    .memory:nth-child(5) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(24deg) translateY(-1461%);
    }

    .memory:nth-child(6) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(30deg) translateY(-520%);
    }

    .memory:nth-child(7) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(36deg) translateY(-1461%);
    }

    .memory:nth-child(8) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(42deg) translateY(-1461%);
    }

    .memory:nth-child(9) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(48deg) translateY(-1461%);
    }

    .memory:nth-child(10) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(54deg) translateY(-1461%);
    }

    .memory:nth-child(11) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(60deg) translateY(-520%);
    }

    .memory:nth-child(12) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(66deg) translateY(-1461%);
    }

    .memory:nth-child(13) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(72deg) translateY(-1461%);
    }

    .memory:nth-child(14) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(78deg) translateY(-1461%);
    }

    .memory:nth-child(15) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(84deg) translateY(-1461%);
    }

    .memory:nth-child(16) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(90deg) translateY(-520%);
    }

    .memory:nth-child(17) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(96deg) translateY(-1461%);
    }

    .memory:nth-child(18) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(102deg) translateY(-1461%);
    }

    .memory:nth-child(19) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(108deg) translateY(-1461%);
    }

    .memory:nth-child(20) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(114deg) translateY(-1461%);
    }

    .memory:nth-child(21) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(120deg) translateY(-520%);
    }

    .memory:nth-child(22) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(126deg) translateY(-1461%);
    }

    .memory:nth-child(23) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(132deg) translateY(-1461%);
    }

    .memory:nth-child(24) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(138deg) translateY(-1461%);
    }

    .memory:nth-child(25) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(144deg) translateY(-1461%);
    }

    .memory:nth-child(26) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(150deg) translateY(-520%);
    }

    .memory:nth-child(27) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(156deg) translateY(-1461%);
    }

    .memory:nth-child(28) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(162deg) translateY(-1461%);
    }

    .memory:nth-child(29) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(168deg) translateY(-1461%);
    }

    .memory:nth-child(30) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(174deg) translateY(-1461%);
    }

    .memory:nth-child(31) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(180deg) translateY(-520%);
    }

    .memory:nth-child(32) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(186deg) translateY(-1461%);
    }

    .memory:nth-child(33) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(192deg) translateY(-1461%);
    }

    .memory:nth-child(34) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(198deg) translateY(-1461%);
    }

    .memory:nth-child(35) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(204deg) translateY(-1461%);
    }

    .memory:nth-child(36) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(210deg) translateY(-520%);
    }

    .memory:nth-child(37) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(216deg) translateY(-1461%);
    }

    .memory:nth-child(38) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(222deg) translateY(-1461%);
    }

    .memory:nth-child(39) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(228deg) translateY(-1461%);
    }

    .memory:nth-child(40) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(234deg) translateY(-1461%);
    }

    .memory:nth-child(41) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(240deg) translateY(-520%);
    }

    .memory:nth-child(42) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(246deg) translateY(-1461%);
    }

    .memory:nth-child(43) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(252deg) translateY(-1461%);
    }

    .memory:nth-child(44) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(258deg) translateY(-1461%);
    }

    .memory:nth-child(45) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(264deg) translateY(-1461%);
    }

    .memory:nth-child(46) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(270deg) translateY(-520%);
    }

    .memory:nth-child(47) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(276deg) translateY(-1461%);
    }

    .memory:nth-child(48) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(282deg) translateY(-1461%);
    }

    .memory:nth-child(49) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(288deg) translateY(-1461%);
    }

    .memory:nth-child(50) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(294deg) translateY(-1461%);
    }

    .memory:nth-child(51) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(300deg) translateY(-520%);
    }

    .memory:nth-child(52) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(306deg) translateY(-1461%);
    }

    .memory:nth-child(53) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(312deg) translateY(-1461%);
    }

    .memory:nth-child(54) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(318deg) translateY(-1461%);
    }

    .memory:nth-child(55) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(324deg) translateY(-1461%);
    }

    .memory:nth-child(56) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(330deg) translateY(-520%);
    }

    .memory:nth-child(57) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(336deg) translateY(-1461%);
    }

    .memory:nth-child(58) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(342deg) translateY(-1461%);
    }

    .memory:nth-child(59) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(348deg) translateY(-1461%);
    }

    .memory:nth-child(60) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(354deg) translateY(-1461%);
    }

    .needle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .needle#hours {
        background-color: #1f1f1f;
        width: 4%;
        height: 30%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#hours.moving {
        transition: transform 150ms ease-out;
    }

    .needle#hours:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#minutes {
        background-color: #1f1f1f;
        width: 2%;
        height: 45%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#minutes.moving {
        transition: transform 150ms ease-out;
    }

    .needle#minutes:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#seconds {
        background-color: #cb2f2f;
        width: 1%;
        height: 50%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#seconds.moving {
        transition: transform 150ms ease-out;
    }

    .needle#seconds:after {
        content: '';
        background-color: #cb2f2f;
        width: 2.5vw;
        height: 2.5vw;
        max-width: 2.5vh;
        max-height: 2.5vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }
    .clock_logo{
        width: 10vw;
        height: 10vw;
        max-width: 10vh;
        max-height: 10vh;
        position: absolute;
        top: 50%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
    @media (min-width: 100vh) {
        .clock {
            border: solid 2.8vh #242424;
            box-shadow: 0 1.4vh 2.8vh rgba(0, 0, 0, 0.8);
        }
    }

</style>





            </div>
        
            <div class="nexmoe-pd-item">
                <div class="qweather" >
    <div id="he-plugin-standard"></div>
    <div class="qweather-logo">

    </div>

</div>
<style>
    .qweather{
        position: relative;
    }
    .qweather-logo{
        position: absolute;
        right: 0;
        top: -15px;
        width: 40px;
        height: 40px;
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
</style>
<script>
  WIDGET = {
    "CONFIG": {
      "layout": "2",
      "width": "260",
      "height": "220",
      "background": "5",
      "dataColor": "e67249",
      "borderRadius": "15",
      "key": "f74d1e1690e6432d801e97fa2f05a162"
    }
  }
</script>
<script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script>

            </div>
        
</div>
<style>
    .nexmoe-pd {
        left: auto;
        top: 40px;
        right: 0;
    }
    .nexmoe-pd-item{
       display: flex;
        justify-content: center;
        margin-bottom: 30px;
    }
</style>

  </div>
  <script src="https://lib.baomitu.com/lazysizes/5.1.0/lazysizes.min.js"></script>
<script src="https://lib.baomitu.com/highlight.js/10.0.0/highlight.min.js"></script>
<script src="https://lib.baomitu.com/mdui/0.4.3/js/mdui.min.js"></script>

<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://lib.baomitu.com/jquery/3.5.1/jquery.slim.min.js"></script>
<script src="/lib/fancybox/js/jquery.fancybox.min.js"></script>


<script src="/js/app.js?v=1721141826481"></script>

<script src="https://lib.baomitu.com/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





<!-- hexo injector body_end start -->
<script src="/js/clock.js"></script>

<script src="/js/webapp.js"></script>

<script src="https://lib.baomitu.com/clipboard.js/2.0.8/clipboard.min.js"></script>

<script src="/lib/codeBlock/codeBlockFuction.js"></script>

<script src="/lib/codeBlock/codeLang.js"></script>

<script src="/lib/codeBlock/codeCopy.js"></script>

<script src="/lib/codeBlock/codeShrink.js"></script>

<link rel="stylesheet" href="/lib/codeBlock/matery.css">

<script src="https://code.jquery.com/jquery-3.6.0.js"></script>

<script src="/js/search.js"></script>
<!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"rect":{"opacity":0.7},"position":"relative","z-index":1,"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/250cb4aa.js","daovoice")</script>
<script>
  daovoice('init', {
    app_id: "250cb4aa"
  });
  daovoice('update');
</script>

