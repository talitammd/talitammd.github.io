<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />
  <title>文章归档：2024 - 卷不过没事了</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

    <!-- Site Verification -->
    <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />

  <link rel="shortcut icon" href="/images/head/head.jpg" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="卷不过没事了">
<meta property="og:url" content="http://example.com/archives/2024/index.html">
<meta property="og:site_name" content="卷不过没事了">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Talita">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://lib.baomitu.com/highlight.js/9.15.8/styles/atom-one-dark.min.css" crossorigin>
  <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css">
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css">
  <link rel="stylesheet" href="/lib/fancybox/css/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://lib.baomitu.com/justifiedGallery/3.8.1/css/justifiedGallery.min.css">
  
    <link rel="stylesheet" href="//at.alicdn.com/t/font_2421060_8z08qcz5sq3.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1720102878666">
<meta name="generator" content="Hexo 7.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/background/xiaomai.png)"></div>
    <div class="nexmoe-small" style="background-image: url(/images/background/lihui.png)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Talita" class="mdui-btn mdui-btn-icon"><img src="/images/head/me.jpeg" alt="Talita"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Talita">
            <img src="/images/head/me.jpeg" alt="Talita" alt="Talita">
        </a>
    </div>
    <div class="nexmoe-count">
        <div class="nexmoe-count-item"><span>文章</span>8 <div class="item-radius"></div><div class="item-radius item-right"></div> </div>
        <div class="nexmoe-count-item"><span>标签</span>6<div class="item-radius"></div><div class="item-radius item-right"></div></div>
        <div class="nexmoe-count-item"><span>分类</span>6<div class="item-radius"></div><div class="item-radius item-right"></div></div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="首页">
            <i class="mdui-list-item-icon nexmoefont icon-meishi"></i>
            <div class="mdui-list-item-content">
                首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives.html" title="归档">
            <i class="mdui-list-item-icon nexmoefont icon-hanbao1"></i>
            <div class="mdui-list-item-content">
                归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于">
            <i class="mdui-list-item-icon nexmoefont icon-jiubei1"></i>
            <div class="mdui-list-item-content">
                关于
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/friend.html" title="友链">
            <i class="mdui-list-item-icon nexmoefont icon-cola"></i>
            <div class="mdui-list-item-content">
                友链
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/download.html" title="下载中心">
            <i class="mdui-list-item-icon nexmoefont icon-tangguo"></i>
            <div class="mdui-list-item-content">
                下载中心
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  
<!-- 站内搜索 -->

<div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search" >
        <form id="search-form">
            <label><input type="text" id="local-search-input" name="q" results="0" placeholder="站内搜索" class="input form-control" autocomplete="off" autocorrect="off"/></label>
            <!-- 清空/重置搜索框 -->
            <i class="fa fa-times" onclick="resetSearch()"></i>
        </form>
    </div>
    <div id="local-search-result"></div> <!-- 搜索结果区 -->
    <!-- <p class='no-result'></p> 无匹配时显示，注意在 CSS 中设置默认隐藏 -->
</div>


  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=2120252100&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(64, 196, 255);background-color: rgba(64, 196, 255, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="mailto:tangyuxian@vip.qq.com" target="_blank" mdui-tooltip="{content: 'mail'}" style="color: rgb(249,8,8);background-color: rgba(249,8,8,.1);">
            <i class="nexmoefont icon-mail-fill"></i>
        </a><a class="mdui-ripple" href="https://blog.csdn.net/qq_40621378?type=blog" target="_blank" mdui-tooltip="{content: 'CSDN'}" style="color: rgb(199,29,35);background-color: rgba(199,29,35,.1);">
            <i class="nexmoefont icon-csdn"></i>
        </a><a class="mdui-ripple" href="https://www.cnblogs.com/lovetangyuxian/" target="_blank" mdui-tooltip="{content: '博客园'}" style="color: rgb(66, 214, 29);background-color: rgba(66, 214, 29, .1);">
            <i class="nexmoefont icon-bokeyuan"></i>
        </a><a class="mdui-ripple" href="https://github.com/tangyuxian/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://gitee.com/tangyuxian" target="_blank" mdui-tooltip="{content: 'gitee'}" style="color: rgb(255, 255, 255);background-color: rgb(199,29,35);">
            <i class="nexmoefont icon-mayun"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JavaScript/">JavaScript</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Node-js/">Node.js</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/TypeScript/">TypeScript</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/react/">react</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/代码管理/">代码管理</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/浏览器/">浏览器</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/node/" style="font-size: 20px;">node</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2024 Talita
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/tangyuxian/hexo-theme-tangyuxian" target="_blank">Tangyuxian</a><br/>
        <a href="http://beian.miit.gov.cn" target="_blank">辽ICP备2021002341号</a><br/>
        
        <div style="font-size: 12px">
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            本站总访问量  <a id="busuanzi_value_site_pv"></a> 次<br />
            本站访客数<a id="busuanzi_value_site_uv"></a>人次
        </div>
        
        
    </div>

</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2024/07/04/Nginx/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/browser.png" data-sizes="auto" alt="Nginx" class="lazyload">
                    <h1>Nginx</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年07月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 15 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器和个人电脑的区别：</p>
<ol>
<li><strong>设计目的和使用场景</strong>：<ul>
<li><strong>服务器</strong>设计用于提供连续的服务，如数据存储、网站托管、应用程序运行等，通常服务于多个用户或客户端。</li>
<li><strong>个人电脑</strong>主要用于个人工作、学习和娱乐，通常只服务于单个用户或少数用户。</li>
</ul>
</li>
<li><strong>硬件配置</strong>：<ul>
<li><strong>服务器</strong>拥有更高性能的处理器、更大容量的内存、更高速度和更大容量的存储设备。它们还可能包括特殊的硬件，如冗余电源、多个网络接口卡等，以提高可靠性和性能。</li>
<li><strong>个人电脑</strong>的硬件配置通常较为普通，满足日常使用需求，如文档编辑、上网浏览、视频播放等。</li>
</ul>
</li>
<li><strong>稳定性和可靠性</strong>：<ul>
<li><strong>服务器</strong>需要24小时不间断运行，因此在设计上更加注重稳定性和可靠性。服务器硬件通常包括故障转移和冗余功能，如RAID磁盘阵列、冗余电源等。</li>
<li><strong>个人电脑</strong>虽然也追求稳定性，但其设计和配置通常不如服务器那样重视持续运行和故障恢复。</li>
</ul>
</li>
<li><strong>操作系统和软件</strong>：<ul>
<li><strong>服务器</strong>运行的操作系统和软件更加专业化，如Windows Server、Linux服务器版等，这些操作系统优化了网络连接、数据处理和多任务处理。</li>
<li><strong>个人电脑</strong>通常运行的是面向普通用户的操作系统，如Windows 10、macOS等，这些系统更注重用户界面和易用性。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li><strong>服务器</strong>因为需要处理和存储大量敏感数据，所以在安全性方面有更高的要求。服务器操作系统和软件通常包括多种安全特性和工具，用于防止未授权访问和数据泄露。</li>
<li><strong>个人电脑</strong>虽然也具备一定的安全特性，但相比之下，其安全配置和防护措施可能不那么严格。</li>
</ul>
</li>
</ol>
<p>Nginx本身也只是一台服务器，它之所以能够实现反向代理和负载均衡的功能，是通过人为的配置来实现的。</p>
<p>Nginx的配置文件（通常是<code>nginx.conf</code>）允许管理员定义各种规则和指令，以控制Nginx如何处理请求。</p>
<h2 id="Nginx-特点"><a href="#Nginx-特点" class="headerlink" title="Nginx 特点"></a>Nginx 特点</h2><ul>
<li>更快：在高并发环境下，Nginx 比其他 WEB 服务器有更快的响应。</li>
<li>高扩展性：Nginx 是基于模块化设计，由多个耦合度极低的模块组成，因此具有很高的扩展性。许多高流量的网站都倾向于开发符合自己业务特性的定制模块。</li>
<li>高可靠性：Nginx 的可靠性来自于其核心框架代码的优秀设计，模块设计的简单性。另外，官方提供的常用模块都非常稳定，每个 worker 进程相对独立，master 进程在一个 worker 进程出错时可以快速拉起新的 worker 子进程提供服务。</li>
<li>低内存消耗：一般情况下，10000个非活跃的 HTTP Keep-Alive 连接在 Nginx 中仅消耗 2.5MB 的内存，这是 Nginx 支持高并发连接的基础。</li>
<li>单机支持10万以上的并发连接：理论上，Nginx 支持的并发连接上限取决于内存，10万远未封顶。</li>
<li>热部署：master 进程与 worker 进程的分离设计，使得 Nginx 能够提供热部署功能，即在 7x24 小时不间断服务的前提下，升级 Nginx 的可执行文件。当然，它也支持不停止服务就更新配置项，更换日志文件等功能。</li>
<li>最自由的 BSD 许可协议：这是 Nginx 可以快速发展的强大动力。BSD 许可协议不只是允许用户免费使用 Nginx ，它还允许用户在自己的项目中直接使用或修改 Nginx 源码，然后发布。</li>
</ul>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/07/04/Nginx/01.png" alt="Untitled" class="lazyload"></p>
<p>正向代理： 我们平时访问国外的资源是受限的，比如看推特，看GitHub等等。由于大陆特有的防火墙策略，直接用国内的服务器是无法访问国外的服务器的，所以我们需要配置一个代理服务器来帮助我们去访问，这种就是正向代理。</p>
<p>反向代理：当网站采用分布式部署时，即使用多台服务器共同处理用户请求，每台服务器都有自己独立的内存空间来存储Session数据，导致我们在服务器之间访问需要频繁登录，此时搭建一个反向代理服务器，由反向代理服务器去选择目标服务器获取数据，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是反向代理服务器的地址，隐藏了真实服务器的地址。</p>
<p>由于服务器一般用的都是Linux系统，所以安装和配置一般都用ubuntu</p>
<h3 id="Nginx安装、常用命令"><a href="#Nginx安装、常用命令" class="headerlink" title="Nginx安装、常用命令"></a><strong>Nginx安装、常用命令</strong></h3><ul>
<li>安装</li>
</ul>
<pre><code class="javascript">// ubuntu
sudo apt install nginx

安装成功后：
# Nginx 配置文件
/etc/nginx/nginx.conf # Nginx 主配置文件
/etc/nginx/nginx.conf.default

# 可执行程序文件
/usr/bin/nginx-upgrade
/usr/sbin/nginx

# Nginx 库文件
/usr/lib/systemd/system/nginx.service # 用于配置系统守护进程
/usr/lib64/nginx/modules # Nginx 模块目录

# 帮助文档
/usr/share/doc/nginx-1.16.1
/usr/share/doc/nginx-1.16.1/CHANGES
/usr/share/doc/nginx-1.16.1/README
/usr/share/doc/nginx-1.16.1/README.dynamic
/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10

# 静态资源目录
/usr/share/nginx/html/404.html
/usr/share/nginx/html/50x.html
/usr/share/nginx/html/index.html

# 存放 Nginx 日志文件
/var/log/nginx
</code></pre>
<ul>
<li>常用指令</li>
</ul>
<pre><code class="javascript"># 启动nginx
sevice nginx start
nginx

# 停止nginx
nginx -s stop
sevice nginx stop ##也可通过service命令
nginx -s quit   ##优雅关闭nginx(不接受新的连接请求，等待旧的连接请求处理完毕再关闭)

# 重新加载配置文件
nginx -s reload

# 测试配置文件
nginx -t
</code></pre>
<ul>
<li>日志分析</li>
</ul>
<p>nginx的日志文件默认存放在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;目录下(根据nginx.conf配置可能不同)。</p>
<p>nginx的log日志分为access log 和 error log。</p>
<p>其中access log 记录了哪些用户，哪些页面以及用户浏览器、ip和其他的访问信息，error log 则是记录服务器错误日志</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h3><p>常用Nginx配置：</p>
<pre><code class="javascript">########### 每个指令必须有分号结束。#################
# main 段配置信息 
user  nginx;                        # 运行用户，默认即是 Nginx，可以不进行设置
worker_processes  auto;             # Nginx 进程数，一般设置为和 CPU 核数一样
error_log  /var/log/nginx/error.log warn;   # Nginx 的错误日志存放目录
pid        /var/run/nginx.pid;      # Nginx 服务启动时的 pid 存放位置

# events 段配置信息
events &#123;
    worker_connections 1024;   # 每个进程允许最大并发数
&#125;

# http 段配置信息
# 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置
http &#123; 
    # 设置日志模式
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log  main;   # Nginx 访问日志存放位置

    sendfile            on;   # 开启高效传输模式
    tcp_nopush          on;   # 减少网络报文段的数量
    tcp_nodelay         on;
    keepalive_timeout   65;   # 保持连接的时间，也叫超时时间，单位秒
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;      # 文件扩展名与类型映射表
    default_type        application/octet-stream;   # 默认文件类型

    include /etc/nginx/conf.d/a.conf;   # 加载子配置项
    
    # server段配置信息
    server &#123;
     listen       80;       # 配置监听的端口
     server_name  localhost;    # 配置的域名
      
     # location段配置信息
     location / &#123;
      root   /usr/share/nginx/html;  # 网站根目录
      index  index.html index.htm;   # 默认首页文件
      deny 172.168.22.11;   # 禁止访问的 ip 地址，可以为 all
      allow 172.168.33.44；# 允许访问的 ip 地址，可以为 all
     &#125;
     
     error_page 500 502 503 504 /50x.html;  # 默认 50x 对应的访问页面
     error_page 400 404 error.html;   # 同上
    &#125;
&#125;
</code></pre>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>需求：使用 nginx 反向代理，访问 <a target="_blank" rel="noopener" href="http://i.meituan.com/">http://i.meituan.com/</a> 直接跳转到 <a target="_blank" rel="noopener" href="http://172.19.187.151:8080/">http://172.19.187.151:8080/</a></p>
<p>步骤：</p>
<ol>
<li><p>解决DNS域名服务器的映射问题：修改host文件<code>sudo vi /etc/hosts</code></p>
<p>添加从 <a target="_blank" rel="noopener" href="http://172.19.187.151:8080/">http://172.19.187.151:8080/</a>到 <a target="_blank" rel="noopener" href="http://i.meituan.com/">http://i.meituan.com/</a> 的映射</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/07/04/Nginx/02.png" alt="Untitled" class="lazyload"></p>
</li>
<li><p>配置nginx转发（反向代理）：mac下nginx的配置文件地址 <code>/usr/local/etc/nginx/nginx.conf</code></p>
</li>
<li><p>测试</p>
</li>
</ol>
<h3 id="配置跨域-CORS"><a href="#配置跨域-CORS" class="headerlink" title="配置跨域 CORS"></a>配置跨域 CORS</h3><p>例如：</p>
<ul>
<li>前端 server 的域名为：fe.com</li>
<li>后端服务的域名为：dev.com</li>
</ul>
<p>现在我在 fe.com 对 dev.com 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 Nginx 服务器，将 server_name 设置为 fe.com 然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回 dev.com。如下面的配置：</p>
<pre><code class="javascript">server &#123;
  listen      80; 
  server_name  fe.com; 
  location / &#123;  
    proxy_pass dev.com; 
    # proxy_pass用于配置代理服务器。
  &#125;
&#125;
</code></pre>
<ul>
<li>在<code>server</code>块内，<code>location</code>块用来匹配你希望转发的特定API路径。每个<code>location</code>块都将定义一个转发规则。<code>server_name</code>为想要处理的特定域名。</li>
<li>在<code>location</code>块内，使用<code>proxy_pass</code>指令可以指定后端服务的URL（包括协议、地址和端口），Nginx将把匹配到的请求转发到这个URL。</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是指Nginx将客户端的请求分发到多个后端服务器，以平衡每个服务器的负载。</p>
<p>通过配置文件中的<code>upstream</code>块和<code>proxy_pass</code>指令来指定需要转发的目标服务器，可以实现负载均衡。</p>
<pre><code class="javascript">upstream backend_servers &#123;
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;
&#125;

server &#123;
    listen 80;
    server_name example.com;

    location / &#123;
        proxy_pass http://backend_servers;
    &#125;
&#125;
</code></pre>
<p>在这个例子中，Nginx会将请求分发到<code>backend1.example.com</code>、<code>backend2.example.com</code>和<code>backend3.example.com</code>这三个后端服务器，从而实现负载均衡。</p>
<p>实现策略：</p>
<ol>
<li><p>轮询策略：默认情况下采用的策略（上面这种就是），将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>
</li>
<li><p>设置权重：默认为1，权重越高，分配的请求越多</p>
<pre><code class="javascript">upstream myserver&#123;
    server 127.0.0.1:8080 weight=1;
    server 127.0.0.1:8081 weight=2;
&#125;
</code></pre>
</li>
<li><p>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p>
<pre><code class="javascript">upstream myserver&#123;
    least_conn;
    server 127.0.0.1:8080;
    server 127.0.0.1:8081;
&#125;
</code></pre>
</li>
<li><p>最快响应时间策略：优先分配给响应时间最短的服务器。</p>
<pre><code class="javascript">upstream myserver&#123;
    fair;
    server 127.0.0.1:8080;
    server 127.0.0.1:8081;
&#125;
</code></pre>
</li>
<li><p>客户端 IP 绑定策略：来自同一个 IP 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。</p>
<pre><code class="javascript">upstream myserver&#123;
    ip_hash;
    server 127.0.0.1:8080;
    server 127.0.0.1:8081;
&#125;
</code></pre>
</li>
</ol>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>一般来说，都需要将动态资源和静态资源分开，由于 Nginx 的高并发和静态资源缓存等特性，经常将静态资源部署在 Nginx 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<h2 id="Nginx配置前端静态页面代码"><a href="#Nginx配置前端静态页面代码" class="headerlink" title="Nginx配置前端静态页面代码"></a><strong>Nginx配置前端静态页面代码</strong></h2><p>假设你的前端项目是一个单页面应用（SPA），所有的静态文件（HTML、CSS、JavaScript、图片等）都位于<code>/var/www/myfrontend</code>目录下，并且你希望你的网站通过<code>http://myfrontend.example.com</code>来访问，应该进行如下配置：</p>
<pre><code class="javascript">server &#123;  
    listen 80; # 监听80端口  
    server_name myfrontend.example.com; # 你的域名  
  
    # 访问日志和错误日志  
    access_log /var/log/nginx/myfrontend_access.log;  
    error_log /var/log/nginx/myfrontend_error.log;  
  
    location / &#123;  
        # 指定静态文件的根目录  
        root /var/www/myfrontend;  
        # 设置默认页面（如果你的单页面应用入口是index.html，则这样设置）  
        index index.html index.htm;  
  
        # 尝试按请求的文件名提供服务，如果找不到文件，则尝试提供index.html（这对单页面应用很重要）  
        try_files $uri $uri/ /index.html;  
    &#125;  
  
    # 其他可能的配置...  
  
    # 禁止访问.htaccess文件（如果你的项目中没有.htaccess文件，这行可以省略）  
    location ~ /\.ht &#123;  
        deny all;  
    &#125;  
&#125;
</code></pre>
<p>现在，你的前端静态页面应该可以通过<code>http://myfrontend.example.com</code>来访问了。请确保你的域名已经正确解析到了你的服务器IP地址，这个过程通常是通过在域名注册商那里设置DNS（域名系统）记录来完成的，并且服务器上的防火墙和安全组规则允许HTTP和HTTPS流量通过。</p>
<h3 id="Nginx-配置后端接口转发-API"><a href="#Nginx-配置后端接口转发-API" class="headerlink" title="Nginx 配置后端接口转发(API)"></a><strong>Nginx 配置后端接口转发(API)</strong></h3><p>将<code>/api</code>路径下的所有请求转发到后端API服务器<code>http://192.168.1.100:3000/</code>：</p>
<pre><code class="javascript">server &#123;  
    listen 80;  
    server_name api.example.com; # 你的域名  
  
    location /api/ &#123;  
        # 去掉请求URI中的/api前缀，并将其转发到后端服务的根路径  
        # 注意：末尾的斜杠（/）很重要，它告诉Nginx替换匹配到的URI部分  
        proxy_pass http://192.168.1.100:3000/;  
  
        # 设置请求头，以便后端服务可以获取原始请求的一些信息  
        proxy_set_header Host $host;  
        proxy_set_header X-Real-IP $remote_addr;  
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  
        proxy_set_header X-Forwarded-Proto $scheme;  
  
        # 如果后端服务不处理以斜杠（/）结尾的路径，并且你希望Nginx自动添加斜杠，则取消注释以下行  
        # proxy_redirect off;  
        # try_files $uri $uri/ =404;  
    &#125;  
  
    # 其他location块，用于处理其他路径的请求...  
  
    # 错误页面配置...  
&#125;
</code></pre>
<p>参考案例：前端请求添加水印的服务，是在div中请求一张背景图片的url，这个url就是一个api接口，需要在nginx中配置，导向实际要去的路径</p>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/06/27/react/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/react.png" data-sizes="auto" alt="react" class="lazyload">
                    <h1>react</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年06月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 19 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="认识-React"><a href="#认识-React" class="headerlink" title="认识 React"></a>认识 React</h2><p>React 的颠覆式创新点：</p>
<ol>
<li><p><strong>虚拟 DOM 机制：</strong>大幅度降低了 UI 上的操作难度</p>
<p>React 会自动用最优的方式将虚拟 DOM 更新到真实的 DOM 节点，不需要再使用浏览器 API 。<strong>当数据发生变化时，UI 能够自动把变化反映出来。</strong></p>
</li>
<li><p><strong>JSX 语法：</strong>简化代码</p>
</li>
</ol>
<p>16.8 版本引入了 Hooks 概念，解决了<strong>业务逻辑的重用问题</strong></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/06/27/react/Untitled.png" alt="Untitled" class="lazyload"></p>
<p>React 需要理解三个概念：组件、状态和 JSX。</p>
<ul>
<li>组件：React 中所有的元素都是组件，分为两种：<ol>
<li>内置组件：<strong>映射到 HTML 节点的组件</strong>，例如 <code>div、input、table</code> 等，作为一种约定，它们都是小写字母。</li>
<li>自定义组件：<strong>自己创建的组件，使用时必须以大写字母开头</strong>，例如<code>TopicList</code>、<code>TopicDetail</code>。</li>
</ol>
</li>
<li>状态：React 中的状态指的是与UI显示直接相关的数据，当这些数据发生变化时，React 会自动重新渲染组件以反映这些变化。</li>
<li>JSX：简化代码，本质和原生 JavaScript 没区别。</li>
</ul>
<h3 id="如何创建一个-React-应用？"><a href="#如何创建一个-React-应用？" class="headerlink" title="如何创建一个 React 应用？"></a><strong>如何创建一个 React 应用？</strong></h3><p>React官方推荐我们使用<code>Create React App</code>，使用如下命令创建：</p>
<pre><code class="bash">npx create-react-app my-app 
cd my-app
npm start
</code></pre>
<p>创建的项目结构非常简单，<code>src/index.js</code> 是程序的入口，<code>App.js</code>是整个应用程序的根组件，主要做一些配置的事情。当然还有以下常见脚手架：</p>
<ul>
<li>Next.js：如果你是在用 Node.js 构建服务端渲染的网站</li>
<li>Gatsby：如果你是在构建面向内容的静态网站</li>
<li>nwb：用于React应用程序、库和其他web npm模块的工具包</li>
<li>razzle：创建没有配置的服务器呈现的通用JavaScript应用程序</li>
<li>Neutrino：创建和构建零初始配置的现代JavaScript应用程序</li>
<li>Umijs：蚂蚁金服脚手架</li>
<li>Icejs：阿里巴巴脚手架</li>
</ul>
<h2 id="理解Hooks"><a href="#理解Hooks" class="headerlink" title="理解Hooks"></a>理解Hooks</h2><h3 id="重新思考-React-组件的本质"><a href="#重新思考-React-组件的本质" class="headerlink" title="重新思考 React 组件的本质"></a><strong>重新思考 React 组件的本质</strong></h3><p>React 组件中，状态发生变化时，UI 会自动变化，即<strong>所谓的数据绑定。</strong></p>
<p>React 要保证的，就是每当状态发生变化时，函数会重新执行，组件会重新渲染（re-render）。</p>
<p>但这并不是说组件的DOM树会被完全重建；React使用了一个名为<code>React Fiber</code>的算法，它包括计算新的 React 元素树，然后与实际DOM进行比较，并计算出最小的DOM更新，生成新的 DOM 树更新到浏览器。</p>
<p>在 hooks 机制出现之前，函数组件的局限性在于无法存在内部状态，而且也无法提供完<br>整的生命周期机制，这就极大限制了函数组件的大规模使用。</p>
<p>函数和对象不同，并没有一个实例的对象能够在多次执行之间保存状态，那势必需要一个函数之外的空间来保存这个状态，而且要能够检测其变化，从而能够触发函数组件的重新渲染。</p>
<p>在 React 中，这个机制就是 Hooks，Hooks 就是“钩子”的意思。<strong>把某个目标结果钩到某个可能会变化的数据源或者事件源上，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生最终更新后的结果，也就是DOM树。</strong></p>
<p>对于 <code>useCallback</code>、<code>useMemo</code> 这样与缓存相关的组件，则是在依赖项发生变化时去更新缓存。</p>
<blockquote>
<p>常用数据源：定时器，监听滚动，键盘事件，复用Fetch，父组件props</p>
</blockquote>
<p><strong>Hooks 使用原则：</strong></p>
<ol>
<li>只能在函数组件或自定义 Hook 的顶层调用，不能在循环、条件或嵌套函数中调用</li>
<li>每个 Hook 调用都会创建一个独立的状态变量，可以在同一个组件中多次调用 Hook 来创建多个状态变量</li>
<li>不能将 Hook 放在 <code>return</code> 之后，即使<code>return</code> 只是可能会被执行到</li>
</ol>
<h3 id="useState：让函数组件具有维持状态的能力"><a href="#useState：让函数组件具有维持状态的能力" class="headerlink" title="useState：让函数组件具有维持状态的能力"></a><strong>useState：让函数组件具有维持状态的能力</strong></h3><p>纯函数不能有状态，所以把状态放在钩子里面，<code>useState()</code>用于为函数组件引入状态。</p>
<p>用法：</p>
<ol>
<li><code>useState(initialState)</code> 的参数 <code>initialState</code> 是创建 <code>state</code> 的初始值。</li>
<li><code>useState()</code> 的返回值是一个数组。第一个数组元素用来读取 <code>state</code> 的值，第二个则是用来设置<code>state</code> 值的函数，约定是<code>set</code>前缀加上状态的变量名。</li>
</ol>
<p><code>state</code>是组件内部的私有对象，只能通过<code>setState</code>方法来更新。其他组件不能直接看到或修改这个<code>state</code>，除非通过组件之间的通信机制，<code>props、context</code>或<code>Redux</code>等状态管理库。</p>
<p>在使用过程中，后者的性能要优于前者，因为后者在<code>count</code> 发生变化的时候，不会创建新的函数引用，这样接收这个属性的组件就不需要刷新，只用更新变量即可</p>
<pre><code class="jsx">const handleIncrement = useCallback(() =&gt; setCount(count + 1), [count]); 
const handleIncrement = useCallback(() =&gt; setCount(count =&gt; count + 1), []);
</code></pre>
<p><strong>什么样的值应该保存在 <code>state</code> 中?</strong></p>
<p><code>state</code> 中永远不要保存可以通过计算得到的值。比如：</p>
<ol>
<li>如果从 <code>props</code> 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示。那么我们要做的就是每次用的时候，都重新计算一下，或者利用某些 cache 机制，而不是将结果直接放到 <code>state</code> 里。</li>
<li>如果需要读取 URL 中的参数，那么我们可以在每次需要用的时候都从 URL 中读取，而不是读出来直接放到 <code>state</code> 里。</li>
<li>每次要用 <code>cookie</code>、<code>localStorage</code> 的值的时候直接去读取，而不是读出来后放到 <code>state</code> 里。</li>
</ol>
<p><strong>无状态组件：</strong></p>
<p><code>state</code> 虽然便于维护状态，但也有自己的弊端：</p>
<ol>
<li><p>一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。</p>
<p><em>比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本组件的 <code>state</code> 里，那么每个用到这个组件的地方，就都需要重新获取一遍。</em></p>
</li>
<li><p>有状态组件在每次渲染时都需要执行生命周期方法和<code>render</code>方法。</p>
</li>
</ol>
<p>而无状态组件只关注接收<code>props</code>并渲染UI，并且由于只是函数只需要执行函数，没有内部状态或复杂的生命周期方法，只是一个纯粹的表现层，没有太多的业务逻辑，非常易于使用、测试和维护。</p>
<h3 id="useEffect：执行副作用"><a href="#useEffect：执行副作用" class="headerlink" title="useEffect：执行副作用"></a><strong>useEffect：执行副作用</strong></h3><p><code>useEffect()</code>用来引入具有副作用的操作，<strong>每次组件 render 完后判断依赖并执行。</strong></p>
<p>“副作用”是一个编程术语，通常指的是在函数执行过程中，除了返回结果之外还产生的其他影响。在纯函数式编程中，函数通常只根据输入计算输出，而不产生任何副作用。但在React等现代前端框架中，由于我们需要与DOM交互、处理用户输入、从服务器获取数据等，因此副作用是不可避免的。</p>
<p>用法：</p>
<pre><code class="jsx">useEffect(()  =&gt;  &#123;
  // Async Action
&#125;, [dependencies])
</code></pre>
<ol>
<li>没有依赖项：每次render后都会重新执行</li>
<li>空数组：只在函数首次执行时触发</li>
<li>存在依赖项：依赖项发生变化时自动执行</li>
<li>回调中存在<code>return</code>：组件销毁时的清理操作</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>回调函数中用到的变量一定要在依赖项中定义</li>
<li>函数是不会变化的，不要监听函数</li>
<li>React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类<br>型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化</li>
</ol>
<h3 id="useCallback：缓存回调函数"><a href="#useCallback：缓存回调函数" class="headerlink" title="useCallback：缓存回调函数"></a><strong>useCallback：缓存回调函数</strong></h3><p>在 React 函数组件中，每次 UI 变化都是通过重新执行整个函数来完成的，这会导致一些函数和变量的重复定义，增加系统开销。</p>
<pre><code class="jsx">import React, &#123; useState &#125; from &quot;react&quot;;
export default function Counter() &#123;
  const [count, setCount] = useState(0);
  const handleIncrement = () =&gt; setCount(count + 1);
  return &lt;button onClick=&#123;handleIncrement&#125;&gt;&#123;count&#125;&lt;/button&gt;;
&#125;
</code></pre>
<p>思考下这个过程，每次组件状态发生变化的时候，函数组件都会重新执行一遍。每次执行都会创建一个新的事件处理函数 <code>handleIncrement</code>。函数中又包含了 <code>count</code> 变量的闭包，以确保每次能够得到正确的结果。</p>
<p>这也意味着，即使 <code>count</code> 没有发生变化，每次刷新时也会创建一个新的函数。这样做不仅增加了系统的开销，更重要的是：<strong>每次创建新函数都会使组件的 props 刷新，从而让组件重新渲染</strong>。</p>
<p>因此，我们需要做到的是：<strong>只有当 count 发生变化时，我们才需要重新定义一个回调<br>函数，</strong>这正是 <code>useCallback</code> 这个 Hook 的作用。</p>
<p>用法：</p>
<pre><code class="jsx">useCallback(fn, deps)
</code></pre>
<p>只有当依赖变量 <code>deps</code> 发生变化时， 才会重新声明 <code>fn</code> 这个回调函数。上面例子通过 <code>useCallback</code> 来进行性能的优化：</p>
<pre><code class="jsx">const handleIncrement = useCallback(() =&gt; setCount(count + 1), [count]);
</code></pre>
<p>这样，只有 <code>count</code> 发生变化的时候，才需要重新创建一个回调函数。而接收这个回调函数作为属性的组件，也不会频繁地需要重新渲染。</p>
<p>除了 <code>useCallback</code>，<code>useMemo</code> 也是为了缓存而设计的。只不过 <code>useCallback</code> 缓存的是 一个函数，而 <code>useMemo</code> 缓存的是计算的结果。</p>
<h3 id="useMemo：缓存计算的结果"><a href="#useMemo：缓存计算的结果" class="headerlink" title="useMemo：缓存计算的结果"></a><strong>useMemo：缓存计算的结果</strong></h3><p><strong>如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算</strong>。</p>
<pre><code class="jsx">useMemo(fn, deps);
</code></pre>
<p>其中，<code>fn</code> 是产生所需数据的一个计算函数，<code>deps</code> 是依赖项。</p>
<p>避免重复计算不仅节省了计算开销，还<strong>避免子组件的重复渲染</strong>。</p>
<pre><code class="jsx">const userToShow = useMemo(()=&gt;&#123;
  if(!user) return null
  return user.data.filter((user)=&gt;&#123;
      return user.first_name.includes(searchKey)
  &#125;)
&#125;,[user,searchKey])
</code></pre>
<p><code>useCallback</code> 的功能可以用 <code>useMemo</code> 来实现：</p>
<pre><code class="jsx">const myEventHandler = useMemo(() =&gt; &#123; 
    // 返回一个函数作为缓存结果
    return () =&gt; &#123;
    // 在这里进行事件处理
    &#125;
&#125;, [dep1, dep2]);
</code></pre>
<p>从本质上来说，它们做了同一件事情：<strong>建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到</strong>。</p>
<h3 id="useRef：在多次渲染之间共享数据"><a href="#useRef：在多次渲染之间共享数据" class="headerlink" title="useRef：在多次渲染之间共享数据"></a>useRef：在多次渲染之间共享数据</h3><p>函数组件和类组件不一样，没有在多次渲染之间共享数据的能力。React 提供了 <code>useRef</code>这个 Hook，在函数组件之外创建的一个容器空间，用来模拟类组件的成员变量。</p>
<pre><code class="tsx">const myRefContainer = useRef(initialValue);
</code></pre>
<p> <code>useRef</code>返回的是一个包含<code>.current</code>属性的对象，这个属性可以指向任何类型的值，并且这个值在组件的多次渲染之间会保持不变。</p>
<p>使用场景：</p>
<ol>
<li><p><strong>访问 DOM 元素</strong>：<code>useRef</code> 最常见的用途是获取对 DOM 元素的直接引用。例如，你可能想要聚焦一个输入框，或者测量某个元素的大小</p>
<pre><code class="jsx">function TextInputWithFocusButton() &#123;  
  const inputElement = useRef(null);  
  
  const handleClick = () =&gt; &#123;
      // current属性指向了真实的dom节点，从而可以调用节点的方法  
    inputElement.current.focus();  
  &#125;;  
  
  return (  
    &lt;&gt;  
      &lt;input ref=&#123;inputElement&#125; type=&quot;text&quot; /&gt;  
  
      &lt;button onClick=&#123;handleClick&#125;&gt;Focus the input&lt;/button&gt;  
    &lt;/&gt;  
  );  
&#125;
</code></pre>
</li>
<li><p><strong>存储变量值</strong>：存储不会触发重新渲染的值，例如定时器 ID、上一次的滚动位置、或者其他任何你需要在组件的不同生命周期中保持的数据。</p>
<pre><code class="jsx">import React, &#123; useCallback, useState, useRef &#125; from &quot;react&quot;;
export default function Timer() &#123;
  const [time, setTime] = useState(0);
  const timer = useRef(null);
  const start = useCallback(()=&gt;&#123;
    // 依赖项数组为空，代表多次渲染下函数的引用依然不变，不必再重新创建
    // 将定时器作为ref，可以在多次渲染之间保留定时器
    // 但是不影响time的值，time的值正常变化
    timer.current = window.setInterval(()=&gt;&#123;
      setTime(time=&gt;time+1)
    &#125;,1000)
  &#125;,[])
  const stop = useCallback(() =&gt; &#123;
    // 按下stop会清除定时器，将定时器移除
    // 这样可以在多次渲染之间保证定时器的引用不会被重新创建，创建和删除的始终是同一个定时器
    // 虽然这一点useState也可以做到，但是useState每次更新值都会导致组件被重新渲染
    // 显然定时器的清除和创建是不需要组件重新渲染的，因此使用useRef可以节省开销
    // 此外，useRef的更新是实时的，你可以立刻看到更新后的值
    // 但是state由于涉及重新渲染，react出于性能考虑，在使用set更新之后并不会立即更新状态和重新渲染，而是累积几个更新一起渲染来提升性能
    window.clearInterval(timer.current);
    timer.current = null;
  &#125;, []);
  return (
    &lt;div&gt;
      &#123;time / 10&#125; seconds
      &lt;br /&gt;
      &lt;button onClick=&#123;start&#125;&gt;Start&lt;/button&gt;
      &lt;button onClick=&#123;stop&#125;&gt;Stop&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
</li>
<li><p><strong>将值传递给子组件</strong>：在某些情况下，你可能需要将父组件中的某个值传递给子组件，但这个值不需要是 React 状态。使用 <code>useRef</code> 可以避免不必要的重新渲染。</p>
</li>
<li><p><strong>保持不变的回调函数引用</strong>：虽然 <code>useCallback</code> 通常用于这个目的，但在某些情况下，<code>useRef</code> 可以用来存储一个不会改变的回调函数引用。</p>
</li>
</ol>
<h3 id="useContext：定义全局状态"><a href="#useContext：定义全局状态" class="headerlink" title="useContext：定义全局状态"></a><strong>useContext：定义全局状态</strong></h3><p>React 组件之间的状态传递方式只有三种：<code>props</code>、<code>Context</code>、<code>Redux</code>等全局状态管理库</p>
<p><code>props</code> 只能在父子组件之间进行，如果要跨层次，或者同层的组件之间要进行数据的共享，React 提供了 <code>Context</code> 这样一个机制，能够让所有在某个组件开始的组件树上访问和修改这个 <code>Context</code>。</p>
<p>创建一个<code>Context</code>对象：</p>
<pre><code class="jsx">const MyContext = createContext(initialValue);
</code></pre>
<p><code>Context</code>对象具有一个 <code>Provider</code> 的属性，一般是作为组件树的根组件，为其后代组件提供 <code>Context</code> 的值，因此<code>value</code>属性是必须的，即使在创建的时候已经定义了初始值：</p>
<pre><code class="jsx">&lt;ThemeContext.Provider value=&quot;dark&quot;&gt;  
  &lt;Toolbar /&gt;  
&lt;/ThemeContext.Provider&gt;
</code></pre>
<p>使用<code>Context</code>中的数据：</p>
<pre><code class="jsx">const theme = useContext(ThemeContext);
</code></pre>
<p><code>Context</code>看上去就是一个全局的数据，为什么要设计这样一 个复杂的机制，而不是直接用一个全局的变量去保存数据呢，就是<strong>为了能够进行数据的绑定</strong>。</p>
<p>它和 <code>state</code> 一样，数据变化是可以引起组件的重新渲染的，如果只是一个全局变量的话就没有这种功能了。</p>
<p>把<code>Context</code>的<code>value</code>值用<code>state</code>来保存，还能把<code>Context</code>也变成一个动态的变量。</p>
<pre><code class="jsx">function ThemeBtn(props) &#123;
  // 如果不使用useContext，是无法直接使用Context中的值的
  const theme = useContext(ThemeContext);
  return (
    &lt;button
      style=&#123;&#123;
        background: theme.background,
        color: theme.foreground,
      &#125;&#125;
      onClick=&#123;props.click&#125;
    &gt;
      Look here!
    &lt;/button&gt;
  );
&#125;

export default function Theme() &#123;
  const [color, setColor] = useState(&quot;light&quot;);
  const toggleColor = useCallback(() =&gt; &#123;
    setColor((color) =&gt; (color === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;));
  &#125;, []);
  return (
    &lt;ThemeContext.Provider value=&#123;themes[color]&#125;&gt;
      &lt;ThemeBtn click=&#123;toggleColor&#125; /&gt;
      // 其他组件
    &lt;/ThemeContext.Provider&gt;
  );
&#125;
</code></pre>
<p><code>Context</code>同样有局限性：</p>
<ol>
<li><code>Context</code>的变化很难追踪造成调试困难</li>
<li>组件复用比较困难，必须保证<code>Context</code>的存在才能复用</li>
</ol>
<p>所以在 React 的开发中，除了像 Theme、Language 等一目了然的需要全局设置的变量外，很少会使用 Context 来做太多数据的共享。</p>
<h3 id="如何创建自定义-Hooks"><a href="#如何创建自定义-Hooks" class="headerlink" title="如何创建自定义 Hooks?"></a><strong>如何创建自定义 Hooks?</strong></h3><p>自定义 Hooks 在形式上就是<strong>声明一个名字以 use 开头的函数</strong>，比如<code>useCounter</code>。但是要注意，自定义 Hooks 在<strong>函数中需要用到其它Hooks。</strong></p>
<pre><code class="jsx">import React, &#123; useCallback, useState &#125; from &quot;react&quot;;
function useCounter()&#123;
  const [count, setCount] = useState(0);
  const handleIncrement = useCallback(() =&gt; setCount(count=&gt;count + 1), []);
  const handleDecrement = useCallback(() =&gt; setCount(count=&gt;count - 1), []);
  const reset = useCallback(() =&gt; setCount(0), []);
  return &#123;count,handleIncrement,handleDecrement,reset&#125;;
&#125;
// 另一个js文件
export default function Counter() &#123;
  const &#123;count,handleIncrement,handleDecrement,reset&#125;=useCounter()
  return (&lt;div&gt;
    &lt;button onClick=&#123;handleIncrement&#125;&gt;+&lt;/button&gt;
    &lt;p&gt;&#123;count&#125;&lt;/p&gt;
    &lt;button onClick=&#123;handleDecrement&#125;&gt;-&lt;/button&gt;
    &lt;button onClick=&#123;reset&#125;&gt;reset&lt;/button&gt;
  &lt;/div&gt;)
&#125;
</code></pre>
<p>通过自定义Hook的方式，可以把逻辑提取出来，成为一个单独的Hook，<strong>一方面能让这个逻辑得到重用，另外一方面也能让代码更加语义化</strong>，<strong>并且易于理解和维护。</strong></p>
<p><strong>三个典型的业务场景：</strong></p>
<ol>
<li><p><strong>封装通用逻辑：useAsync</strong></p>
<p><strong>发起异步请求获取数据并显示在界面上：</strong>请求正确返回、UI 展现数据、处理请求出错</p>
<p>为什么不写一个工具类，而是封装成Hooks呢？写成工具类还能用Hook，能用state吗</p>
<pre><code class="jsx">import React, &#123; useCallback, useState &#125; from &quot;react&quot;;
const useAsync = (asyncFn) =&gt; &#123;
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState(null);
  const execute = useCallback(() =&gt; &#123;
    // 请求开始，清除数据列表和错误，设置loading状态
    setLoading(true);
    setData(null);
    setErr(null);
    return asyncFn()
      .then((res) =&gt; &#123;
        // 如果请求成功，将数据写进data，设置loading为false
        setData(res);
        setLoading(false);
      &#125;)
      .catch((err) =&gt; &#123;
        setErr(err);
        setLoading(false);
      &#125;);
  &#125;, [asyncFn]);
  return &#123; execute, loading, data, err &#125;;
&#125;;
export default function UserList() &#123;
  const &#123;
    execute: fetchUsers,
    loading,
    data: users,
    err,
  &#125; = useAsync(async () =&gt; &#123;
    const res = await fetch(&quot;https://reqres.in/api/users/&quot;);
    const json = await res.json();
    return json.data;
  &#125;);
  return (
    &lt;div&gt;
      &lt;button onClick=&#123;fetchUsers&#125; disabled=&#123;loading&#125;&gt;
        &#123;loading ? &quot;loading...&quot; : &quot;Show Users&quot;&#125;
      &lt;/button&gt;
      &#123;err &amp;&amp; &lt;div&gt;出现错误&lt;/div&gt;&#125;
      &lt;br /&gt;
      &lt;ul&gt;
        &#123;users &amp;&amp;
          users.length &gt; 0 &amp;&amp;
          users.map((user) =&gt; &lt;li key=&#123;user.id&#125;&gt;&#123;user.first_name&#125;&lt;/li&gt;)&#125;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
</li>
</ol>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/28/T1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/TypeScript.png" data-sizes="auto" alt="TypeScript介绍（一）" class="lazyload">
                    <h1>TypeScript介绍（一）</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>7.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 34 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h1 id="TypeScript基础语法"><a href="#TypeScript基础语法" class="headerlink" title="TypeScript基础语法"></a>TypeScript基础语法</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote>
<p><em>TypeScript是微软公司开发的一种基于JavaScript语言的编程语言，它的目的是增强 JavaScript 的功能， 可以看成是 JavaScript 的超集，即它继承了后者的全部语法，又增加了一些自己的语法，使其更适合多人合作的企业级项目。</em></p>
</blockquote>
<p>TypeScript 的主要功能是为 JavaScript 添加类型系统。在语法上，JavaScript 属于<strong>动态类型语言</strong>，声明一个变量后可以任意改变其类型，不具有很强的约束性。TypeScript 属于<strong>静态类型语言，</strong>类型错误时在开发阶段就会报错，有利于提早发现错误，避免使用时报错。</p>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p><strong>声明方式：</strong></p>
<p>类型声明为在标识符后面添加“<strong>冒号 + 类型</strong>”。<strong>函数参数</strong>和<strong>返回值</strong>，也是这样来声明类型。</p>
<pre><code class="tsx">let foo:string;

function toString(num:number):string &#123;
  return String(num);
&#125;
</code></pre>
<p><strong>使用规则：</strong></p>
<ol>
<li>类型声明并不是必需的，如果没有，<strong>TypeScript 会自己推断类型</strong>。如果变量更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</li>
<li>TypeScript 规定，<strong>变量只有赋值后才能使用</strong>，否则就会报错。而 JavaScript 允许这种行为，没有赋值的变量会返回<code>undefined</code>。</li>
<li>TypeScript 可以推断函数的返回值，因此<strong>函数返回值的类型通常是省略不写的。</strong></li>
</ol>
<h3 id="TypeScript-的编译"><a href="#TypeScript-的编译" class="headerlink" title="TypeScript 的编译"></a><strong>TypeScript 的编译</strong></h3><p>JavaScript 的运行环境（浏览器和 Node.js）不认识 TypeScript 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“编译”（compile）。</p>
<p>经过编译后，类型声明和类型相关的TypeScript代码将全部删除，只留下能运行的 JavaScript 代码。因此，TypeScript 的类型检查只是<strong>编译时的类型检查</strong>，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<p><strong>tsc 编译器：</strong></p>
<p>TypeScript 官方提供的编译器叫做 tsc，用于将 TypeScript 脚本编译成可供运行的 JavaScript 脚本。</p>
<p>tsc编译后，会在当前目录下生成一个同名的JavaScript脚本文件，这个脚本就完全是编译后生成的 JavaScript 代码，需要使用额外的命令来运行它。</p>
<pre><code class="bash">$ tsc app.ts 
$ node app.js
</code></pre>
<p>tsc的基本用法如下：</p>
<pre><code class="bash"># 使用 tsconfig.json 的配置
$ tsc
# 只编译 index.ts
$ tsc index.ts
# 编译 src 目录的所有 .ts 文件
$ tsc src/*.ts
# 指定编译配置文件
$ tsc --project tsconfig.production.json
# 只生成类型声明文件，不编译出 JS 文件
$ tsc index.js --declaration --emitDeclarationOnly
# 多个 TS 文件编译成单个 JS 文件
$ tsc app.ts util.ts --target esnext --outfile index.js --outDir dist
</code></pre>
<ol>
<li><code>--outFile</code>：使用该参数可将多个 TypeScript 脚本编译成一个 JavaScript 文件。</li>
<li><code>--outDir</code>：编译结果默认保存在当前目录，<code>--outDir</code>参数可以指定保存到其他目录。</li>
<li><code>--target</code>：为了保证编译结果能在各种 JavaScript 引擎运行，tsc 默认会将 TypeScript 代码编译成很低版本的 JavaScript，即3.0版本（以<code>es3</code>表示）。使用<code>--target</code>参数可以指定编译后的 JavaScript 版本。建议使用<code>es2015</code>，或者更新版本。</li>
<li><code>--noEmitOnError</code>：一旦报错就停止编译，不生成编译产物。</li>
<li><code>--noEmit</code>：只检查类型是否正确，不生成 JavaScript 文件。</li>
</ol>
<p>TypeScript 允许将<code>tsc</code>的编译参数，写在配置文件<code>tsconfig.json</code>。只要当前目录有这个文件，<code>tsc</code>就会自动读取，运行时不用再写各项参数。也可以在输入命令时通过<code>--project</code> 指定具体的编译配置文件。例如：</p>
<pre><code class="json">&#123;  
  &quot;files&quot;: [&quot;dd.ts&quot;, &quot;aa.ts&quot;],  
  &quot;compilerOptions&quot;: &#123;  
    &quot;outFile&quot;: &quot;dist/app.js&quot;  
  &#125;  
&#125;
</code></pre>
<p><code>tsconfig.json</code>的具体配置项参见<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-tsconfig.json.md">https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-tsconfig.json.md</a>。</p>
<p><strong>ts-node工具：</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node</a> 是一个需要安装的非官方 npm 模块，它允许你运行 TypeScript 代码而无需先编译它。使用时，可以<code>npm install -g ts-node</code>先全局安装它。安装后，就可以直接<code>ts-node script.ts</code>运行 TypeScript 编译后的脚本。</p>
<p>如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行输入代码运行。例如：</p>
<pre><code class="bash">$ ts-node
&gt; const twice = (x:string) =&gt; x + x;
&gt; twice(&#39;abc&#39;)
&#39;abcabc&#39;
&gt;
</code></pre>
<p>要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入<code>.exit</code>。</p>
<p>如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>TypeScript 继承了 JavaScript 的类型设计，将值分成8种类型：<code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>、<code>undefined</code>、<code>null</code>。</p>
<aside>
💡 任意类型转boolean只要加`！！`即可


</aside>

<p>其中<code>undefined</code>和<code>null</code>是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p>
<p><strong>所有类型的名称都是小写字</strong>母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript 语言中是<strong>内置对象</strong>，提供了用于该对象的多种方法。例如，<code>Number.parseInt()</code>、<code>Number.parseFloat()</code>、<code>Number.isNaN()</code>。</p>
<p><strong>包装对象：</strong></p>
<p>在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。但类似<code>&#39;hello&#39;.charAt(1)</code> 这样的代码是可以运行的，因为在调用方法时，字符串会自动转为包装对象，<code>charAt()</code>方法其实是定义在包装对象上。这样的设计省去了将原始类型的值手动转成对象实例的麻烦。</p>
<p>五种基本类型中，除了symbol 类型和 bigint 类型外，都可以使用构造函数来获取包装对象。</p>
<p>在TypeScript中，大写类型同时包含<strong>包装对象和字面量</strong>（字面量表示固定的值）两种情况，小写类型<strong>只包含字面量</strong>，不包含包装对象。</p>
<p><strong>建议只使用小写类型，不使用大写类型。</strong></p>
<p>而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p>
<p><strong>bigint：</strong></p>
<p><code>bigint</code> 类型是 ES2020 标准引入的，且 <code>bigint</code> 与 <code>number</code> 类型不兼容。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数<code>target</code>不低于<code>es2020</code>）。</p>
<p><strong>undefined 和 null：</strong></p>
<p><code>undefined</code> 和 <code>null</code> 是所有类型的子类型，且各自都只有一个值，因此其他类型的变量都可以被赋值为<code>null</code> 和 <code>undefined</code> 。</p>
<p><code>undefined</code> 类型表示未定义（即还未给出定义，以后可能会有定义）。</p>
<p><code>null</code> 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p>
<h3 id="基本数据类型-Symbol"><a href="#基本数据类型-Symbol" class="headerlink" title="基本数据类型 Symbol"></a><strong>基本数据类型 Symbol</strong></h3><p><strong>Symbol的基本用法：</strong></p>
<p><code>Symbol</code>是ES6 新增的数据类型 ，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用<code>Symbol()</code>函数来创建一个<code>Symbol</code>实例。传入的可选的字符串参数，相当于给你创建的Symbol实例一个描述信息。</p>
<pre><code class="tsx">let s1 = Symbol()
let s2 = Symbol(&#39;another symbol&#39;)
</code></pre>
<p>如何理解Symbol的唯一性：</p>
<pre><code class="tsx">let s1 = Symbol()
let s2 = Symbol(&#39;another symbol&#39;)
let s3 = Symbol(&#39;another symbol&#39;)

s1 === s2 // false
s2 === s3 // false
</code></pre>
<p><strong>应用场景1：使用Symbol来作为对象属性名</strong></p>
<pre><code class="tsx">const PROP_NAME = Symbol()
const PROP_AGE = Symbol()

let obj = &#123;
    // 将Symbol作为对象属性名时，需要写在[]里
  [PROP_NAME]: &quot;一斤代码&quot;
&#125;
obj[PROP_AGE] = 18

obj[PROP_NAME] // &#39;一斤代码&#39;
obj[PROP_AGE] // 18
</code></pre>
<p>注意：<code>Symbol</code>类型的<code>key</code>不会被列举</p>
<pre><code class="tsx">let obj = &#123;
   [Symbol(&#39;name&#39;)]: &#39;一斤代码&#39;,
   age: 18,
   title: &#39;Engineer&#39;
&#125;

Object.keys(obj)   // [&#39;age&#39;, &#39;title&#39;]

for (let p in obj) &#123;
   console.log(p)   // 分别会输出：&#39;age&#39; 和 &#39;title&#39;
&#125;

Object.getOwnPropertyNames(obj)   // [&#39;age&#39;, &#39;title&#39;]

JSON.stringify(obj)  // &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125;
</code></pre>
<p>如果实在想获取以Symbol方式定义的对象属性，还是有一些专门针对Symbol的API的，比如：</p>
<pre><code class="tsx">// 使用Object的API
Object.getOwnPropertySymbols(obj) // [Symbol(name)]

// 使用新增的反射API
Reflect.ownKeys(obj) // [Symbol(name), &#39;age&#39;, &#39;title&#39;]
</code></pre>
<p><strong>应用场景2：使用Symbol来替代常量</strong></p>
<pre><code class="tsx">const TYPE_AUDIO = &#39;AUDIO&#39;
const TYPE_VIDEO = &#39;VIDEO&#39;
const TYPE_IMAGE = &#39;IMAGE&#39;
// 使用Symbol来替代常量(Symbol的唯一性)
const TYPE_AUDIO = Symbol()
const TYPE_VIDEO = Symbol()
const TYPE_IMAGE = Symbol()
</code></pre>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>大写的<code>Object</code>类型为原型链的最顶端，所有类型的父类型，代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，也就是说，<strong>原始类型值、对象、数组、函数</strong>都是合法的<code>Object</code>类型。</p>
<p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。另外，空对象<code>&#123;&#125;</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p>
<pre><code class="tsx">let obj:Object;
let obj:&#123;&#125;;

obj = undefined; // 报错
obj = null; // 报错
</code></pre>
<p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p>
<p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即<strong>只包含对象、数组和函数</strong>，不包括原始类型的值。所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p>
<p>注意：无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象<strong>原生的属性和方法</strong>，用户自定义的属性和方法都不存在于这两个类型之中。</p>
<pre><code class="tsx">const o1:Object = &#123; foo: 0 &#125;;
const o2:object = &#123; foo: 0 &#125;;

o1.toString() // 正确
o1.foo // 报错

o2.toString() // 正确
o2.foo // 报错
</code></pre>
<p>在TypeScript中，只有<code>toString()</code>是<code>object</code>对象的原生方法，可以正确访问。</p>
<p>非常麻烦，因此在实际开发中，尽量避免使用 <code>Object</code> 或 <code>object</code> 类型，除非有特定的原因。使用更具体的类型可以提供更好的类型安全性和可读性。</p>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/28/T1/Untitled.png" alt="Untitled" class="lazyload"></p>
<h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a><strong>any 类型</strong></h3><p>any 类型表示任意类型，一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查，即使有明显的类型错误。</p>
<pre><code class="tsx">let x:any = &#39;hello&#39;;

x(1) // 不报错
x.foo = 100; // 不报错
</code></pre>
<p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p>
<p>从集合论的角度看，<code>any</code>类型可以看成是“<strong>顶层类型</strong>”（top type），包含了一切可能的类型。</p>
<p><strong>类型推断为any：</strong></p>
<p>TypeScript 如果无法推断出类型，就会认为该变量的类型是<code>any</code>，后面就不再对其进行类型检查了。这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为<code>any</code>。</p>
<p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，只要推断出<code>any</code>类型就会报错。</p>
<pre><code class="bash">$ tsc --noImplicitAny app.ts
</code></pre>
<p>使用<code>let</code>和<code>var</code>声明变量时如果不赋值，也没有指定类型，TypeScript 会推断它们的类型为<code>any</code>。这时即使打开了<code>noImplicitAny</code>，也不会报错。</p>
<pre><code class="tsx">let x;

x = 123;
x = &#123; foo: &#39;hello&#39; &#125;;
</code></pre>
<p>因此使用<code>let</code>和<code>var</code>声明变量时，<strong>如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</strong></p>
<p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）。</p>
<p><strong>any的污染问题：</strong></p>
<p><code>any</code>类型可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量也被污染为<code>any</code>类型。</p>
<pre><code class="tsx">let x:any = &#39;hello&#39;;
let y:number;

y = x; // 不报错

y * 123 // 不报错
y.toFixed() // 不报错
</code></pre>
<p>由于TypeScript 检查不出错误，问题就这样留到运行时才会暴露，这就是不宜使用<code>any</code>类型的另一个主要原因。</p>
<h3 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a><strong>unknown 类型</strong></h3><ol>
<li><code>unknown</code><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">类型</a>是<code>any</code>的安全类型，但定义后变量将变成<code>private</code>，不能再赋值给别的变量，也不能直接调用。</li>
<li><code>unknown</code>类型只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符，其他运算都会报错。</li>
</ol>
<p>怎么才能取出<code>unknown</code>类型变量呢？</p>
<p>答案是“<strong>类型缩小</strong>”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p>
<pre><code class="tsx">let a:unknown = 1;
if (typeof a === &#39;number&#39;) &#123;
  let r = a + 10; // 正确
&#125;

let s:unknown = &#39;hello&#39;;
if (typeof s === &#39;string&#39;) &#123;
  s.length; // 正确
&#125;
</code></pre>
<p>只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p>
<p>一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p>
<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a><strong>never 类型</strong></h3><p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。它等同于空集，即不可能赋给它任何值，否则都会报错，但是可以赋值给任意其他类型。</p>
<p><code>never</code>类型的使用场景：</p>
<ol>
<li><p>在一些类型运算之中，保证类型运算的完整性</p>
</li>
<li><p>不可能返回值的函数，返回值的类型就可以写成<code>never</code></p>
<pre><code class="tsx">function f():never &#123;
  throw new Error(&#39;Error&#39;);
&#125;

let v1:number = f(); // 不报错
let v2:string = f(); // 不报错
let v3:boolean = f(); // 不报错
</code></pre>
</li>
<li><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。处理完所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p>
<pre><code class="tsx">function fn(x:string|number) &#123;
  if (typeof x === &#39;string&#39;) &#123;
    // ...
  &#125; else if (typeof x === &#39;number&#39;) &#123;
    // ...
  &#125; else &#123;
    x; // never 类型
  &#125;
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p><em>总之，TypeScript 有两个“顶层类型”（<code>any</code>和<code>unknown</code>），和一个“底层类型”<code>never</code>。</em></p>
</blockquote>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a><strong>值类型</strong></h3><p>TypeScript 规定，单个值也可以作为一种类型，称为“值类型”，即该变量只能取值为该值。</p>
<pre><code class="tsx">let x:&#39;hello&#39;;

x = &#39;hello&#39;; // 正确
x = &#39;world&#39;; // 报错
</code></pre>
<p>应用场景：TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码没有注明类型，就会推断该变量是值类型。</p>
<pre><code class="tsx">// x 的类型是 &quot;https&quot;
const x = &#39;https&#39;;

// y 的类型是 string
const y:string = &#39;https&#39;;
</code></pre>
<p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。但如果<code>const</code>赋值为对象，并不会推断为值类型。</p>
<pre><code class="tsx">// x 的类型是 &#123; foo: number &#125;
const x = &#123; foo: 1 &#125;;
</code></pre>
<p>这是因为 JavaScript 里面，<code>const</code>变量赋值为对象时，属性值是可以改变的。</p>
<p>值类型可能会出现一些很奇怪的报错，因为父类型不能赋值给子类型，等号右侧<code>4 + 1</code>的类型为<code>number</code>，等号左侧的类型为数值<code>5</code>，<code>number</code>是<code>5</code>的父类型，所以报错了。但是，反过来是可以的，子类型可以赋值给父类型。</p>
<pre><code class="tsx">let x:5 = 5;
let y:number = 4 + 1;

x = y; // 报错
y = x; // 正确
</code></pre>
<p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言。</p>
<p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a><strong>联合类型</strong></h3><p>联合类型指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p>
<p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p>
<pre><code class="tsx">let x:string|number;

x = 123; // 正确
x = &#39;abc&#39;; // 正确

let setting:true|false;

let gender:&#39;male&#39;|&#39;female&#39;;

let rainbowColor:&#39;赤&#39;|&#39;橙&#39;|&#39;黄&#39;|&#39;绿&#39;|&#39;青&#39;|&#39;蓝&#39;|&#39;紫&#39;;
</code></pre>
<p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p>
<pre><code class="tsx">let name:string|null;

name = &#39;John&#39;;
name = null;
</code></pre>
<p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p>
<pre><code class="tsx">let x:
  | &#39;one&#39;
  | &#39;two&#39;
  | &#39;three&#39;
  | &#39;four&#39;;
</code></pre>
<p>上面示例中，联合类型的第一个成员<code>one</code>前面，加上了竖杠。</p>
<p>如果使用了联合类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p>
<pre><code class="tsx">function printId(
  id:number|string
) &#123;
    console.log(id.toUpperCase()); // 报错
&#125;
</code></pre>
<p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p>
<pre><code class="tsx">function printId(
  id:number|string
) &#123;
  if (typeof id === &#39;string&#39;) &#123;
    console.log(id.toUpperCase());
  &#125; else &#123;
    console.log(id);
  &#125;
&#125;
</code></pre>
<p><strong>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。</strong></p>
<p>实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。下面是“类型缩小”的另一个例子。</p>
<pre><code class="tsx">function getPort(
  scheme: &#39;http&#39;|&#39;https&#39;
) &#123;
  switch (scheme) &#123;
    case &#39;http&#39;:
      return 80;
    case &#39;https&#39;:
      return 443;
  &#125;
&#125;
</code></pre>
<p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a><strong>交叉类型</strong></h3><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p>
<p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p>
<pre><code class="tsx">let x:number&amp;string;
</code></pre>
<p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是<code>never</code>。</p>
<p><strong>主要用途：</strong></p>
<ol>
<li><p>对象合成</p>
<pre><code class="tsx">let obj:
  &#123; foo: string &#125; &amp;
  &#123; bar: string &#125;;

obj = &#123;
  foo: &#39;hello&#39;,
  bar: &#39;world&#39;
&#125;;
</code></pre>
</li>
<li><p>为对象类型添加新属性</p>
<pre><code class="tsx">type A = &#123; foo: number &#125;;

type B = A &amp; &#123; bar: number &#125;;
</code></pre>
</li>
</ol>
<h2 id="数组和元祖"><a href="#数组和元祖" class="headerlink" title="数组和元祖"></a>数组和元祖</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><blockquote>
<p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p>
</blockquote>
<p>数组的类型有<strong>两种写法</strong>：</p>
<ol>
<li><p>在数组成员的类型后面，加上一对方括号</p>
<pre><code class="tsx">let arr:number[] = [1, 2, 3];
let arr:(number|string)[];
</code></pre>
</li>
<li><p>使用 TypeScript 内置的 Array 接口</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2, 3];
</code></pre>
</li>
</ol>
<aside>
💡 **注意：**由于数组成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。


</aside>

<h3 id="数组的类型推断"><a href="#数组的类型推断" class="headerlink" title="数组的类型推断"></a><strong>数组的类型推断</strong></h3><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。</p>
<p><strong>空数组的类型推断：</strong></p>
<p>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是<code>any[]</code>。后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p>
<pre><code class="tsx">const arr = [];
arr // 推断为 any[]

arr.push(123);
arr // 推断类型为 number[]

arr.push(&#39;abc&#39;);
arr // 推断类型为 (string|number)[]
</code></pre>
<p><strong>非空数组的类型推断：</strong></p>
<p>类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p>
<pre><code class="tsx">// 推断类型为 number[]
const arr = [123];

arr.push(&#39;abc&#39;); // 报错
</code></pre>
<h3 id="元祖概念"><a href="#元祖概念" class="headerlink" title="元祖概念"></a>元祖概念</h3><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有，它允许数组的各个成员的类型可以不同。</p>
<p><strong>使用规则：</strong></p>
<ol>
<li><p>由于成员的类型可以不一样，所以元组必须明确声明每个成员的类型。</p>
<pre><code class="tsx">const s:[string, string, boolean]
  = [&#39;a&#39;, &#39;b&#39;, true];
</code></pre>
<p>数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。TypeScript 的区分方法就是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p>
<p>使用元组时，必须明确给出类型声明，不能省略，否则 TypeScript 会把一个值自动推断为数组。</p>
<pre><code class="tsx">// a 的类型被推断为 (number | boolean)[]
let a = [1, true];
</code></pre>
</li>
<li><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>
<pre><code class="tsx">let a:[number, number?] = [1];
</code></pre>
<p>注意：所有可选成员必须在必选成员之后。</p>
</li>
<li><p>由于元组的成员数量是有限的，因此越界的成员会报错。</p>
<pre><code class="tsx">let x:[string, string] = [&#39;a&#39;, &#39;b&#39;];

x[2] = &#39;c&#39;; // 报错
</code></pre>
<p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p>
<pre><code class="tsx">type NamedNums = [
  string,
  ...number[]
];

const a:NamedNums = [&#39;A&#39;, 1, 2];
const b:NamedNums = [&#39;B&#39;, 1, 2, 3];
</code></pre>
<p>如果不确定元组成员的类型和数量，可以写成下面这样。</p>
<pre><code class="tsx">type Tuple = [...any[]];
</code></pre>
</li>
<li><p>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</p>
<pre><code class="tsx">type Color = [
  red: number,
  green: number,
  blue: number
];

const c:Color = [255, 255, 255];
</code></pre>
</li>
</ol>
<h3 id="扩展运算符与成员数量"><a href="#扩展运算符与成员数量" class="headerlink" title="扩展运算符与成员数量"></a><strong>扩展运算符与成员数量</strong></h3><p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量<strong>是不确定</strong>的，这导致如果函数调用时，使用扩展运算符传入函数参数，会发生参数数量与数组长度不匹配的报错。</p>
<pre><code class="tsx">const arr = [1, 2];

function add(x:number, y:number)&#123;
  // ...
&#125;

add(...arr) // 报错
</code></pre>
<p>如果函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p>
<p>解决这个问题的方法：</p>
<ol>
<li><p>把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p>
<pre><code class="tsx">const arr:[number, number] = [1, 2];

function add(x:number, y:number)&#123;
  // ...
&#125;

add(...arr) // 正确
</code></pre>
</li>
<li><p>使用<code>as const</code>断言</p>
<pre><code class="tsx">const arr = [1, 2] as const;
</code></pre>
</li>
</ol>
<h2 id="TypeScript-的函数类型"><a href="#TypeScript-的函数类型" class="headerlink" title="TypeScript 的函数类型"></a><strong>TypeScript 的函数类型</strong></h2><p>函数需要在声明时，给出<strong>参数的类型</strong>和<strong>返回值的类型（可选）</strong></p>
<p>函数的多种写法：</p>
<ol>
<li><p>普通函数</p>
<pre><code class="tsx">function add(a: number, b: number): number &#123;  
    return a + b;  
&#125;
const hello = function (txt:string) &#123;
  console.log(&#39;hello &#39; + txt);
&#125;
</code></pre>
</li>
<li><p>箭头函数</p>
<pre><code class="tsx">const add = (a: number, b: number): number =&gt; &#123;  
    return a + b;  
&#125;;  
  
// 简写形式（当函数体只有一条语句时）  
const add = (a: number, b: number): number =&gt; a + b;
</code></pre>
</li>
<li><p><strong>函数类型别名</strong></p>
<p>使用类型别名可以为函数的参数和返回值类型定义一个名字，然后在其他地方使用这个别名</p>
<pre><code class="tsx">type AddFunction = (a: number, b: number) =&gt; number;  
  
const add: AddFunction = (a, b) =&gt; a + b;
</code></pre>
</li>
<li><p><code>typeof</code>套用另一个函数类型</p>
<pre><code class="tsx">function add(x: number, y: number) &#123;
  return x + y;
&#125;

const myAdd: typeof add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
</li>
<li><p>函数类型的对象写法：<code>&#123;(参数列表): 返回值&#125;</code></p>
<pre><code class="tsx">let add: &#123;
  (x: number, y: number): number;
&#125;;

add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
<p>这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。</p>
<pre><code class="tsx">let foo: &#123;
  (x: number): void;
  version: string;
&#125; = f;
function f(x: number) &#123;
  console.log(x);
&#125;
f.version = &quot;1.0&quot;;
</code></pre>
</li>
<li><p>使用 <code>Interface</code> 来声明函数类型</p>
<pre><code class="tsx">interface myfn &#123;
  (a: number, b: number): number;
&#125;
var add: myfn = (a, b) =&gt; a + b;
</code></pre>
</li>
</ol>
<h3 id="其他常见写法"><a href="#其他常见写法" class="headerlink" title="其他常见写法"></a>其他常见写法</h3><ol>
<li><p><strong>可选参数：</strong>使用<code>?</code>来标记函数的某个参数是可选的</p>
<pre><code class="tsx">function greet(name?: string) &#123;  
    return name ? `Hello, $&#123;name&#125;!` : &#39;Hello, stranger!&#39;;  
&#125;
</code></pre>
<p>函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。</p>
</li>
<li><p><strong>默认参数：</strong>为函数的参数指定默认值</p>
<pre><code class="tsx">function greet(name: string = &#39;stranger&#39;) &#123;  
    return `Hello, $&#123;name&#125;!`;  
&#125;
</code></pre>
</li>
<li><p><strong>剩余参数：</strong>使用<code>...</code>语法来创建一个剩余参数，将剩余的参数收集到一个数组中</p>
<pre><code class="tsx">function sum(...numbers: number[]): number &#123;  
    return numbers.reduce((acc, val) =&gt; acc + val, 0);  
&#125;
</code></pre>
<p>这里的”剩余”指的是除了明确列出的参数之外的所有参数，如果剩下的所有参数类型相同，可以用数组，类型不同可以用元祖，元祖需要声明每一个剩余参数的类型</p>
<pre><code class="tsx">function f(
  ...args: [boolean, string?]
) &#123;&#125;
</code></pre>
<p>rest 参数还可以与变量解构结合使用：</p>
<pre><code class="tsx">function repeat(
  ...[str, times]: [string, number]
):string &#123;
  return str.repeat(times);
&#125;

// 等同于
function repeat(
  str: string,
  times: number
):string &#123;
  return str.repeat(times);
&#125;
</code></pre>
</li>
<li><p><strong>高阶函数：</strong>一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数</p>
<pre><code class="tsx">(someValue: number) =&gt; (multiplier: number) =&gt; someValue * multiplier;
</code></pre>
</li>
</ol>
<h3 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a><strong>参数解构</strong></h3><p>解构赋值是一种JavaScript表达式，它允许你从一个数组或对象中提取数据到不同的变量中。</p>
<p><strong>数组解构：</strong></p>
<p>假设你有一个函数，它期望一个包含两个元素的数组作为参数，并希望直接将这些元素分配给两个变量：</p>
<pre><code class="tsx">function processArray([first, second]: [number, string]) &#123;  
    console.log(first);  // 输出第一个数字  
    console.log(second); // 输出第二个字符串  
&#125;  
  
processArray([1, &quot;two&quot;]);
</code></pre>
<p><strong>对象解构：</strong></p>
<pre><code class="tsx">function processPerson(&#123; name, age &#125;: &#123; name: string, age: number &#125;) &#123;  
    console.log(name);  
    console.log(age);  
&#125;  
  
processPerson(&#123; name: &quot;Alice&quot;, age: 30 &#125;);
</code></pre>
<p><strong>可选和默认值：</strong></p>
<pre><code class="tsx">function processPerson(&#123; name = &quot;Anonymous&quot;, age = 0 &#125;: &#123; name?: string, age?: number &#125;) &#123;  
    console.log(name);  
    console.log(age);  
&#125;  
  
processPerson(&#123; age: 30 &#125;); // 输出 &quot;Anonymous&quot; 和 30
</code></pre>
<p><strong>剩余参数和解构：</strong></p>
<pre><code class="tsx">function processArray(...[first, ...rest]: [number, ...number[]]) &#123;  
    console.log(first);  
    console.log(rest); // rest 是一个数组  
&#125;  
  
processArray(1, 2, 3, 4); // 输出 1 和 [2, 3, 4]
</code></pre>
<p><strong>结合type：</strong></p>
<pre><code class="tsx">type ABC = &#123; a:number; b:number; c:number &#125;;

function sum(&#123; a, b, c &#125;:ABC) &#123;
  console.log(a + b + c);
&#125;
</code></pre>
<h3 id="返回值设置为void和never有什么区别？"><a href="#返回值设置为void和never有什么区别？" class="headerlink" title="返回值设置为void和never有什么区别？"></a><strong>返回值设置为void和never有什么区别？</strong></h3><p><code>void</code> 类型表示没有任何类型。</p>
<p>当你指定一个函数返回 <code>void</code> 类型时，意味着这个函数不返回任何值（或者更准确地说，它返回 <code>undefined</code>）。</p>
<p>在实际编程中，即使你指定函数返回 <code>void</code>，TypeScript仍然允许你隐式地返回 <code>undefined</code>（因为 <code>undefined</code> 是 <code>void</code> 类型的唯一有效值）。</p>
<p>示例：</p>
<pre><code class="tsx">function logMessage(message: string): void &#123;  
    console.log(message);  
    // 隐式返回 undefined  
&#125;  
const result = logMessage(&quot;Hello, world!&quot;); // result 将会是 undefined
</code></pre>
<p><code>never</code> 类型表示的是那些永不存在的值的类型，通常用于描述那些总是抛出错误或永远不返回的函数。</p>
<p><strong>示例1：总是抛出错误的函数</strong></p>
<pre><code class="tsx">function error(message: string): never &#123;  
    throw new Error(message);  
    // 这里不会执行到任何后续的代码，所以返回类型是 never  
&#125;
</code></pre>
<p><strong>示例2：永远不返回的函数（无限循环）</strong></p>
<pre><code class="tsx">function loopForever(): never &#123;  
    while (true) &#123;  
        // 这个循环永远不会结束，所以返回类型是 never  
    &#125;  
&#125;
</code></pre>
<p><strong>示例2：使用</strong> <code>never</code> <strong>类型的类型守卫</strong></p>
<p>使用 <code>never</code> 类型来创建一个类型守卫，该守卫可以确保某个条件总是为 <code>false</code>（这在某些高级类型操作中可能是有用的）。</p>
<pre><code class="tsx">function isNever(x: never): never &#123;  
    throw new Error(&quot;Unexpected object of type &#39;never&#39;.&quot;);  
&#125;  
  
// 这个函数永远不会被调用，因为没有任何值可以是 &#39;never&#39; 类型  
// 但它在这里作为一个示例来说明 `never` 类型的用法
</code></pre>
<p><strong>总结：</strong></p>
<ol>
<li><code>void</code> 表示函数不返回任何有用的值（或返回 <code>undefined</code>）。</li>
<li><code>never</code> 表示函数永不返回（或者总是抛出错误）。</li>
</ol>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。</p>
<p>这意味着，该函数内部有多套逻辑，根据参数类型的不同，分别执行对应的逻辑。这就叫“函数重载”。</p>
<p>TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。</p>
<pre><code class="tsx">function reverse(str:string):string;
function reverse(arr:any[]):any[];
function reverse(
  stringOrArray:string|any[]
):string|any[] &#123;
  if (typeof stringOrArray === &#39;string&#39;)
    return stringOrArray.split(&#39;&#39;).reverse().join(&#39;&#39;);
  else
    return stringOrArray.slice().reverse();
&#125;
</code></pre>
<p>上面示例中，前两行类型声明列举了重载的各种情况。第三行是函数本身的类型声明，它必须与前面已有的重载声明兼容。</p>
<p><strong>使用规则：</strong></p>
<ol>
<li><p>函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。</p>
</li>
<li><p>重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。</p>
<pre><code class="tsx">function f(x:any):number;
function f(x:string): 0|1;
function f(x:any):any &#123;
  // ...
&#125;

const a:0|1 = f(&#39;hi&#39;); // 报错
</code></pre>
</li>
<li><p>对象的方法也可以使用重载。</p>
<pre><code class="tsx">class StringBuilder &#123;
  #data = &#39;&#39;;

  add(num:number): this;
  add(bool:boolean): this;
  add(str:string): this;
  add(value:any): this &#123;
    this.#data += String(value);
    return this;
  &#125;

  toString() &#123;
    return this.#data;
  &#125;
&#125;
</code></pre>
</li>
<li><p>函数重载也可以用来精确描述函数参数与返回值之间的对应关系</p>
<pre><code class="tsx">function createElement(
  tag:&#39;a&#39;
):HTMLAnchorElement;
function createElement(
  tag:&#39;canvas&#39;
):HTMLCanvasElement;
function createElement(
  tag:&#39;table&#39;
):HTMLTableElement;
function createElement(
  tag:string
):HTMLElement &#123;
  // ...
&#125;
</code></pre>
<p>这个示例的函数重载，也可以用对象表示。</p>
<pre><code class="tsx">type CreateElement = &#123;
  (tag:&#39;a&#39;): HTMLAnchorElement;
  (tag:&#39;canvas&#39;): HTMLCanvasElement;
  (tag:&#39;table&#39;): HTMLTableElement;
  (tag:string): HTMLElement;
&#125;
</code></pre>
</li>
<li><p>由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载，除非多个参数之间、或者某个参数与返回值之间，存在对应关系。</p>
</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>JavaScript 语言使用构造函数，生成对象的实例。</p>
<p>构造函数的最大特点，就是必须使用<code>new</code>命令调用。</p>
<pre><code class="tsx">class Animal &#123;
  numLegs:number = 4;
&#125;

type AnimalConstructor = new () =&gt; Animal;

function create(c:AnimalConstructor):Animal &#123;
  return new c();
&#125;

const a = create(Animal);
</code></pre>
<p>上面示例中，类型<code>AnimalConstructor</code>就是一个构造函数，而函数<code>create()</code>需要传入一个构造函数。在 JavaScript 中，类（class）本质上是构造函数，所以<code>Animal</code>这个类可以传入<code>create()</code>。</p>
<p>构造函数还有另一种类型写法，就是采用对象形式。</p>
<pre><code class="tsx">type F = &#123;
  new (s:string): object;
&#125;;
</code></pre>
<p>上面示例中，类型 F 就是一个构造函数。类型写成一个可执行对象的形式，并且在参数列表前面要加上<code>new</code>命令。</p>
<p>某些函数既是构造函数，又可以当作普通函数使用，比如<code>Date()</code>。这时，类型声明可以写成下面这样。</p>
<pre><code class="tsx">type F = &#123;
  new (s:string): object;
  (n?:number): number;
&#125;
</code></pre>
<p>上面示例中，F 既可以当作普通函数执行，也可以当作构造函数使用。</p>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/15/DB/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/JavaScript.png" data-sizes="auto" alt="DOM和BOM" class="lazyload">
                    <h1>DOM和BOM</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>8.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 35 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="Document-Object-Model"><a href="#Document-Object-Model" class="headerlink" title="Document Object Model"></a><strong>Document Object Model</strong></h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/15/DB/Untitled.png" alt="Untitled" class="lazyload"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>DOM</strong>，即文档对象模型。它是一种跨平台的、独立于编程语言的API，它把HTML、XHTML或XML文档当作一个树结构，而每个节点视为一个对象，这些对象可以被编程语言操作，进而改变文档的结构，映射到文档的显示。</p>
<p>简单来说，DOM就是我们为了方便编程语言对HTML等文档进行操作，把HTML文档中的节点全部视为一个个的对象，所有可用于操作和创建网页的属性、方法和事件都被组织到对象中，这些对象依照层级关系形成一棵树，这棵树就命名为DOM树。有了对象，编程就方便多了，只要一层层拿到对象就可以优雅地改变对象的属性进而动态地改变HTML等文档的展示。</p>
<p>例如，DOM 中指定下面代码中的 <code>querySelectorAll</code> 方法必须要返回文档中所有 <code>&lt;p&gt;</code> 元素组成的列表：</p>
<pre><code class="jsx">const paragraphs = document.querySelectorAll(&quot;p&quot;);
// paragraphs[0] 是第一个 &lt;p&gt; 元素
// paragraphs[1] 是第二个 &lt;p&gt; 元素，依此类推
alert(paragraphs[0].nodeName);
</code></pre>
<p><em><strong>DOM 不是一种编程语言，也不是 JavaScript 语言的一部分，而是用于建立网站的 Web API。DOM 被设计成与特定编程语言相独立，使文档的结构化表述可以通过单一，一致的 API 获得。</strong></em></p>
<h3 id="网页加载过程"><a href="#网页加载过程" class="headerlink" title="网页加载过程"></a>网页加载过程</h3><ol>
<li><strong>HTML下载到本地内存</strong>：当浏览器请求一个HTML页面时，会从服务器下载HTML文件并将其存储在本地内存中。这个过程是通过HTTP请求完成的，并且通常会遵循TCP&#x2F;IP协议</li>
<li><strong>解析成DOM树</strong>：浏览器会解析HTML文档，将HTML标签和属性转换为DOM树</li>
<li><strong>展示页面到屏幕</strong>：在构建DOM树的同时或之后，浏览器还会开始解析CSS并构建<code>CSSOM</code>（CSS对象模型）树。然后，它会将DOM树和CSSOM树合并成一个渲染树（<code>render tree</code>），这个渲染树包含了页面上需要显示的内容以及这些内容如何显示（例如颜色、字体大小等）。最后，浏览器会根据渲染树在屏幕上绘制页面</li>
<li><strong>DOM API 动态修改</strong>：DOM API允许JavaScript等网络编程语言动态地访问和更新HTML文档的内容、结构和样式。例如，你可以使用JavaScript来修改DOM树中的元素、添加或删除元素、更改元素的属性或样式等<ul>
<li><strong>在页面加载过程中</strong>：当浏览器接收到 HTML 文档并开始解析时，它会同时或随后构建一个 DOM 树。一旦 DOM 树构建完成，浏览器就可以开始渲染页面了，但此时页面可能还没有完全加载完成，比如可能还有 CSS 和 JavaScript 文件需要加载和执行。此时，JavaScript 可以使用 DOM API 来修改已经解析并添加到 DOM 树中的元素</li>
<li><strong>在页面加载完成后</strong>：一旦页面完全加载并渲染完成（例如，所有图片都已加载），JavaScript 可以使用 DOM API 来添加新元素、删除现有元素或执行其他操作。这通常通过监听 <code>DOMContentLoaded</code> 或 <code>load</code> 事件来实现，这些事件会在页面加载的不同阶段触发</li>
</ul>
</li>
<li><strong>网页加载优化</strong>：为了提高网页的加载性能，开发者可以采取一系列优化措施，如压缩HTML、CSS和JavaScript文件、使用CDN（内容分发网络）来加速资源的加载、通过异步加载和延迟加载来减少阻塞等</li>
</ol>
<h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><p>当浏览器载入 HTML 文档，浏览器会解析它并创建一个DOM树。在DOM树中，HTML文档中的每个元素都被表示为<strong>一个节点，</strong>根节点为 <strong><code>Document</code> 对象，</strong>使我们可以从脚本中对 HTML 页面中的所有元素进行访问。。这些节点具有属性和方法，允许你通过编程的方式与它们进行交互。</p>
<p>在 HTML DOM (Document Object Model) 中 ，每一个元素都是<strong>节点</strong>:</p>
<ul>
<li>文档是一个<strong>文档节点</strong>。</li>
<li>所有的HTML元素都是<strong>元素节点</strong>。</li>
<li>所有 HTML 属性都是<strong>属性节点</strong>。</li>
<li>文本插入到 HTML 元素是<strong>文本节点</strong>。</li>
<li>注释是<strong>注释节点</strong>。</li>
</ul>
<blockquote>
<p><code>Document</code> 对象是 <code>Window</code> 对象的一部分，可通过 <code>window.document</code>属性对其进行访问。</p>
</blockquote>
<p><strong>Document 对象属性和方法：</strong></p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<p><strong>常用DOM API：</strong></p>
<p><strong>（1）创建DOM对象</strong></p>
<pre><code class="jsx">var el2 = document.createElement(&#39;input&#39;);
var node = document.createTextNode(&#39;hello world!&#39;);
</code></pre>
<p><strong>（2）查找DOM对象</strong></p>
<pre><code class="jsx">*// 返回当前文档中第一个类名为 &quot;myclass&quot; 的元素*
var el = document.querySelector(&quot;.myclass&quot;);

*// 返回一个文档中所有的class为&quot;note&quot;或者 &quot;alert&quot;的div元素*
var els = document.querySelectorAll(&quot;div.note, div.alert&quot;);

*// 获取元素*
var el = document.getElementById(&#39;xxx&#39;);
var els = document.getElementsByClassName(&#39;highlight&#39;);
var els = document.getElementsByTagName(&#39;td&#39;);

// 获取父元素、父节点
var parent = ele.parentElement;
var parent = ele.parentNode;

// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断
var nodes = ele.children;    

// 查询子元素
var els = ele.getElementsByTagName(&#39;td&#39;);
var els = ele.getElementsByClassName(&#39;highlight&#39;);

// 当前元素的第一个/最后一个子元素节点
var el = ele.firstElementChild;
var el = ele.lastElementChild;

// 下一个/上一个兄弟元素节点
var el = ele.nextElementSibling;
var el = ele.previousElementSibling;
</code></pre>
<p><strong>（3）更改DOM对象</strong></p>
<pre><code class="jsx">*// 添加、删除子元素*
ele.appendChild(el);
ele.removeChild(el);

*// 替换子元素*
ele.replaceChild(el1, el2);

*// 插入子元素*
parentElement.insertBefore(newElement, referenceElement);
</code></pre>
<p><strong>（4）操作DOM对象的属性</strong></p>
<pre><code class="jsx">*// 获取一个&#123;name, value&#125;的数组*
var attrs = el.attributes;

*// 获取、设置属性*
var c = el.getAttribute(&#39;class&#39;);
el.setAttribute(&#39;class&#39;, &#39;highlight&#39;);

*// 判断、移除属性*
el.hasAttribute(&#39;class&#39;);
el.removeAttribute(&#39;class&#39;);

*// 是否有属性设置*
el.hasAttributes();
</code></pre>
<h3 id="元素对象"><a href="#元素对象" class="headerlink" title="元素对象"></a>元素对象</h3><p>以下是HTML中常见的元素节点类型及其分类列举：</p>
<ol>
<li><p><strong>文档结构元素</strong>：</p>
<ul>
<li><code>&lt;html&gt;</code>: 根元素，包含了整个HTML文档。</li>
<li><code>&lt;head&gt;</code>: 包含了文档的元（meta）数据，如<code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>等。</li>
<li><code>&lt;body&gt;</code>: 包含了所有可见的页面内容，如文本、图片、音频、视频等。</li>
</ul>
</li>
<li><p><strong>标题元素</strong>：</p>
<ul>
<li><code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code>: 定义标题或子标题，<code>&lt;h1&gt;</code>表示最高级别的标题。</li>
</ul>
</li>
<li><p><strong>段落元素</strong>：</p>
<ul>
<li><code>&lt;p&gt;</code>: 定义段落。</li>
</ul>
</li>
<li><p><strong>列表元素</strong>：</p>
<ul>
<li><code>&lt;ul&gt;</code>: 无序列表（unordered list）。</li>
<li><code>&lt;ol&gt;</code>: 有序列表（ordered list）。</li>
<li><code>&lt;li&gt;</code>: 列表项（list item）。</li>
</ul>
</li>
<li><p><strong>链接元素</strong>：</p>
<ul>
<li><p><code>&lt;a&gt;</code>: 定义超链接，可以链接到其他网页或同一网页的不同部分</p>
<ul>
<li><code>href</code>：指定链接的目标地址</li>
<li><code>target</code>：指定在何处打开链接的文档</li>
<li><code>rel</code>：定义当前文档与被链接文档之间的关系</li>
</ul>
<pre><code class="jsx">&lt;a href=&quot;https://example.com&quot; 
target=&quot;_blank&quot; 
rel=&quot;noopener noreferrer&quot;&gt;链接文本&lt;/a&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>图像元素</strong>：</p>
<ul>
<li><p><code>&lt;img&gt;</code>: 定义图像，通常与<code>src</code>、<code>alt</code>等属性一起使用</p>
<ul>
<li><code>src</code>：指定图像的来源</li>
<li><code>alt</code>：为图像提供替代文本，以便在图像无法显示时显示</li>
<li><code>width</code> 和 <code>height</code>：指定图像的宽度和高度</li>
</ul>
<pre><code class="jsx">&lt;img src=&quot;image.jpg&quot; alt=&quot;示例图片&quot; width=&quot;500&quot; height=&quot;600&quot;&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>表格元素</strong>：</p>
<ul>
<li><code>&lt;table&gt;</code>: 定义表格。</li>
<li><code>&lt;tr&gt;</code>: 定义表格行。</li>
<li><code>&lt;th&gt;</code>: 定义表格头部单元格。</li>
<li><code>&lt;td&gt;</code>: 定义表格数据单元格。</li>
</ul>
</li>
<li><p><strong>表单元素</strong>：</p>
<ul>
<li><code>&lt;form&gt;</code>: 定义HTML表单，用于用户输入。</li>
<li><code>&lt;input&gt;</code>: 定义输入字段，如文本框、密码框、单选框、复选框等<ul>
<li><code>type</code>、<code>name</code>、<code>value</code></li>
</ul>
</li>
<li><code>&lt;textarea&gt;</code>: 定义多行文本输入字段<ul>
<li><code>rows</code>、<code>cols</code></li>
</ul>
</li>
<li><code>&lt;button&gt;</code>: 定义点击按钮。</li>
<li><code>&lt;select&gt;</code>: 定义下拉选择列表<ul>
<li><code>name</code>、<code>value</code></li>
</ul>
</li>
<li><code>&lt;option&gt;</code>: 定义下拉选择列表中的选项<ul>
<li><code>name</code>、<code>value</code></li>
</ul>
</li>
</ul>
<pre><code class="jsx">&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;&gt;  
&lt;textarea rows=&quot;4&quot; cols=&quot;50&quot;&gt;默认文本&lt;/textarea&gt;  
&lt;select name=&quot;color&quot;&gt;  
  &lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;  
  &lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;  
&lt;/select&gt;
</code></pre>
</li>
<li><p><strong>分区和布局元素</strong>：</p>
<ul>
<li><code>&lt;div&gt;</code>: 定义一个区块或容器，通常与CSS一起使用来布局页面。</li>
<li><code>&lt;span&gt;</code>: 定义内联元素，通常用于对文本的一部分应用样式。</li>
<li><code>&lt;section&gt;</code>: 定义文档中的独立部分或章节。</li>
<li><code>&lt;article&gt;</code>: 定义独立的内容，如博客文章、论坛帖子等。</li>
<li><code>&lt;nav&gt;</code>: 定义导航链接的容器。</li>
<li><code>&lt;header&gt;</code>: 定义文档的页眉或区域页眉。</li>
<li><code>&lt;footer&gt;</code>: 定义文档的页脚或区域页脚。</li>
</ul>
</li>
<li><p><strong>媒体元素</strong>：</p>
<ul>
<li><code>&lt;audio&gt;</code>: 定义音频内容。</li>
<li><code>&lt;video&gt;</code>: 定义视频内容。</li>
</ul>
</li>
<li><p><strong>其他常见元素</strong>：</p>
<ul>
<li><code>&lt;br&gt;</code>: 插入一个简单的换行符。</li>
<li><code>&lt;hr&gt;</code>: 创建水平线。</li>
<li><code>&lt;meta&gt;</code>: 提供关于HTML文档的元信息。</li>
<li><code>&lt;link&gt;</code>: 定义文档与外部资源之间的关系。</li>
<li><code>&lt;style&gt;</code>: 定义内部样式信息。</li>
<li><code>&lt;script&gt;</code>: 定义客户端脚本，如JavaScript代码。</li>
</ul>
</li>
</ol>
<p>以下属性和方法可适用于所有 HTML 元素：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<blockquote>
<p><em>如果你只需要在特定的元素上监听事件，那么使用 <code>element.addEventListener()</code> 通常是更好的选择，因为它更具体，并且可以减少不必要的计算。然而，如果你需要在整个文档中监听某种类型的事件（例如，点击任何元素或键盘输入），那么使用 <code>document.addEventListener()</code> 可能是更合适的选择。</em></p>
</blockquote>
<h3 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h3><p>所有主流浏览器都支持 Attr 对象，以下是一些常见的属性对象的属性和方法：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>简单来讲，事件就是一个动作，而 HTML 为这些动作指定了特定的对象，和 DOM 对象一样，事件不属于任何一门语言，但是可以作为元素（DOM对象）的属性嵌入元素中，也就是指定该元素为触发对象，当在该元素中触发了指定的事件时，就可以执行该事件绑定在该元素上的JavaScript代码。</p>
<p><strong>DOM中的事件是如何触发的？</strong></p>
<ol>
<li><strong>事件源</strong>：事件的触发首先需要一个事件源，也就是引发事件的HTML元素。例如，当用户点击一个按钮时，这个按钮就是事件源。</li>
<li><strong>事件类型</strong>：每个事件都有一个类型，如“click”、“keydown”等。当事件源上发生与事件类型匹配的动作时，事件就会被触发。</li>
<li><strong>事件监听器</strong>：为了处理事件，需要在事件源上注册一个或多个事件监听器（也称为事件处理器）。事件监听器是一个函数，当事件被触发时，这个函数会被调用。在JavaScript中，通常使用<code>addEventListener()</code>方法为元素添加事件监听器。</li>
<li><strong>事件流</strong>：DOM事件流描述了事件从发生到被处理的过程。这个过程包括三个阶段：捕获阶段、目标阶段和冒泡阶段。<ul>
<li><strong>捕获阶段</strong>：从document对象开始，沿着DOM树向下传播，直到到达事件源。在捕获阶段，事件监听器可以被注册在DOM树的任何节点上，但默认情况下，事件监听器不会在捕获阶段被触发（除非在注册时特别指定）。</li>
<li><strong>目标阶段</strong>：当事件到达事件源时，会触发注册在该元素上的事件监听器。</li>
<li><strong>冒泡阶段</strong>：事件从事件源开始，沿着DOM树向上传播，直到回到document对象。在冒泡阶段，所有经过的节点（包括事件源本身）上注册的事件监听器都会被触发。<em>举个例子，两个元素A和B绑定了不同的点击事件，并且B元素在A元素的内部，那么在点击了B时，B事件会先发生，然后A事件发生。</em></li>
</ul>
</li>
<li><strong>事件处理</strong>：当事件监听器被触发时，会执行相应的函数。这个函数可以执行任何需要的操作，如修改页面内容、发送网络请求等。</li>
</ol>
<aside>
💡 *1. 不同浏览器对DOM事件的支持可能有所不同。例如，一些较旧的浏览器可能不支持某些事件类型或事件流特性。
2. DOM 0级事件（直接在HTML元素上添加事件监听器，如`element.onclick = function() {...};`）和DOM 2级事件（使用`addEventListener()`方法添加事件监听器）在事件处理机制上也有所不同。DOM 0级事件只能在事件的目标阶段处理事件，而DOM 2级事件则可以在捕获阶段、目标阶段和冒泡阶段处理事件。*


</aside>

<p>以下是一些常见的<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/dom-obj-event.html">DOM事件</a>：</p>
<ol>
<li><strong>鼠标事件</strong>：<ul>
<li><code>click</code>：当用户在元素上单击鼠标按钮时触发。</li>
<li><code>dblclick</code>：当用户在元素上双击鼠标按钮时触发。</li>
<li><code>mousedown</code>：当用户在元素上按下鼠标按钮时触发。</li>
<li><code>mouseup</code>：当用户在元素上释放鼠标按钮时触发。</li>
<li><code>mousemove</code>：当鼠标指针在元素内部移动时触发。</li>
<li><code>mouseover</code>：当鼠标指针从元素外部移动到元素内部时触发。</li>
<li><code>mouseout</code>：当鼠标指针从元素内部移动到元素外部时触发。</li>
<li><code>contextmenu</code>：当用户在元素上右键点击时触发（通常用于显示上下文菜单）。</li>
</ul>
</li>
<li><strong>键盘事件</strong>：<ul>
<li><code>keydown</code>：当用户在键盘上按下某个键时触发。</li>
<li><code>keyup</code>：当用户在键盘上释放某个键时触发。</li>
<li><code>keypress</code>：当用户在键盘上按下并释放一个键时触发（通常用于处理文本输入）。</li>
</ul>
</li>
<li><strong>表单事件</strong>：<ul>
<li><code>submit</code>：当表单提交时触发（常用于验证表单数据）。</li>
<li><code>reset</code>：当表单重置时触发。</li>
<li><code>focus</code>：当元素获得焦点时触发（例如，用户点击输入框）。</li>
<li><code>blur</code>：当元素失去焦点时触发（例如，用户离开输入框）。</li>
<li><code>change</code>：当元素的值发生变化且失去焦点时触发（常用于输入框和下拉列表）。</li>
</ul>
</li>
<li><strong>文档&#x2F;窗口事件</strong>：<ul>
<li><code>load</code>：当页面或图片加载完成时触发。</li>
<li><code>unload</code>：当用户离开页面时触发（例如，关闭页面或跳转到其他页面）。</li>
<li><code>scroll</code>：当用户滚动页面时触发。</li>
<li><code>resize</code>：当浏览器窗口大小发生变化时触发。</li>
</ul>
</li>
<li><strong>触摸事件</strong>（主要针对移动设备）：<ul>
<li><code>touchstart</code>：当用户触摸屏幕时触发。</li>
<li><code>touchmove</code>：当用户在屏幕上移动手指时触发。</li>
<li><code>touchend</code>：当用户从屏幕上移开手指时触发。</li>
<li><code>touchcancel</code>：当系统取消触摸事件时触发（例如，电话呼入）。</li>
</ul>
</li>
<li><strong>拖放事件</strong>：<ul>
<li><code>dragstart</code>：当用户开始拖动元素时触发。</li>
<li><code>drag</code>：当用户在拖动元素时触发。</li>
<li><code>dragend</code>：当用户结束拖动元素时触发。</li>
<li><code>dragenter</code>：当拖动的元素进入目标元素时触发。</li>
<li><code>dragover</code>：当拖动的元素在目标元素上移动时触发。</li>
<li><code>dragleave</code>：当拖动的元素离开目标元素时触发。</li>
<li><code>drop</code>：当用户在目标元素上释放拖动的元素时触发。</li>
</ul>
</li>
<li><strong>其他事件</strong>：<ul>
<li><code>error</code>：当发生错误时触发（例如，图片加载失败）。</li>
<li><code>abort</code>：当加载被中止时触发（例如，用户停止加载页面）。</li>
<li><code>beforeunload</code>：当页面即将卸载（关闭、刷新或跳转到其他页面）时触发。</li>
</ul>
</li>
</ol>
<h2 id="Browser-Object-Model"><a href="#Browser-Object-Model" class="headerlink" title="Browser Object Model"></a><strong>Browser Object Model</strong></h2><p>BOM是浏览器对象模型，DOM 是将HTML文档中的各个元素封装成一个对象（Document），而 <strong>BOM</strong> 则是将一个浏览器的各个组成部分封装成对象（Browser）供调用使用。</p>
<p>BOM的核心对象是<code>window</code>，它表示浏览器的一个实例（通常就是浏览器窗口或标签页）。由于<code>window</code>是BOM的顶层对象，其他BOM对象都是它的子对象或者方法。</p>
<h3 id="BOM的组成部分"><a href="#BOM的组成部分" class="headerlink" title="BOM的组成部分"></a>BOM的组成部分</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/15/DB/Untitled1.png" alt="Untitled" class="lazyload"></p>
<p>图中看出，BOM 对象大致包含五个部分：</p>
<ul>
<li>Window 对象：浏览器窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：浏览器所处客户端的显示器屏幕对象</li>
<li>History：浏览器当前窗口的访问历史记录对象</li>
<li>Location：浏览器当前窗口的地址栏对象</li>
</ul>
<h3 id="窗口对象window"><a href="#窗口对象window" class="headerlink" title="窗口对象window"></a><strong>窗口对象window</strong></h3><p>BOM 的核心是 <code>window</code> 窗口对象对象，表示浏览器的实例。<code>window</code> 对象在浏览器中有两重身份，一个是全局对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有对象、变量和函数都以 <code>window</code> 作为其 Global 对象，都可以访问其上定义全局方法。</p>
<p>window对象不需要创建可以直接使用，<code>window.方法名();</code>，甚至可以把window直接省略<code>方法名();</code></p>
<p>以下是一些常见的<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/obj-window.html">Window对象方法</a>：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<p>以下是一些常用的<code>window</code>属性：</p>
<table>
<thead>
<tr>
<th align="left">属性 &#x2F; 方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>document.activeElement</code></td>
<td align="left">返回当前获取焦点元素</td>
</tr>
<tr>
<td align="left"><code>document.addEventListener()</code></td>
<td align="left">向文档添加句柄</td>
</tr>
<tr>
<td align="left"><code>document.baseURI</code></td>
<td align="left">返回文档的绝对基础 URI</td>
</tr>
<tr>
<td align="left"><code>document.body</code></td>
<td align="left">返回文档的<code>body</code>元素</td>
</tr>
<tr>
<td align="left"><code>document.open()</code></td>
<td align="left">打开一个流，以收集来自任何 <code>document.write()</code> 或 <code>document.writeln() </code>方法的输出。</td>
</tr>
<tr>
<td align="left"><code>document.close()</code></td>
<td align="left">关闭用 <code>document.open() </code>方法打开的输出流，并显示选定的数据。</td>
</tr>
<tr>
<td align="left"><code>document.cookie</code></td>
<td align="left">设置或返回与当前文档有关的所有 <code>cookie</code>。</td>
</tr>
<tr>
<td align="left"><code>document.createAttribute()</code></td>
<td align="left">创建一个属性节点</td>
</tr>
<tr>
<td align="left"><code>document.createElement()</code></td>
<td align="left">创建元素节点。</td>
</tr>
<tr>
<td align="left"><code>document.createTextNode()</code></td>
<td align="left">创建文本节点。</td>
</tr>
<tr>
<td align="left"><code>document.doctype</code></td>
<td align="left">返回与文档相关的文档类型声明 (DTD)。</td>
</tr>
<tr>
<td align="left"><code>document.documentElement</code></td>
<td align="left">返回文档的根节点</td>
</tr>
<tr>
<td align="left"><code>document.documentMode</code></td>
<td align="left">返回用于通过浏览器渲染文档的模式</td>
</tr>
<tr>
<td align="left"><code>document.domain</code></td>
<td align="left">返回当前文档的域名。</td>
</tr>
<tr>
<td align="left"><code>document.embeds</code></td>
<td align="left">返回文档中所有嵌入的内容（<code>embed</code>）集合</td>
</tr>
<tr>
<td align="left"><code>document.forms</code></td>
<td align="left">返回对文档中所有 <code>Form</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByClassName()</code></td>
<td align="left">返回文档中所有指定类名的元素集合，作为 <code>NodeList</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>document.getElementById()</code></td>
<td align="left">返回对拥有指定 <code>id</code> 的第一个对象的引用。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByName()</code></td>
<td align="left">返回带有指定名称的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.getElementsByTagName()</code></td>
<td align="left">返回带有指定标签名的对象集合。</td>
</tr>
<tr>
<td align="left"><code>document.images</code></td>
<td align="left">返回对文档中所有 <code>Image</code> 对象引用。</td>
</tr>
<tr>
<td align="left"><code>document.importNode()</code></td>
<td align="left">把一个节点从另一个文档复制到该文档以便应用。</td>
</tr>
<tr>
<td align="left"><code>document.lastModified</code></td>
<td align="left">返回文档被最后修改的日期和时间。</td>
</tr>
<tr>
<td align="left"><code>document.normalize()</code></td>
<td align="left">删除空文本节点，并连接相邻节点</td>
</tr>
<tr>
<td align="left"><code>document.querySelector()</code></td>
<td align="left">返回文档中匹配指定的CSS选择器的第一元素</td>
</tr>
<tr>
<td align="left"><code>document.querySelectorAll()</code></td>
<td align="left"><code>document.querySelectorAll() </code>是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表</td>
</tr>
<tr>
<td align="left"><code>document.readyState</code></td>
<td align="left">返回文档状态 (载入中……)</td>
</tr>
<tr>
<td align="left"><code>document.removeEventListener()</code></td>
<td align="left">移除文档中的事件句柄(由 <code>addEventListener() </code>方法添加)</td>
</tr>
<tr>
<td align="left"><code>document.renameNode()</code></td>
<td align="left">重命名元素或者属性节点。</td>
</tr>
<tr>
<td align="left"><code>document.scripts</code></td>
<td align="left">返回页面中所有脚本的集合。</td>
</tr>
<tr>
<td align="left"><code>document.strictErrorChecking</code></td>
<td align="left">设置或返回是否强制进行错误检查。</td>
</tr>
<tr>
<td align="left"><code>document.title</code></td>
<td align="left">返回当前文档的标题。</td>
</tr>
<tr>
<td align="left"><code>document.URL</code></td>
<td align="left">返回文档完整的URL</td>
</tr>
<tr>
<td align="left"><code>document.write()</code></td>
<td align="left">向文档写 HTML 表达式 或 JavaScript 代码。</td>
</tr>
<tr>
<td align="left"><code>document.writeln()</code></td>
<td align="left">等同于 <code>write()</code> 方法，不同的是在每个表达式之后写一个换行符。</td>
</tr>
</tbody></table>
<p>一些使用示例：</p>
<pre><code class="jsx">var userInput = window.confirm(&quot;你确定要继续吗?&quot;);  
if (userInput) &#123;  
  console.log(&quot;用户点击确定&quot;);  
&#125; else &#123;  
  console.log(&quot;用户点击取消或关闭&quot;);  
&#125;

var userName = window.prompt(&quot;请输入你的姓名:&quot;, &quot;默认姓名&quot;);  
if (userName != null) &#123;  
  console.log(&quot;你好，&quot; + userName + &quot;!&quot;);  
&#125; else &#123;  
  console.log(&quot;用户未输入姓名或点击了取消&quot;);  
&#125;

&lt;button id=&quot;openWindow&quot;&gt;打开窗口&lt;/button&gt;
&lt;button id=&quot;closeWindow&quot;&gt;关闭窗口&lt;/button&gt;
&lt;script&gt;
    var openWindow = document.getElementById(&quot;openWindow&quot;);
    var newWindow; //全局变量，对新创建的窗口进行操作
    openWindow.onclick = function()&#123;
        newWindow = open(&quot;https://www.baidu.com&quot;); //打开指定url的窗口
    &#125;
        
    var closeWindow = document.getElementById(&quot;closeWindow&quot;);
    closeWindow.onclick = function()&#123;
        newWindow.close(); //关闭调用它的窗口
    &#125;
&lt;/script&gt;

var myTimer = setTimeout(function() &#123;  
  console.log(&quot;Hello, World!&quot;);  
&#125;, 2000); // 2秒后执行  
  
// 取消定时器  
clearTimeout(myTimer);
</code></pre>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a><code>history</code></h3><p>该对象保存着用户上网的历史记录。出于安全方面的考虑，开发人员无法得知用户浏览过的URL，不过借由用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退前进</p>
<ul>
<li><code>length</code>：返回历史列表中的网址数</li>
<li><code>back()</code>：加载 <code>history</code> 列表中的前一个 URL</li>
<li><code>forward()</code>：加载 <code>history</code> 列表中的下一个 URL</li>
<li><code>go()</code>：加载 <code>history</code> 列表中的某个具体页面，负数表示向后跳转，正数表示向前跳转</li>
</ul>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a><code>location</code></h3><p>浏览器当前窗口的<strong>地址栏对象，</strong>通过<code>window.location</code>对象，可以解析URL、重定向浏览器到新的页面、重新加载当前页面等</p>
<ul>
<li><code>window.location.href</code>：获取或设置当前页面的完整URL。</li>
<li><code>window.location.protocol</code>：获取URL的协议部分（如 <code>&quot;http:&quot;</code> 或 <code>&quot;https:&quot;</code>）。</li>
<li><code>window.location.host</code>：获取URL的主机名和端口号（如果有）。</li>
<li><code>window.location.hostname</code>：获取URL的主机名。</li>
<li><code>window.location.pathname</code>：获取URL的路径名。</li>
<li><code>window.location.search</code>：获取URL的查询字符串部分（包括问号）。</li>
<li><code>window.location.hash</code>：获取URL的哈希（锚点）部分。</li>
</ul>
<p><strong>location对象中的方法：</strong></p>
<pre><code class="jsx">&lt;button&gt;跳转页面&lt;/button&gt;
&lt;button&gt;替换页面&lt;/button&gt;
&lt;button&gt;刷新页面&lt;/button&gt;
&lt;script&gt;
  var btn = document.getElementsByTagName(&#39;button&#39;);//返回值为一个类数组
  btn[0].onclick = function () &#123;
    location.assign(&#39;./test2.html&#39;)
  &#125;
  btn[1].onclick = function () &#123;
    location.replace(&#39;./test2.html&#39;)
  &#125;
  btn[2].onclick = function () &#123;
    location.reload()
  &#125;
&lt;/script&gt;
</code></pre>
<ul>
<li><code>assign()</code>：传递一个url参数，打开新url，替换当前页面，并在浏览记录中生成一条记录，页面替换后可以返回上一个页面</li>
<li><code>replace()</code>：参数为一个url，打开新url，替换当前页面，不会在历史记录中生成新记录，替换页面后无法再次返回之前页面</li>
<li><code>reload()</code>：重新加载当前显示的页面，参数可以为<code>boolean</code>类型，默认为<code>false</code>，表示以最有效方式重新加载，可能从缓存中直接加载。如果参数为<code>true</code>，强制从服务器中重新加载</li>
</ul>
<h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a><code>navigator</code></h3><p>浏览器对象，提供了与浏览器相关的信息和操作接口。在前端开发中，通常使用<code>Navigator</code>对象来获取用户浏览器的相关信息，例如浏览器的名称、版本、语言设置、设备类型、操作系统等。这些信息对于实现浏览器兼容性、设备适配等功能非常重要。<code>Navigator</code>对象还包含了一些方法和属性，用于获取当前设备的地理位置信息、访问设备的媒体设备等</p>
<ul>
<li><code>navigator.appName</code>：浏览器名称；注意：<code>“Netscape”</code>是 IE11、Chrome、Firefox 以及 Safari 的应用程序名称的统称；</li>
<li><code>navigator.appVersion</code>：浏览器版本；</li>
<li><code>navigator.appCodeName</code>：返回浏览器的应用程序代码名称</li>
<li><code>navigator.language</code>：浏览器设置的语言；</li>
<li><code>navigator.platform</code>：操作系统类型；</li>
<li><code>navigator.userAgent</code>：返回用户代理头的字符串表示（通常是浏览器类型、版本和操作系统信息）；</li>
<li><code>navigator.cookieEnabled</code>：返回一个布尔值，表示是否启用<code>cookie</code>；</li>
<li><code>navigator.product</code>：返回浏览器引擎的产品名称</li>
</ul>
<h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a><code>screen</code></h3><ul>
<li><code>screen.width</code>和<code>screen.height</code>：屏幕总宽度&#x2F;高度</li>
<li><code>screen.availWidth</code>和<code>screen.availHeight</code>：可用宽度&#x2F;高度，（即减去系统界面元素后的宽度和高度）</li>
<li><code>screen.colorDepth</code>：颜色深度</li>
<li><code>screen.pixelDepth</code>：颜色分辨率</li>
</ul>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/15/gongju/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/nodejs.png" data-sizes="auto" alt="Node常用工具模块" class="lazyload">
                    <h1>Node常用工具模块</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>单纯针对路径的操作，对文件没有关联，因此即使文件不存在也没关系</p>
<ul>
<li><code>path.basename(dir)</code> ：返回路径的最后一部分</li>
<li><code>path.dirname(dir)</code> ：返回路径除了最后一部分的部分</li>
<li><code>path.format(dir)</code> ：将对象解析为路径并返回</li>
<li><code>path.parse(dir)</code> ：将路径解析为对象并返回</li>
<li><code>path.resolve(dir)</code> ：将一个路径解析为绝对路径并返回</li>
<li><code>path.join(dir)</code>或<code>path.join([...paths])</code> ：将路径拼接并返回</li>
<li><code>path.extname(path)</code>：返回路径的扩展名</li>
</ul>
<p>两个全局变量：</p>
<ul>
<li><code>__dirname</code> ：当前文件的绝对路径</li>
<li><code>__filename</code> ：当前文件的绝对路径加文件名</li>
</ul>
<pre><code class="jsx">let path = require(&#39;path&#39;)
let demo = &#39;./src/a/b/c.js&#39;
console.log(path.basename(demo))
// 输出c.js
console.log(path.dirname(demo))
// 输出./src/a/b/c.js
console.log(path.parse(demo))
//输出&#123; root: &#39;&#39;, dir: &#39;./src/a/b&#39;, base: &#39;c.js&#39;, ext: &#39;.js&#39;, name: &#39;c&#39; &#125;
console.log(path.format(&#123; root: &#39;&#39;, dir: &#39;./src/a/b&#39;, base: &#39;c.js&#39;, ext: &#39;.js&#39;, name: &#39;c&#39; &#125;))
console.log(__dirname)
// 输出/Users/v/nodeStudy
console.log(__filename)
// 输出/Users/v/nodeStudy/code.js
console.log(path.resolve(__dirname,&#39;./do&#39;))
// 输出/Users/v/nodeStudy/do
console.log(path.resolve(&#39;../&#39;,&#39;./u&#39;))
// 输出/Users/v/u
console.log(path.join(&#39;./love&#39;,&#39;/me&#39;))
// 输出love/me
</code></pre>
<h2 id="process全局对象"><a href="#process全局对象" class="headerlink" title="process全局对象"></a>process全局对象</h2><p>在Node.js中，<code>process</code>是一个全局对象，提供了与当前Node.js进程互动的信息和功能</p>
<p>属性：</p>
<ul>
<li><p><code>env</code>：用户环境信息，比如webpack打包的时候，都是要读环境信息的</p>
<pre><code class="jsx">&#123;
  WEBIDE_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/webide.vmoptions&#39;,
  PHPSTORM_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/phpstorm.vmoptions&#39;,
  GATEWAY_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/gateway.vmoptions&#39;,
  STUDIO_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/studio.vmoptions&#39;,
  MallocNanoZone: &#39;0&#39;,
  USER: &#39;v&#39;,
  __CFBundleIdentifier: &#39;com.microsoft.VSCode&#39;,
  COMMAND_MODE: &#39;unix2003&#39;,
  DATAGRIP_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/datagrip.vmoptions&#39;,
  PATH: &#39;/Users/v/ML/Anaconda/anaconda3/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Library/TeX/texbin:/Applications/VMware Fusion.app/Contents/Public:/Users/v/ML/Anaconda/anaconda3/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/apache-maven-3.8.6/bin:/usr/local/mysql/bin:/Users/v/Library/Android/idk/emulator:/Users/v/Library/Android/idk/tools:/Users/v/Library/Android/idk/tools/bin:/Users/v/Library/Android/idk/platform-tools:/usr/local/apache-maven-3.8.6/bin:/usr/local/mysql/bin:/Users/v/Library/Android/idk/emulator:/Users/v/Library/Android/idk/tools:/Users/v/Library/Android/idk/tools/bin:/Users/v/Library/Android/idk/platform-tools&#39;,
  RUBYMINE_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/rubymine.vmoptions&#39;,
  DATASPELL_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/dataspell.vmoptions&#39;,
  LOGNAME: &#39;v&#39;,
  SSH_AUTH_SOCK: &#39;/private/tmp/com.apple.launchd.fvq04dfldB/Listeners&#39;,
  RIDER_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/rider.vmoptions&#39;,
  JETBRAINSCLIENT_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/jetbrainsclient.vmoptions&#39;,
  SHELL: &#39;/bin/zsh&#39;,
  JETBRAINS_CLIENT_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/jetbrains_client.vmoptions&#39;,
  APPCODE_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/appcode.vmoptions&#39;,
  HOME: &#39;/Users/v&#39;,
  DEVECOSTUDIO_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/devecostudio.vmoptions&#39;,
  CLION_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/clion.vmoptions&#39;,
  GOLAND_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/goland.vmoptions&#39;,
  PYCHARM_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/pycharm.vmoptions&#39;,
  WEBSTORM_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/webstorm.vmoptions&#39;,
  IDEA_VM_OPTIONS: &#39;/Users/v/java/ç ´è§£å·¥å\x85·intellij/vmoptions/idea.vmoptions&#39;,
  TMPDIR: &#39;/var/folders/ql/878t6sxs55zd1_l592j7ffxr0000gn/T/&#39;,
  __CF_USER_TEXT_ENCODING: &#39;0x1F5:0x19:0x34&#39;,
  XPC_SERVICE_NAME: &#39;0&#39;,
  XPC_FLAGS: &#39;0x0&#39;,
  ORIGINAL_XDG_CURRENT_DESKTOP: &#39;undefined&#39;,
  SHLVL: &#39;1&#39;,
  PWD: &#39;/Users/v/mywork/myNode&#39;,
  OLDPWD: &#39;/Users/v/mywork/myNode&#39;,
  HOMEBREW_BOTTLE_DOMAIN: &#39;https://mirrors.ustc.edu.cn/homebrew-bottles&#39;,
  HOMEBREW_PREFIX: &#39;/opt/homebrew&#39;,
  HOMEBREW_CELLAR: &#39;/opt/homebrew/Cellar&#39;,
  HOMEBREW_REPOSITORY: &#39;/opt/homebrew&#39;,
  MANPATH: &#39;/opt/homebrew/share/man:/usr/share/man:/usr/local/share/man:/Library/TeX/Distributions/.DefaultTeX/Contents/Man:/opt/homebrew/share/man::&#39;,
  INFOPATH: &#39;/opt/homebrew/share/info:/opt/homebrew/share/info:&#39;,
  M2_HOME: &#39;/usr/local/apache-maven-3.8.6&#39;,
  ANDROID_HOME: &#39;/Users/v/Library/Android/idk&#39;,
  TERM_PROGRAM: &#39;vscode&#39;,
  TERM_PROGRAM_VERSION: &#39;1.89.0&#39;,
  LANG: &#39;zh_CN.UTF-8&#39;,
  COLORTERM: &#39;truecolor&#39;,
  GIT_ASKPASS: &#39;/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh&#39;,
  VSCODE_GIT_ASKPASS_NODE: &#39;/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)&#39;,
  VSCODE_GIT_ASKPASS_EXTRA_ARGS: &#39;&#39;,
  VSCODE_GIT_ASKPASS_MAIN: &#39;/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js&#39;,
  VSCODE_GIT_IPC_HANDLE: &#39;/var/folders/ql/878t6sxs55zd1_l592j7ffxr0000gn/T/vscode-git-f81461131c.sock&#39;,
  VSCODE_INJECTION: &#39;1&#39;,
  ZDOTDIR: &#39;/Users/v&#39;,
  USER_ZDOTDIR: &#39;/Users/v&#39;,
  TERM: &#39;xterm-256color&#39;,
  _: &#39;/usr/local/bin/node&#39;
&#125;
</code></pre>
<p>该属性对象的最大作用是判断当前的驱动环境：注入不同的开发环境，在运行脚本时对环境进行判断，不同环境做不同的事情</p>
<pre><code class="jsx">console.log(process.env.MODE_ENV=&#39;script&#39;)
console.log(process.env.MODE_ENV)
</code></pre>
</li>
<li><p><code>argv</code>：启动node时的命令行参数，是用户自己定义的参数，写在末尾，比如webpack打包的时候，输入的<code>—help</code> 就是通过<code>argv</code>来读取的</p>
</li>
<li><p><code>execArgv</code>：node命令后的直接参数，是node自带的参数，写在node后面</p>
</li>
<li><p><code>stdout</code>和<code>stdin</code>：屏幕输出和输入对象</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li><p><code>cwd()</code> ：获取当前进程工作目录，该方法和<code>__dirname</code> 看似一样，但是当你<code>cd</code> 到上级目录后，<code>__dirname</code> 随之改变，但是工作进程目录是不变的，你的js文件在哪个目录，它就永远是哪个目录</p>
</li>
<li><p><code>exit()</code> ：退出进程</p>
</li>
<li><p><code>memoryUsage()</code> ：获取内存使用情况</p>
<pre><code class="jsx">&#123;
  rss: 31670272,
  heapTotal: 4227072,
  heapUsed: 2977752,
  external: 1080724,
  arrayBuffers: 10515
&#125;
</code></pre>
<p><code>rss</code>为node总内存，<code>heapTotal</code>为node堆内存，<code>heapUsed</code>为已使用内存，<code>external</code>为调用C++的额外内存，<code>arrayBuffers</code>是<code>buffer</code>内存</p>
</li>
</ul>
<p><strong>示例1：获取和修改环境变量</strong></p>
<pre><code class="jsx">// 获取环境变量  
const envVar = process.env.LOGNAME;  
console.log(envVar);  
  
// 修改环境变量（注意：这不会修改父进程或操作系统的环境变量，只会影响当前Node.js进程）  
process.env.LOGNAME = &#39;new value&#39;;  
console.log(process.env.LOGNAME); // 输出 &#39;new value&#39;
</code></pre>
<p><strong>示例2：监听进程事件</strong></p>
<pre><code class="jsx">// 监听退出事件  
process.on(&#39;exit&#39;, (code) =&gt; &#123;  
  console.log(`About to exit with code: $&#123;code&#125;`);  
&#125;);  
  
// 当Node.js接收到SIGTERM或SIGINT信号时，会触发&#39;exit&#39;事件  
process.kill(process.pid, &#39;SIGTERM&#39;); // 这将导致进程退出并触发&#39;exit&#39;事件  
  
// 监听未捕获的异常  
process.on(&#39;uncaughtException&#39;, (err) =&gt; &#123;  
  console.error(&#39;Uncaught Exception:&#39;, err);  
  process.exit(1); // 强制退出进程  
&#125;);  
  
// 抛出一个未捕获的异常来触发&#39;uncaughtException&#39;事件  
setTimeout(() =&gt; &#123;  
  throw new Error(&#39;This is an uncaught exception&#39;);  
&#125;, 100);
</code></pre>
<p><strong>示例3：获取进程信息</strong></p>
<pre><code class="jsx">// 获取当前进程的PID  
console.log(&#39;Process ID:&#39;, process.pid);  
  
// 获取当前进程的标题（可以通过process.title修改）  
console.log(&#39;Process title:&#39;, process.title);  
  
// 获取当前Node.js的版本  
console.log(&#39;Node.js version:&#39;, process.version);  
  
// 获取当前Node.js平台的架构  
console.log(&#39;Platform architecture:&#39;, process.arch);  
  
// 获取当前操作系统平台  
console.log(&#39;Operating system platform:&#39;, process.platform);
</code></pre>
<p><strong>示例4：发送信号给进程</strong></p>
<pre><code class="jsx">// 发送信号给当前进程（这通常不是一个好实践，但只是为了演示）  
process.kill(process.pid, &#39;SIGTERM&#39;); // 这将导致进程退出  
  
// 在实际中，你可能会发送信号给子进程或其他进程  
// 例如，使用child_process模块创建子进程后，可以使用process.kill发送信号
</code></pre>
<p><strong>示例5：获取工作台输入</strong></p>
<pre><code class="jsx">process.stdout.write(&#39;请输入一个数字&#39;)
process.stdin.on(&#39;data&#39;,res=&gt;&#123;
    console.log(res.toString())
        process.exit()
&#125;)
</code></pre>
<p>使用<code>on</code>对<code>stdin</code>进行监听，一旦获取到<code>data</code>，就执行回调函数，以实现和控制台的交互。比如vue-cli打包的时候，一直通过控制台和用户交互，用的就是这种方式</p>
<h2 id="util工具模块"><a href="#util工具模块" class="headerlink" title="util工具模块"></a>util工具模块</h2><p>该模块提供了许多实用的工具函数，使得开发者能够更便捷地进行各种常见的操作</p>
<p>类型判断：</p>
<ul>
<li><code>util.isArray(object)</code></li>
<li><code>util.isBoolean(object)</code></li>
<li><code>util.isNull(object)</code></li>
<li><code>util.isNullOrUndefined(object)</code></li>
<li><code>util.isNumber(object)</code></li>
<li><code>util.isString(object)</code></li>
<li><code>util.isSymbol(object)</code></li>
<li><code>util.isUndefined(object)</code></li>
<li><code>util.isObject(object)</code>：判断一个对象是否是一个对象（不是数组、null、undefined、字符串、数字、布尔值或 Symbol）</li>
<li><code>util.isPrimitive(object)</code>：判断一个对象是否是原始类型（字符串、数字、布尔值、Symbol 或 null）</li>
<li><code>util.isFunction(object)</code>：判断一个对象是否是一个函数</li>
<li><code>util.isRegExp(object)</code>：判断一个对象是否是一个正则表达式</li>
<li><code>util.isError(object)</code>：判断一个对象是否是一个 Error 对象</li>
<li><code>util.types</code>：这是一个对象，提供了各种用于检查对象类型的函数，如 <code>util.types.isBigInt64Array(object)</code>、<code>util.types.isBigUint64Array(object)</code> 等。</li>
</ul>
<p>回调转换：</p>
<ul>
<li><code>util.promisify(original)</code>：把异步函数包装为<code>promise</code>对象形式</li>
</ul>
<pre><code class="jsx">let util = require(&#39;util&#39;)
let fs = require(&#39;fs&#39;)

fs.readFile(&#39;./test.txt&#39;, (error, content) =&gt; &#123;
    console.log(content.toString())
&#125;)
//转换为Promise形式以后，可以使用then API了
const promiseReadFile = util.promisify(fs.readFile)
promiseReadFile(&#39;./test.txt&#39;).then(res =&gt; &#123;
    console.log(res.toString())
&#125;)
</code></pre>
<ul>
<li><code>util.callbackify(asyncFn)</code>：将一个返回值为<code>promise</code>的函数改为回调</li>
</ul>
<pre><code class="jsx">let util = require(&#39;util&#39;)
function f1() &#123;
    return new Promise(
        res =&gt; &#123;
            setTimeout(() =&gt; &#123;
                res(20)
                //回调产生一个值10
            &#125;, 2000)
        &#125;
    )
&#125;
const callbackf1 = util.callbackify(f1)
callbackf1(function (num) &#123;
    console.log(num)
&#125;)
</code></pre>
<h2 id="fs文件模块"><a href="#fs文件模块" class="headerlink" title="fs文件模块"></a>fs文件模块</h2><p><code>fs</code>模块是Node.js中用于与文件系统进行交互的核心模块之一</p>
<h3 id="常用文件操作"><a href="#常用文件操作" class="headerlink" title="常用文件操作"></a>常用文件操作</h3><ol>
<li><p>读取文件：<code>readFile</code></p>
<pre><code class="jsx">fs.readFile(&#39;example.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; &#123;  
  if (err) throw err;  
  console.log(data);  
&#125;);
</code></pre>
</li>
<li><p>写入并创建文件，如果文件已存在，已存在的文件将被覆盖：<code>writeFile</code></p>
<pre><code class="jsx">fs.writeFile(&#39;example.txt&#39;, &#39;Hello, World!&#39;, &#39;utf8&#39;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;The file has been saved!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>向文件末尾追加内容，如果文件不存在，它将被创建：<code>appendlink</code></p>
<pre><code class="jsx">fs.appendFile(&#39;example.txt&#39;, &#39;Appended text&#39;, &#39;utf8&#39;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;The &quot;data to append&quot; was appended to file!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>删除文件：<code>unlink</code></p>
</li>
<li><p>移动&#x2F;重命名文件：<code>rename</code></p>
</li>
<li><p>拷贝文件：<code>copyFile</code></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>所有文件方法都是异步操作，以一个回调函数作为最后的参数，路径作为第一个参数通常</li>
<li>所有文件方法都有一个同步版本，就是在原方法后加一个<code>Sync</code>，它不用回调函数作为参数，写入结果直接返回</li>
<li>需要注意的是，如果既有同步的文件操作，又有异步的文件操作，事件循环机制会使同步操作先执行，而导致异步操作的结果可能对同步结果进行覆盖</li>
</ul>
<h3 id="常用文件夹操作"><a href="#常用文件夹操作" class="headerlink" title="常用文件夹操作"></a>常用文件夹操作</h3><ol>
<li><p>读取文件夹目录中的文件：<code>readdir</code></p>
<pre><code class="jsx">fs.readdir(&#39;./&#39;, (err, files) =&gt; &#123;  
  files.forEach(file =&gt; &#123;  
    console.log(file);  
  &#125;);  
&#125;);
</code></pre>
</li>
<li><p>创建空文件夹：<code>mkdir</code></p>
<pre><code class="jsx">fs.mkdir(&#39;./newDir&#39;, &#123; recursive: true &#125;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;Directory has been created!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>删除（只有空文件夹可以删除）：<code>rmdir</code></p>
<pre><code class="jsx">fs.rmdir(&#39;./newDir&#39;, &#123; recursive: true &#125;, (err) =&gt; &#123;  
  if (err) throw err;  
  console.log(&#39;Directory has been deleted!&#39;);  
&#125;);
</code></pre>
</li>
<li><p>拷贝和移动：没有直接api，必须手动遍历</p>
<ul>
<li><em><strong>递归清空文件夹中的文件</strong></em></li>
</ul>
<pre><code class="jsx">const fs = require(&#39;fs&#39;)
const ph = require(&#39;path&#39;)

function empty(path) &#123;
    if (fs.existsSync(path)) &#123;
        const dir = fs.readdirSync(path)
        dir.forEach(item =&gt; &#123;
            const fullpath = ph.join(path, item)
            const _state = fs.statSync(fullpath)
            if (_state.isDirectory()) &#123;
                empty(fullpath)
            &#125; else &#123;
                fs.unlinkSync(fullpath)
            &#125;
        &#125;)
    &#125;
&#125;
empty(&#39;./testdir&#39;)
</code></pre>
<ul>
<li><em><strong>递归拷贝文件夹</strong></em></li>
</ul>
<pre><code class="jsx">const fs = require(&#39;fs&#39;)
const ph = require(&#39;path&#39;)

function copy(srcpath, targetpath) &#123;
    if (!fs.existsSync(targetpath)) &#123;
        fs.mkdirSync(targetpath)
    &#125;
    if (fs.existsSync(srcpath)) &#123;
        const dir = fs.readdirSync(srcpath)
        dir.forEach(item =&gt; &#123;
            const srcfullpath = ph.join(srcpath, item)
            const targetfullpath = ph.join(targetpath, item)
            const state = fs.statSync(srcfullpath)
            if (state.isDirectory()) &#123;
                copy(srcfullpath, targetfullpath)
            &#125; else &#123;
                fs.copyFileSync(srcfullpath,targetfullpath)
            &#125;
        &#125;)
    &#125;
&#125;
copy(&#39;./testdir&#39;, &#39;./dir&#39;)
</code></pre>
<p><em>注意：如果没使用同步函数并且没有加入回调函数作为参数，运行时就会报错</em></p>
</li>
<li><p>获取文件或目录的详细信息（如大小、创建时间等）：<code>stat()</code></p>
<pre><code class="jsx">fs.stat(&#39;example.txt&#39;, (err, stats) =&gt; &#123;  
  console.log(stats.isFile()); // 检查是否为文件  
  console.log(stats.size); // 文件大小（字节）  
&#125;);
</code></pre>
</li>
</ol>
<h3 id="常用检测文件夹方法"><a href="#常用检测文件夹方法" class="headerlink" title="常用检测文件夹方法"></a>常用检测文件夹方法</h3><ol>
<li>检查文件或文件夹是否存在：<code>exists</code></li>
<li>获取文件状态信息，判断是文件还是文件夹：<code>stat</code></li>
</ol>
<h3 id="其他文件操作"><a href="#其他文件操作" class="headerlink" title="其他文件操作"></a>其他文件操作</h3><ul>
<li><code>watch</code>：监听文件是否发生改变，一旦改变则出发回调。因为一直处于监听状态，所以程序不会退出</li>
<li><code>open</code>：打开后可以进行自由操作（基本不用了）<ul>
<li><code>read</code>：自由读取</li>
<li><code>write</code>：自由写入</li>
</ul>
</li>
<li><code>writeStream</code>和<code>readStream</code>：以流形式进行操作，创建写入流和读取流</li>
</ul>
<pre><code class="jsx">const fs=require(&#39;fs&#39;)
fs.watch(&#39;./copy.txt&#39;,(err,filename)=&gt;&#123;
    console.log(filename+&#39;文件发生改变&#39;)
    process.exit()
&#125;)
</code></pre>
<h3 id="好用的第三方库"><a href="#好用的第三方库" class="headerlink" title="好用的第三方库"></a>好用的第三方库</h3><aside>
💡 *注意：用之前先安装*


</aside>

<p><code>fs-extra</code> ：提供了一些操作文件的方法，如果开发过程中经常使用文件操作的话，最好引入这个包，功能比原生的<code>fs</code>模块更强大</p>
<ul>
<li><code>copy</code> ：可以拷贝文件，也可以拷贝文件夹</li>
<li><code>emptyDir</code> ：递归清空文件夹</li>
<li><code>remove</code> ：删除文件或者文件夹</li>
<li><code>move</code> ：移动文件或者文件夹</li>
<li><code>outputFile</code> ：向文件中添加内容，如果文件不存在，则自动创建</li>
</ul>
<pre><code class="jsx">const fs = require(&#39;fs-extra&#39;)
fs.copySync(&#39;./dir&#39;,&#39;./newdir&#39;)
fs.emptyDirSync(&#39;./dir&#39;)
fs.removeSync(&#39;./newdir&#39;)
fs.moveSync(&#39;./testdir&#39;,&#39;./dir/testdir&#39;)
fs.outputFileSync(&#39;./newcopy.txt&#39;,&#39;love u&#39;)
</code></pre>
<p><code>compressing</code> ：帮助制作文件压缩包和解压文件压缩包，因为文件夹是不能进行网络传输的，因此想要上传文件夹必须先压缩。这个包里的回调方法采用的是promise，而不是回调函数</p>
<ul>
<li><code>zip.compressDir</code> ：压缩文件夹</li>
<li><code>zip.uncompress</code> ：解压压缩包</li>
</ul>
<pre><code class="jsx">const cm = require(&#39;compressing&#39;)
cm.zip.compressDir(&#39;./dir&#39;,&#39;./dirzip.zip&#39;).then(res=&gt;&#123;
    console.log(&#39;压缩成功&#39;)
&#125;)
cm.zip.uncompress(&#39;./dirzip.zip&#39;,&#39;./zip&#39;).then(res=&gt;&#123;
    console.log(&#39;解压成功&#39;)
&#125;)
</code></pre>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/05/09/JavaScript-core-principle/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/JavaScript.png" data-sizes="auto" alt="JavaScript核心原理" class="lazyload">
                    <h1>JavaScript核心原理</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月09日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 20 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="JavaScript-执行机制"><a href="#JavaScript-执行机制" class="headerlink" title="JavaScript 执行机制"></a>JavaScript 执行机制</h2><p>JavaScript 的执行机制主要涉及到其单线程特性、事件循环以及任务队列等概念。下面详细解释这些概念以及它们如何共同影响 JavaScript 的执行。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a><strong>单线程</strong></h3><p>JavaScript 是单线程的，这意味着它一次只能执行一个任务。这确保了代码执行的顺序性和一致性，但同时也带来了一个问题：当遇到需要等待的操作（如 I&#x2F;O 操作、定时器、网络请求等）时，整个线程会被阻塞，直到该操作完成。</p>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a><strong>异步编程</strong></h3><p>为了解决这个问题，JavaScript 引入了异步编程的概念。异步编程允许 JavaScript 在等待某个操作完成的同时执行其他任务。但如果同步代码依赖的是异步任务执行完的结果，怎么办呢？</p>
<p>给出的解决方法就是回调函数，当你调用一个异步API并传递一个回调函数时，一旦异步操作完成，事件循环会收到通知，并自动将相应的回调函数推入任务队列。</p>
<p><strong>常见的异步任务有：</strong></p>
<ol>
<li>定时器：<code>setTimeout</code> 和 <code>setInterval</code></li>
<li>建立网络连接：<code>fetch</code> API 、 <code>XMLHttpReques</code>、 <code>http</code>、<code>https</code> 或其他第三方库（如 <code>axios</code>、<code>request</code>）</li>
<li>读取网络流数据</li>
<li>向文件写入数据：<code>fs</code></li>
<li>Ajax提交</li>
<li>请求数据库服务</li>
<li>动态import()</li>
</ol>
<p><strong>异步操作在Node.js中的执行环境：</strong></p>
<ol>
<li><strong>事件循环</strong>：与浏览器环境不同的是，Node.js的事件循环包括更多的阶段（如timers、pending callbacks、idle, prepare、poll、check、close callbacks等），这些阶段用于处理不同类型的异步任务。</li>
<li><strong>多线程</strong>：虽然JavaScript在Node.js中仍然是单线程执行的，但Node.js内部使用了多线程来处理某些类型的异步任务。这些线程由Node.js的底层库管理，当Node.js代码执行一个异步I&#x2F;O操作时，它会将任务委托给libuv库，然后立即返回并继续执行后续的代码。libuv库会根据操作系统的功能（例如，Linux的epoll、Windows的IOCP等）来高效地处理这些异步I&#x2F;O任务。当异步I&#x2F;O操作完成时，libuv库会通知Node.js，然后Node.js会将相应的回调函数放入事件循环的队列中等待执行。所以，虽然V8引擎是Node.js的核心部分，用于执行JavaScript代码，但异步I&#x2F;O操作是由libuv库和底层操作系统来处理的，而不是由V8引擎直接处理。这种设计使得Node.js能够高效地处理大量并发连接和异步操作，从而成为构建高性能网络应用的理想选择。</li>
</ol>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h3><p>在JavaScript中，宏任务（MacroTasks）和微任务（MicroTasks）是事件循环中处理异步操作的两类主要任务。</p>
<p><strong>宏任务</strong></p>
<ul>
<li><strong>script（全局任务）</strong>：这是代码的主入口，整个的script标签内都是宏任务。</li>
<li><strong>setTimeout</strong>：延迟一段时间后执行的任务。</li>
<li><strong>setInterval</strong>：每隔一段时间执行的任务。</li>
<li><strong>setImmediate</strong>（Node.js环境）：在I&#x2F;O事件后执行的任务，在Node.js中与setTimeout类似，但在浏览器中没有这个函数。</li>
<li><strong>I&#x2F;O操作</strong>：如Node.js中的文件读写、网络请求等。</li>
<li><strong>UI渲染</strong>（浏览器环境）：浏览器在空闲时会进行页面的渲染。</li>
</ul>
<p><strong>微任务</strong></p>
<ul>
<li><strong>Promise</strong>：Promise的回调函数是微任务。当Promise的状态改变（从pending变为fulfilled或rejected）时，其then或catch方法中的回调函数会被放入微任务队列。</li>
<li><strong>process.nextTick</strong>（Node.js环境）：Node.js特有的API，用于在当前执行栈的末尾立即执行回调。但如果在Vue.js中，则为DOM更新之后立即执行。</li>
<li><strong>MutationObserver</strong>（浏览器环境）：用于监视DOM更改的API，其回调函数也是微任务。</li>
</ul>
<p>当JavaScript代码执行时，如果是在浏览器环境中，会先执行script（或称为全局任务）中的同步代码，然后执行微任务队列中的回调，最后才执行宏任务队列中的回调。这个过程会一直重复，直到所有的任务都被执行完毕。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a><strong>事件循环</strong></h3><p>事件循环是 JavaScript 引擎处理异步任务和更新 UI 的主要方式。它的工作原理大致如下：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/09/JavaScript-core-principle/Untitled.png" alt="Untitled" class="lazyload"></p>
<ol>
<li><p><strong>执行栈（Call Stack）</strong>：JavaScript 引擎有一个执行栈，用于存储函数调用和返回的结果。当执行栈为空时，事件循环会查看任务队列和微任务队列。</p>
<ul>
<li>同步代码：立即放入JS引擎（主线程）执行，并原地等待结果</li>
<li>异步代码：先放入宿主环境（浏览器&#x2F;Node)，不必原地等待结果，并不阻塞主线程继续往下执行，回调函数在等到异步结果之后再执行</li>
</ul>
<p>于是，调用栈中放主线任务，宿主环境来执行异步任务，在执行完后会通知主线程，并自动把回调函数推送到任务队列中，等执行栈中任务空了，就会从任务队列中拿回调。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/09/JavaScript-core-principle/Untitled1.png" alt="Untitled" class="lazyload"></p>
<p>同样是异步任务的回调函数，有的回调是需要连贯执行的，为了优化这个体验，又分为了<strong>微任务（需要立即连贯执行）</strong>和<strong>宏任务（不需要立即连贯执行）</strong></p>
<p>事件循环中任务队列的过程可以分为先检查微任务队列，再检查宏任务队列</p>
</li>
<li><p><strong>检查微任务队列</strong>：在每次事件循环迭代中，JavaScript 引擎会首先查看微任务队列。如果微任务队列中有任务，它会执行这些任务，直到微任务队列为空。</p>
</li>
<li><p><strong>执行栈和微任务队列</strong>：在执行微任务的过程中，如果有新的微任务被添加到微任务队列，它们也会在当前事件循环迭代中被执行。只有当微任务队列完全为空时，JavaScript 引擎才会继续下一步。</p>
</li>
<li><p><strong>检查宏任务队列</strong>：当微任务队列为空时，JavaScript 引擎会查看宏任务队列。如果宏任务队列中有任务，它会取出第一个任务并将其推入执行栈中执行。这个过程会一直重复，直到任务队列为空。</p>
</li>
<li><p><strong>渲染</strong>：在执行完一个事件循环迭代中的所有任务后，浏览器会更新 UI 并进行渲染。</p>
</li>
<li><p><strong>下一轮事件循环</strong>：然后，事件循环会开始新一轮的迭代，再次检查微任务队列和任务队列中的任务。</p>
</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h2><p>当一个请求，它依赖于上一个请求的结果的时候，就需要来调用回调函数，如果这样的请求多了，就会变成这样：</p>
<pre><code class="jsx">请求1(function(res1)&#123;
    请求2(function(res2)&#123;
        请求3(function(res3)&#123;
            请求4(function(res4)&#123;
                ......
            &#125;)
        &#125;)
    &#125;)
&#125;)
</code></pre>
<p>这就是回调地狱，为了优雅的表示异步回调，便有了<code>Promise</code>。</p>
<p><code>Promise</code> 是 JavaScript 中的一个对象，它的构造函数为<code>new Promise(fn)</code>，<code>fn</code>为回调函数，它接收两个参数<code>resolve</code>和<code>reject</code>。</p>
<p>以下是 Promise 的一些基本概念和特性：</p>
<ol>
<li><p><strong>状态</strong>：Promise 有三种状态：</p>
<ul>
<li><code>pending</code>（待定）：初始状态，既不是成功，也不是失败状态。</li>
<li><code>fulfilled</code>（已实现）：意味着操作成功完成。</li>
<li><code>rejected</code>（已拒绝）：意味着操作失败。</li>
</ul>
</li>
<li><p><strong>执行器（Executor）</strong>：<code>Promise</code> 构造函数接受一个执行器函数作为参数，<strong>异步操作会放在该执行器函数内</strong>。执行器函数有两个参数：<code>resolve</code> 和 <code>reject</code>，它们是两个函数，分别用于将 Promise 的状态从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>。这两个函数为<code>Promise</code>对象的内置函数，无需自己定义。</p>
<pre><code class="jsx">const promise = new Promise((resolve, reject) =&gt; &#123;  
  // 假设这是一个异步操作，例如从服务器获取数据  
  setTimeout(() =&gt; &#123;  
    // 模拟异步操作成功，我们调用 resolve 函数，并传递一个值  
    const data = &#39;成功获取的数据&#39;;  
    resolve(data);  
  &#125;, 1000);  
  
  // 注意：在实际应用中，你可能需要在某个错误处理回调中调用 reject 函数  
  // 例如，网络请求失败时  
&#125;);  
</code></pre>
<p><code>**resolve</code> 函数被用来在异步操作成功时传递一个值给 Promise 的成功处理函数。这个值会成为 <code>then</code> 方法第一个回调函数的参数。**如果异步操作失败，你应该用 <code>reject</code> 函数，并传递一个表示错误原因的值给 Promise 的失败处理函数（即 <code>then</code> 方法的第二个参数，或者更常见的 <code>catch</code> 方法）。</p>
</li>
<li><p><strong>链式调用（Chaining）</strong>：<code>Promise</code> 提供了 <code>.then()</code> 和 <code>.catch()</code> 方法，用于注册成功和失败的回调函数。这两个方法都返回新的 Promise 对象，因此可以链式调用。</p>
<pre><code class="jsx">// 使用 then 方法处理 Promise 的结果  
promise.then(  
  value =&gt; &#123;  
    console.log(value); // 输出：成功获取的数据  
    // 在这里，你可以对获取到的数据做进一步的处理  
  &#125;,  
  error =&gt; &#123;  
    // 这个回调函数会在 Promise 被 reject 时调用  
    // 但在这个示例中，因为我们从未调用 reject，所以这个回调函数不会被执行  
    console.error(&#39;出现错误：&#39;, error);  
  &#125;  
);
</code></pre>
</li>
<li><p><strong>错误处理</strong>：每一步都写<code>reject</code>特别麻烦，为了简化任务需要，我们诞生了<code>catch</code>方法，来捕获<code>resolve</code>时的异常，这样就可以省略<code>reject</code>方法了。</p>
</li>
<li><p><strong><code>Promise</code> 链</strong>：多个 <code>.then()</code> 调用可以组成 <code>Promise</code> 链，每个 <code>.then()</code> 的回调函数都会接收前一个 <code>Promise</code> 的结果作为参数。</p>
</li>
<li><p><strong>静态方法</strong>：为了满足更多业务需要，又诞生了6个<code>promise</code>的静态方法。</p>
<ul>
<li><code>promise.all()</code>等待所有<code>Promise</code>执行成功，一个不成功都算失败</li>
<li><code>promise.allSettled()</code>等待所有<code>Promise</code>执行完成，无论成功还是失败</li>
<li><code>promise.any()</code>任意一个promise成功就行</li>
<li><code>promise.race()</code>等待第一个promise完成</li>
<li><code>promise.reject(reason)</code>返回一个状态为<code>rejected</code>的<code>Promise</code>对象</li>
<li><code>Promise.resolve()</code>它会接受四种类型的参数：<ol>
<li>一个<code>promise</code>实例——直接返回</li>
<li>具有<code>then</code>方法的对象——转为<code>promise</code>对象，并立即执行<code>then</code>方法</li>
<li>普通对象或不是对象——返回一个新的<code>promise</code>对象，将参数传给下一个<code>then</code></li>
<li>不带任何参数——状态为<code>resolved</code>的<code>promise</code>对象</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>下面是一个简单的 Promise 示例：</p>
<pre><code class="jsx">function fetchData() &#123;  
  return new Promise((resolve, reject) =&gt; &#123;  
    // 模拟异步操作，例如 AJAX 请求  
    setTimeout(() =&gt; &#123;  
      // 模拟成功获取数据  
      const data = &#39;Hello, World!&#39;;  
      resolve(data); // 将 Promise 状态设置为 fulfilled，并传递数据  
    &#125;, 1000);  
  
    // 如果发生错误，可以调用 reject 函数  
    // reject(new Error(&#39;Failed to fetch data&#39;));  
  &#125;);  
&#125;  
  
// 使用 Promise  
fetchData()  
  .then(data =&gt; &#123;  
    console.log(data); // 输出 &#39;Hello, World!&#39;  
    // 返回新的 Promise 或值，可以继续链式调用  
    return &#39;Another data point&#39;;  
  &#125;)  
  .then(data =&gt; &#123;  
    console.log(data); // 输出 &#39;Another data point&#39;  
  &#125;)  
  .catch(error =&gt; &#123;  
    console.error(&#39;An error occurred:&#39;, error);  
  &#125;);
</code></pre>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a><code>async</code> 和 <code>await</code></h2><p><code>async</code> 和 <code>await</code> 是 JavaScript 中用于处理异步操作的关键字，它们主要用在 <code>Promise</code> 和基于 <code>Promise</code> 的技术中。使得异步代码能够以更直观、更易于理解的同步代码风格来编写。</p>
<p><strong>async</strong></p>
<ul>
<li><code>async</code> 函数是声明一个函数是异步的。</li>
<li>异步函数总是返回一个 <code>Promise</code>。</li>
<li>如果 <code>async</code> 函数中有 <code>return</code> 语句，返回的值将被包装在一个 <code>Promise</code> 中。</li>
<li>如果 <code>async</code> 函数中没有 <code>return</code> 语句，则返回的 <code>Promise</code> 将解析为 <code>undefined</code>。</li>
</ul>
<p><strong>await</strong></p>
<ul>
<li><code>await</code> 关键字只能在 <code>async</code> 函数内部使用。</li>
<li><code>await</code> 会卡在当前的异步操作中等待 <code>Promise</code> 完成并返回结果，然后继续往下执行。</li>
<li>如果等待的 Promise 被拒绝，<code>await</code> 表达式会抛出一个错误。</li>
</ul>
<p>示例：</p>
<pre><code class="jsx">async function fetchData() &#123;  
  let response = await fetch(&#39;https://api.example.com/data&#39;);  
  let data = await response.json();  
  return data;  
&#125;  
  
fetchData().then(data =&gt; &#123;  
  console.log(data);  
&#125;).catch(error =&gt; &#123;  
  console.error(&#39;Error:&#39;, error);  
&#125;);
</code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>不要在非 <code>async</code> 函数中使用 <code>await</code>，否则会导致语法错误。</li>
<li>当你需要处理一系列的异步操作，可以使用 <code>async/await</code> 的连续调用。</li>
<li>尽管 <code>async/await</code> 使得代码更易于阅读和理解，但在某些情况下（如需要并行处理多个异步操作时），使用 Promise 的链式调用或 <code>Promise.all()</code> 可能更有效率。</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在JavaScript中，作用域（Scope）是代码执行上下文中的一个重要概念，它决定了变量、函数和表达式的可访问性和生命周期。作用域决定了在何处以及如何查找变量（标识符）的引用。</p>
<h3 id="作用域类型"><a href="#作用域类型" class="headerlink" title="作用域类型"></a><strong>作用域类型</strong></h3><p>JavaScript中有两种主要的作用域类型：</p>
<ol>
<li><strong>全局作用域</strong>：不在任何函数内部的变量或函数，也就是定义在windows下的变量范围，在任何地方都可以访问。容易导致全局污染，命名冲突，对bug查找不利。</li>
<li><strong>局部作用域</strong>：只在函数内部定义的变量范围。<ul>
<li><strong>函数作用域</strong>：在ES6之前，JavaScript只有函数作用域，这意味着变量在函数内部是局部的，在函数外部是不可见的。</li>
<li><strong>块级作用域（Block Scope）</strong>：ES6引入了<code>let</code>和<code>const</code>关键字，它们提供了块级作用域。在<code>&#123;&#125;</code>中声明的变量或常量仅在该块内部是可访问的。</li>
</ul>
</li>
</ol>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><p>作用域链就是由最内部的作用域往最外部查找变量的过程，形成的链条就是作用域链。</p>
<p>作用域链是一种数据结构，它保存了当前执行上下文中所有变量和函数引用的有序列表。这个列表从当前作用域开始，然后是其父级作用域，然后是更高级别的父级作用域，直到全局作用域。如果变量未在任何作用域中找到，那么将抛出一个引用错误（ReferenceError）。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（Closure）允许函数记住并访问其所在的词法环境，即使在函数执行完毕并返回后，这些词法环境中的数据仍然可以被闭包内部的代码所访问。闭包有几个主要的应用场景：</p>
<ol>
<li><p><strong>数据封装和私有变量</strong>：</p>
<p>闭包可以用来封装数据，并通过特定的接口（函数）来访问这些数据，从而实现数据的私有性。</p>
<pre><code class="jsx">function createCounter() &#123;  
    let count = 0; // 私有变量，不通过return暴露  
    return &#123;  
        increment: function() &#123;  
            count++;  
        &#125;,  
        getCount: function() &#123;  
            return count;  
        &#125;  
    &#125;;  
&#125;  
const counter = createCounter();  
counter.increment();  
console.log(counter.getCount()); // 输出：1
</code></pre>
</li>
<li><p><strong>回调函数和高阶函数</strong>：</p>
<p>闭包经常作为回调函数使用，因为它们可以记住自己的词法环境，包括this、变量等。在高阶函数中，闭包也非常有用，因为它们可以接收函数作为参数，并返回函数作为结果。</p>
<pre><code class="jsx">function greet(name) &#123;  
    return function(greeting) &#123;  
        console.log(greeting + &#39;, &#39; + name);  
    &#125;;  
&#125;  

const helloJohn = greet(&#39;John&#39;);  
helloJohn(&#39;Hello&#39;); // 输出：Hello, John
</code></pre>
</li>
<li><p><strong>实现装饰器&#x2F;函数修饰器</strong>：</p>
<p>闭包可以用来创建装饰器，它们可以修改或增强函数的行为。</p>
<pre><code class="jsx">function logCalls(func) &#123;  
    return function() &#123;  
        console.log(&#39;Calling: &#39; + func.name);  
        func.apply(this, arguments);  
    &#125;;  
&#125;  
const originalFunc = function() &#123;  
    console.log(&#39;Inside original function&#39;);  
&#125;;  
const loggedFunc = logCalls(originalFunc);  
loggedFunc(); // 输出：Calling: originalFunc, Inside original function
</code></pre>
</li>
<li><p><strong>实现模块模式</strong>：</p>
<p>闭包可以用来模拟私有属性和方法，从而创建模块。这有助于避免全局命名空间的污染，并提供了一种组织代码的方式。</p>
<pre><code class="jsx">var myModule = (function() &#123;  
    var privateVar = &#39;Hello&#39;;  
    function privateFunc() &#123;  
        return privateVar;  
    &#125;  
    return &#123;  
        publicFunc: function() &#123;  
            return privateFunc();  
        &#125;  
    &#125;;  
&#125;)();  
console.log(myModule.publicFunc()); // 输出：Hello
</code></pre>
</li>
<li><p><strong>事件监听器</strong>：</p>
<p>在事件驱动的编程中，闭包经常被用作事件监听器的回调函数，因为它们可以记住与特定事件相关的数据或状态。</p>
<pre><code class="jsx">button.addEventListener(&#39;click&#39;, function() &#123;  
    // 这个匿名函数是一个闭包，它可以访问外部变量  
    console.log(&#39;Button clicked!&#39;);  
&#125;);
</code></pre>
</li>
</ol>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>在 JavaScript 中，每个函数都有一个 <code>prototype</code> 属性，这个属性是一个指针，指向一个对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，可以通过 <code>Object.getPrototypeOf()</code> 访问。</p>
<p>当你创建一个函数（即一个类构造函数）时，JavaScript 会自动为这个函数添加一个 <code>prototype</code> 属性，这个属性是一个对象，通常被称为该函数的原型对象。</p>
<pre><code class="jsx">function Person(name) &#123;  
    this.name = name;  
&#125;  
Person.prototype.sayHello = function() &#123;  
    console.log(`Hello, my name is $&#123;this.name&#125;`);  
&#125;;    
const person1 = new Person(&#39;Alice&#39;);  
person1.sayHello(); // 输出: Hello, my name is Alice
</code></pre>
<p>在这个例子中，<code>Person.prototype</code> 就是 <code>Person</code> 构造函数的原型对象，而 <code>sayHello</code> 方法就定义在这个原型对象上。因此，当我们使用 <code>new Person(&#39;Alice&#39;)</code> 创建一个 <code>Person</code> 的实例时，这个实例（即 <code>person1</code>）可以访问到定义在 <code>Person.prototype</code> 上的 <code>sayHello</code> 方法。</p>
<p>原型链是 JavaScript 中实现继承的一种方式。当一个对象试图访问其某个属性或方法时，JavaScript 会首先在该对象自身的属性中查找，如果找不到，则会沿着该对象的原型链向上查找，直到找到为止（或者直到到达原型链的末尾，即 <code>Object.prototype</code>，此时如果还未找到，则返回 <code>undefined</code>）。</p>
<p>在上面的例子中，<code>person1</code> 对象并没有直接定义 <code>sayHello</code> 方法，但是它可以访问到 <code>Person.prototype</code> 上的 <code>sayHello</code> 方法，这就是因为 <code>person1</code> 的原型链中包含了 <code>Person.prototype</code>。</p>
<p>更具体地说，当我们使用 <code>new</code> 关键字创建一个新的对象时，JavaScript 会做以下几件事情：</p>
<ol>
<li>创建一个新的空对象。</li>
<li>将这个新对象的 <code>__proto__</code>指向构造函数的 <code>prototype</code> 对象。</li>
<li>将这个新对象作为 <code>this</code> 上下文传入构造函数并执行，从而设置新对象的属性。</li>
<li>返回这个新对象。</li>
</ol>
<p>因此，当我们说 <code>person1.sayHello()</code> 时，JavaScript 首先在 <code>person1</code> 对象自身上查找 <code>sayHello</code> 属性，由于没找到，所以会沿着原型链（即 <code>person1.__proto__</code>，也就是 <code>Person.prototype</code>）继续查找，最终在 <code>Person.prototype</code> 上找到了 <code>sayHello</code> 方法并执行。</p>
<p>需要注意的是，虽然 <code>__proto__</code> 属性在大多数现代浏览器中都可以访问，但它并不是 JavaScript 语言规范的一部分，而是某些浏览器为了实现原型链而提供的。在编写可移植的代码时，应该使用符合JavaScript 语言规范的 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 方法来访问和修改对象的原型。</p>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/04/30/Node-js_Tutorial/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/nodejs.png" data-sizes="auto" alt="Node.js介绍" class="lazyload">
                    <h1>Node.js介绍</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年04月30日</a>
            <a><i class="nexmoefont icon-areachart"></i>7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 30 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/">NodeJs</a>不是<code>JavaScript</code>应用，也不是编程语言，因为编程语言用的是<code>JavaScript</code>，Nodejs是 <code>JavaScript</code>的运行时的环境。</p>
</li>
<li><p>Nodejs是构建在V8引擎之上的，V8引擎是由C&#x2F;C++编写的，因此我们的JavaSCript代码需要由C&#x2F;C++转化后再执行。</p>
</li>
<li><p>NodeJs 使用异步 I&#x2F;O 和事件驱动的设计理念，可以高效地处理大量并发请求，提供了非阻塞式 I&#x2F;O 接口和事件循环机制，使得开发人员可以编写高性能、可扩展的应用程序，异步I&#x2F;O最终都是由<code>libuv</code> 事件循环库去实现的。</p>
</li>
<li><p>NodeJs 使用npm作为包管理工具，类似于python的pip，或者是java的Maven，目前<a target="_blank" rel="noopener" href="https://www.npmjs.com/">npm</a>拥有上百万个模块。</p>
</li>
<li><p>NodeJs适合干一些IO密集型应用，不适合CPU密集型应用，nodejsIO依靠libuv有很强的处理能力，而CPU因为NodeJs单线程原因，容易造成CPU占用率高，如果非要做CPU密集型应用，可以使用C++插件编写，或者NodeJs提供的<code>cluster</code>。(CPU密集型指的是图像的处理或者音频处理需要大量数据结构 + 算法的运算过程)</p>
<blockquote>
<p><em>IO意为Input和Output，也就是输入输出。</em></p>
</blockquote>
</li>
</ol>
<h3 id="NodeJs-大致架构图"><a href="#NodeJs-大致架构图" class="headerlink" title="NodeJs 大致架构图"></a>NodeJs 大致架构图</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/04/30/Node-js_Tutorial/1.png" alt="image.png" class="lazyload"></p>
<p>最上层为应用层，也就是可供开发的API，由<code>JavaScript</code>编写。</p>
<p>中间层和底层实现通讯，由C和C++来编写。</p>
<p>同时，NodeJs在做一些不擅长的事情的时候，可以使用C或C++写的插件来做。</p>
<p>底层需要使用V8引擎来解析<code>JavaScript</code>，最底层为操作系统，NodeJs可以实现跨平台。</p>
<h3 id="NodeJs-主要作用"><a href="#NodeJs-主要作用" class="headerlink" title="NodeJs 主要作用"></a>NodeJs 主要作用</h3><ol>
<li>为前端提供开发工具，vue-cli、webpack等</li>
<li>提供线上环境模拟（开发服务），本地开发如何上线进行调试</li>
<li>提供中间层服务器渲染（ssr、高流量项目）</li>
<li>做后端服务（极少）</li>
</ol>
<p>Nodejs的核心操作：</p>
<ol>
<li><strong>文件读写</strong></li>
<li><strong>网络服务</strong></li>
</ol>
<h2 id="Nodejs与浏览器环境"><a href="#Nodejs与浏览器环境" class="headerlink" title="Nodejs与浏览器环境"></a>Nodejs与浏览器环境</h2><h3 id="运行在浏览器环境中的代码："><a href="#运行在浏览器环境中的代码：" class="headerlink" title="运行在浏览器环境中的代码："></a>运行在浏览器环境中的代码：</h3><ul>
<li><strong>HTML页面中的JavaScript</strong>：在HTML文件的<code>&lt;script&gt;</code>标签中直接嵌入的JavaScript代码。这些代码通常用于处理用户的交互事件（如点击按钮）、更新DOM（如添加或修改页面元素）、发送AJAX请求等。</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;UTF-8&quot;&gt;  
    &lt;title&gt;Browser Code&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;button id=&quot;myButton&quot;&gt;Click me&lt;/button&gt;  
    &lt;script&gt;  
        document.getElementById(&#39;myButton&#39;).addEventListener(&#39;click&#39;, function() &#123;  
            alert(&#39;Button clicked!&#39;);  
        &#125;);  
    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;
</code></pre>
<ul>
<li><strong>外部JavaScript文件</strong>：通过<code>&lt;script src=&quot;...&quot;&gt;</code>标签在HTML页面中引入的外部JavaScript文件。这些文件通常包含更复杂的逻辑和函数，用于处理页面上的各种功能和交互。</li>
</ul>
<pre><code class="html">&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><code>script.js</code> 文件的内容：</p>
<pre><code class="javascript">function showAlert() &#123;  
    alert(&#39;Hello from script.js!&#39;);  
&#125;  
  
// 可以在页面上通过其他方式调用这个函数
</code></pre>
<ul>
<li><strong>浏览器特定的API</strong>：使用浏览器提供的特定API，如<code>window</code>、<code>document</code>、<code>navigator</code>、<code>localStorage</code>、<code>fetch</code> API等。</li>
</ul>
<h3 id="运行在Node-js环境中的代码："><a href="#运行在Node-js环境中的代码：" class="headerlink" title="运行在Node.js环境中的代码："></a>运行在Node.js环境中的代码：</h3><ul>
<li><strong>命令行工具</strong>：使用Node.js编写的命令行工具，可以执行各种任务，如文件操作、网络请求、数据转换等。</li>
</ul>
<pre><code class="javascript">// 例如，一个简单的Node.js程序，打印出&#39;Hello, Node.js!&#39;  
console.log(&#39;Hello, Node.js!&#39;);
</code></pre>
<ul>
<li><strong>Web服务器</strong>：使用Node.js的HTTP或Express等框架创建的Web服务器，用于处理客户端的请求并返回响应。</li>
</ul>
<pre><code class="javascript">const http = require(&#39;http&#39;);  
  
const server = http.createServer((req, res) =&gt; &#123;  
    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text/plain&#39; &#125;);  
    res.end(&#39;Hello, Node.js Server!&#39;);  
&#125;);  
  
server.listen(3000, () =&gt; &#123;  
    console.log(&#39;Server is listening on port 3000&#39;);  
&#125;);
</code></pre>
<ul>
<li><strong>后台任务</strong>：使用Node.js编写的长时间运行的后台任务，如数据抓取、图像处理、日志分析等。</li>
<li><strong>数据库操作</strong>：使用Node.js连接和操作数据库，如MySQL、MongoDB等。</li>
<li><strong>Node.js特定的模块和API</strong>：使用Node.js提供的核心模块（如<code>fs</code>、<code>path</code>、<code>http</code>）或第三方模块（如Express、Koa、Mongoose）来编写代码。</li>
<li><strong>没有DOM操作</strong>：Node.js代码通常不包含直接操作DOM的代码，因为它在服务器端运行，没有DOM环境。</li>
</ul>
<p>总结来说，运行在浏览器环境中的代码主要用于<u><strong>处理用户交互、更新页面内容、发送网络请求</strong></u>等前端任务，而运行在Node.js环境中的代码则主要用于<u><strong>构建服务器端应用、处理数据、创建命令行工具</strong></u>等后端任务。两者在使用的API、库、工具和运行环境上都有所不同。</p>
<h3 id="运行在浏览器环境和Node-js环境的代码主要存在以下区别："><a href="#运行在浏览器环境和Node-js环境的代码主要存在以下区别：" class="headerlink" title="运行在浏览器环境和Node.js环境的代码主要存在以下区别："></a>运行在浏览器环境和Node.js环境的代码主要存在以下区别：</h3><ol>
<li><p>全局对象：</p>
<ul>
<li><p>在浏览器中定义全局变量，会挂载到顶层对象<code>window</code>上，之后也可以通过<code>window</code>来访问该变量：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/04/30/Node-js_Tutorial/Untitled.png" alt="Untitled" class="lazyload"></p>
</li>
<li><p>在Node.js环境中，使用<code>global</code>定义全局变量，例如：</p>
<pre><code class="jsx">//a.js
global.name = &#39;abc&#39;
//b.js
require(&#39;./a&#39;)
console.log(global.name)
</code></pre>
<p>此时输入指令<code>node b.js</code>，控制台成功输出<code>abc</code></p>
<p>但由于浏览器和nodejs的全局变量不一样，不同的环境还需要判断，于是在<code>ECMAScript 2020</code> 出现了一个<code>globalThis</code>全局变量，在nodejs环境会自动切换成<code>global</code> ，浏览器环境自动切换<code>window</code>非常方便</p>
</li>
</ul>
</li>
<li><p>运行环境：</p>
<ul>
<li>浏览器环境主要用于运行前端代码，与用户直接交互，如操作DOM、处理用户事件等。</li>
<li>Node.js环境主要用于运行服务器端代码，如文件操作、数据库操作、网络请求等。Node.js提供了许多API，如<code>fs</code>、<code>http</code>、<code>crypto</code>、<code>path</code>等，用于处理这些服务器端任务。</li>
</ul>
</li>
<li><p>模块系统：</p>
<ul>
<li>浏览器环境原生支持ES6模块，并可以通过工具如<code>webpack</code>支持<code>CommonJS</code>或<code>AMD</code>等模块系统。</li>
<li>Node.js环境原生支持<code>CommonJS</code>模块，并已经开始支持ES6模块。在Node.js中，模块是通过<code>require()</code>函数引入的，而在浏览器中，可以使用ES6的<code>import</code>语句或其他模块加载器。</li>
</ul>
</li>
<li><p>DOM操作：</p>
<ul>
<li>浏览器环境提供了对DOM的完整访问，允许JavaScript代码直接操作HTML和CSS。</li>
<li>Node.js环境不仅没有DOM，也没有BOM，不能直接操作HTML或CSS。</li>
</ul>
</li>
<li><p>安全性：</p>
<ul>
<li>浏览器环境的安全性受到同源策略（<code>Same-Origin Policy</code>）的限制，以防止跨站脚本攻击（<code>XSS</code>）和其他安全问题。浏览器中的JavaScript代码不能直接访问其他来源的数据或资源。</li>
<li>Node.js环境在服务器端运行，因此具有更高的权限和更少的限制。然而，这也增加了潜在的安全风险，因此开发者需要格外小心，避免引入安全漏洞。</li>
</ul>
</li>
<li><p>I&#x2F;O操作：</p>
<ul>
<li>在浏览器环境中，JavaScript代码通常通过<code>AJAX</code>或<code>Fetch API</code>等技术与服务器进行异步通信。这些操作是异步的，不会阻塞主线程。</li>
<li>在Node.js环境中，JavaScript代码可以直接与文件系统、数据库和其他I&#x2F;O设备进行交互。Node.js使用事件驱动和非阻塞I&#x2F;O模型来处理这些操作，以实现高并发和性能。</li>
</ul>
</li>
<li><p>扩展性：</p>
<ul>
<li>浏览器环境主要关注前端功能的实现和用户体验的优化，因此其API和功能相对有限。</li>
<li>Node.js环境则更加灵活和可扩展，它可以通过npm（Node Package Manager）安装和使用大量的第三方库和工具来扩展其功能和应用范围。</li>
</ul>
</li>
</ol>
<h2 id="安装NodeJs"><a href="#安装NodeJs" class="headerlink" title="安装NodeJs"></a>安装NodeJs</h2><ul>
<li><strong>如果你是一个初学者或只需要在单一项目中工作</strong>：直接安装 Node.js<ol>
<li>当安装 Node.js 时，npm 通常会自动作为一部分一起安装，因为 npm 是 Node.js 的默认包管理工具。它允许开发者从 npm 仓库中安装、更新、发布和管理 Node.js 的第三方包和依赖。</li>
<li>npm 还支持使用 <code>package.json</code> 文件来管理项目的依赖和元数据，因此在项目中使用<code>npm install</code>即可将依赖包下载完成，</li>
</ol>
</li>
<li><strong>如果你需要维护多个项目，并且这些项目需要不同版本的 Node.js</strong>：安装 <a target="_blank" rel="noopener" href="https://github.com/nvm-sh/nvm">nvm</a> 可以更好地管理不同版本的 Node.js，避免版本冲突。<ol>
<li><strong>使用 nvm 安装或卸载特定版本Node.js</strong>：<code>nvm install 16.16.0</code> 和<code>nvm uninstall 16.16.0</code></li>
<li><strong>切换 Node.js 版本</strong>：<code>nvm use 14.15.3</code></li>
<li><strong>查看已安装和当前正在使用的 Node.js 版本</strong>：<code>nvm list</code></li>
</ol>
</li>
</ul>
<blockquote>
<p><em>安装成功后可以输入<code>node -v &amp;&amp; npm -v &amp;&amp; npx -v</code> 来查看是否安装成功及安装版本</em></p>
</blockquote>
<p>npm（全称 Node Package Manager）是 Node.js 的包管理工具，它是一个基于命令行的工具，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</p>
<hr>
<h2 id="Node-Package-Manager"><a href="#Node-Package-Manager" class="headerlink" title="Node Package Manager"></a>Node Package Manager</h2><h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package json"></a>Package json</h3><p>执行<code>npm init</code>便可以初始化一个package.json，括号内为默认选项，加上<code>-y</code>参数则将所有选项填充为默认值。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/04/30/Node-js_Tutorial/a.png" alt="image.png" class="lazyload"></p>
<ol>
<li><p><code>name</code>：项目名称，必须是唯一的字符串，通常采用小写字母和连字符的组合。</p>
</li>
<li><p><code>version</code>：项目版本号，通常采用语义化版本号规范。</p>
<blockquote>
<p><em>version 三段式版本号（例如1.0.0 ）分别代表大版本号、次版本号 、修订号，<br>大版本号一般是有重大变化才会升级，<br>次版本号一般是增加功能进行升级，<br>修订号一般是修改bug进行升级</em></p>
</blockquote>
</li>
<li><p><code>description</code>：项目描述。</p>
</li>
<li><p><code>main</code>：项目的主入口文件路径，通常是一个 JavaScript 文件。</p>
</li>
<li><p><code>keywords</code>：项目的关键字列表，方便他人搜索和发现该项目。</p>
</li>
<li><p><code>author</code>：项目作者的信息，包括姓名、邮箱、网址等。</p>
</li>
<li><p><code>license</code>：项目的许可证类型，可以是自定义的许可证类型或者常见的开源许可证（如 MIT、Apache 等）。</p>
</li>
<li><p><code>dependencies</code>：项目生产环境所依赖的包的列表，这些包会在项目运行时自动安装。如果想在不同环境下配置不同的依赖项，可以使用以下两个配置：</p>
<ul>
<li><p><code>devDependencies</code>：仅在开发过程中所需要的包的列表，这些包不会随项目一起发布，而是只在开发时使用。</p>
</li>
<li><p><code>peerDependencies</code>：项目的同级依赖，即项目所需要的模块被其他模块所依赖。一般是给编写插件和npm包的人员所使用的，比如插件名为<code>vite-plugin-xm</code>，插件的依赖为<code>vite</code> ：</p>
<pre><code class="json">  &quot;dependencies&quot;: &#123;
    &quot;vite-plugin-xm&quot;:&quot;1.0.0&quot;
  &#125;,
  &quot;peerDependencies&quot;: &#123;
    &quot;vite&quot;:&quot;^5.2.10&quot;
  &#125;
</code></pre>
</li>
</ul>
</li>
<li><p><code>scripts</code>：定义了一些脚本命令，比如启动项目、运行测试等。这些命令是通过<code>npm run xxx</code> 来执行的。</p>
</li>
<li><p><code>repository</code>：项目代码仓库的信息，包括类型、网址等。</p>
<pre><code class="json">  &quot;repository&quot;: &#123;
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;no git&quot;
  &#125;,
</code></pre>
</li>
<li><p><code>bugs</code>：项目的 bug 报告地址。</p>
</li>
<li><p><code>homepage</code>：项目的官方网站地址或者文档地址，将npm包发布到npm官网上之后，以上配置都可以被看到。</p>
</li>
</ol>
<h3 id="npm-命令"><a href="#npm-命令" class="headerlink" title="npm 命令"></a>npm 命令</h3><ol>
<li><p><code>npm init</code>：初始化一个新的 npm 项目，生成 package.json 文件。</p>
</li>
<li><p><code>npm install</code>：安装一个包或一组包（默认为最新的，可以通过<code>@</code>来下载指定版本），简写为<code>npm i</code>。安装的依赖都会存放在根目录的node_modules，默认采用扁平化的方式安装，并且排序规则为<code>.&gt;@&gt;首字母</code>。使用的算法是广度优先遍历，在遍历依赖树时，npm会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有依赖都被处理完毕。在处理每个依赖时，npm会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本。但是这种扁平化只存在于理想情况下，如果有多个模块用到同一个依赖，会出现复用的情况：</p>
<ul>
<li>安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块</li>
<li>安装某个二级模块时，若发现第一层级有相同名称，但不同版本的模块，会下载多个版本的该模块，还是会出现模块冗余的情况</li>
</ul>
<p>比如A 依赖 C1.0，B 依赖 C1.0，D 依赖 C2.0。此时C 1.0就会被放到A B的node_moduels，C2.0 会被放入D模块下面的node_moduels。</p>
</li>
<li><p><code>npm install &lt;package-name&gt; --save</code>：安装指定的包，并将其添加到 package.json 文件中的<code>dependencies</code>依赖列表中，在npm5.4版本之后加不加没区别。</p>
</li>
<li><p><code>npm install &lt;package-name&gt; --save-dev</code>：安装指定的包，并将其添加到 package.json 文件中的开发依赖列表中，简写为<code>npm -D</code>。</p>
</li>
<li><p><code>npm install -g &lt;package-name&gt;</code>：全局安装指定的包。</p>
</li>
<li><p><code>npm update &lt;package-name&gt;</code>：更新指定的包。</p>
</li>
<li><p><code>npm uninstall &lt;package-name&gt;</code>：卸载指定的包。</p>
</li>
<li><p><code>npm run &lt;script-name&gt;</code>：执行 package.json 文件中定义的脚本命令。</p>
</li>
<li><p><code>npm search &lt;keyword&gt;</code>：搜索 npm 库中包含指定关键字的包。</p>
</li>
<li><p><code>npm info &lt;package-name&gt;</code>：查看指定包的详细信息。</p>
</li>
<li><p><code>npm list</code>：列出当前项目中安装的所有包。</p>
</li>
<li><p><code>npm outdated</code>：列出当前项目中需要更新的包。</p>
</li>
<li><p><code>npm audit</code>：检查当前项目中的依赖项是否存在安全漏洞。</p>
</li>
<li><p><code>npm publish</code>：发布自己开发的包到 npm 库中。</p>
</li>
<li><p><code>npm login</code>：登录 npm 账户。</p>
</li>
<li><p><code>npm logout</code>：注销当前 npm 账户。</p>
</li>
<li><p><code>npm link</code>: 将本地模块链接到全局的 node_modules 目录下</p>
</li>
<li><p><code>npm config list</code> 用于列出所有的 npm 配置信息。执行该命令可以查看当前系统和用户级别的所有 npm 配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）</p>
</li>
<li><p><code>npm get registry</code> 用于获取当前 npm 配置中的 registry 配置项的值。registry 配置项用于指定 npm 包的下载地址，如果未指定，则默认使用 npm 官方的包注册表地址</p>
</li>
<li><p><code>npm config set registry &lt;registry-url&gt;</code> 命令，将 registry 配置项的值修改为指定的 <code>&lt;registry-url&gt;</code> 地址，比如淘宝镜像。</p>
</li>
</ol>
<h3 id="npm-install-后续流程"><a href="#npm-install-后续流程" class="headerlink" title="npm install 后续流程"></a>npm install 后续流程</h3><p>首先，检查config里的文件（可以通过<code>npm config —list</code>来查看），首先检查项目级别的<code>.npmrc</code>，至于npmrc可以配置什么给大家一个demo参考。如果没有进行配置过的话，会按照用户级别&gt;全局级别&gt;node内置级别的顺序去找<code>.npmrc</code>配置文件。</p>
<pre><code class="jsx">registry=http://registry.npmjs.org/
# 定义npm的registry，即npm的包下载源

proxy=http://proxy.example.com:8080/
# 定义npm的代理服务器，用于访问网络

https-proxy=http://proxy.example.com:8080/
# 定义npm的https代理服务器，用于访问网络

strict-ssl=true
# 是否在SSL证书验证错误时退出

cafile=/path/to/cafile.pem
# 定义自定义CA证书文件的路径

user-agent=npm/&#123;npm-version&#125; node/&#123;node-version&#125; &#123;platform&#125;
# 自定义请求头中的User-Agent

save=true
# 安装包时是否自动保存到package.json的dependencies中

save-dev=true
# 安装包时是否自动保存到package.json的devDependencies中

save-exact=true
# 安装包时是否精确保存版本号

engine-strict=true
# 是否在安装时检查依赖的node和npm版本是否符合要求

scripts-prepend-node-path=true
# 是否在运行脚本时自动将node的路径添加到PATH环境变量中
</code></pre>
<p>找到配置后会检查是否存在package-lock.json文件：</p>
<ul>
<li>如果存在会比较package-lock.json和package.json的版本是否一致：<ul>
<li>如果不一致，会根据package.json的版本进行下载，并对package-lock.json文件进行更新。</li>
<li>如果一致，会检查是否存在需要安装模块的缓存，也就是之前安装过该模块，会直接把该模块解压到node_modules中，如果不存在的话，则去npm官网下载该资源包，并检查其完整性，添加到缓存中，更新lock文件，最后解压到node_modules中</li>
</ul>
</li>
<li>如果不存在，获取包的信息，扁平化构建依赖树，再来检查有没有缓存，后续过程和以上内容没差别</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/04/30/Node-js_Tutorial/image.webp" alt="image.png" class="lazyload"></p>
<h3 id="package-lock-json-的作用"><a href="#package-lock-json-的作用" class="headerlink" title="package-lock.json 的作用"></a>package-lock.json 的作用</h3><p>很多朋友只知道这个东西可以锁定版本记录依赖树详细信息，它的一些具体参数含义为：</p>
<ul>
<li>version 参数指定了当前包的版本号</li>
<li>resolved 参数指定了当前包的下载地址</li>
<li>integrity 是一串用于验证包的完整性的哈希值</li>
<li>dev 参数指定了当前包是一个开发依赖包</li>
<li>bin 参数指定了当前包中可执行文件的路径和名称</li>
<li>engines 参数指定了当前包所依赖的Node.js版本范围</li>
</ul>
<p>知识点来了，package-lock.json 帮我们做了缓存，他会通过 <code>name + version + integrity</code> 信息生成一个唯一的key，这个key能找到对应的index-v5 下的缓存记录，如果发现有缓存记录，就会找到tar包的hash值，然后将对应的二进制文件解压到node_modeules</p>
<h3 id="npm-run-原理"><a href="#npm-run-原理" class="headerlink" title="npm run 原理"></a>npm run 原理</h3><p>假设我们想要执行一个脚本命令<code>npm run dev</code> ，该命令具体为：</p>
<pre><code class="jsx">&quot;scripts&quot;:&#123;
    &quot;dev&quot;: &quot;vite&quot;
&#125;
</code></pre>
<p>所有的可执行脚本都放在node_modules&#x2F;.bin里，读取package.json 的scripts 对应的脚本命令时，查找规则是：</p>
<ol>
<li>先从当前项目的node_modules&#x2F;.bin去查找可执行命令vite</li>
<li>如果没找到就去全局的node_modules 去找可执行命令vite</li>
<li>如果还没找到就去环境变量查找</li>
<li>再找不到就进行报错</li>
</ol>
<p>因为nodejs 是跨平台的，所以需要可执行命令兼容各个平台，因此如果成功找到该脚本命令就会发现有三个文件：</p>
<ol>
<li><code>.sh</code>文件是给Linux unix Macos 使用</li>
<li><code>.cmd</code> 给windows的cmd使用</li>
<li><code>.ps1</code> 给windows的powerShell 使用</li>
</ol>
<p>脚本命令不是凭空产生的，是在package.json的<code>bin</code> 配置项中去配置的，配置完之后，当用户对该npm包进行安装时，会自动在<code>node_modules/.bin</code>中注入该脚本命令的三个可执行文件</p>
<p><strong>npm run 的生命周期：</strong></p>
<p>比如我们想要执行dev指令，那么predev和postdev将自动在dev指令执行之前和之后自动执行</p>
<pre><code>&quot;predev&quot;: &quot;node prev.js&quot;,
&quot;dev&quot;: &quot;node index.js&quot;,
&quot;postdev&quot;: &quot;node post.js&quot;
</code></pre>
<p>运用场景：</p>
<ol>
<li><code>npm run build </code>可以在打包之后删除dist目录等等</li>
<li><code>npm run post </code>编写完一个工具发布npm，那就可以在之后写一个ci脚本顺便帮你推送到git等等</li>
</ol>
<h3 id="NPX"><a href="#NPX" class="headerlink" title="NPX"></a>NPX</h3><p>npx是一个命令行工具，它是npm 5.2.0版本中新增的功能。它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包的可执行文件。具有以下优点：</p>
<ol>
<li>避免全局污染：npx允许你执行npm package，而不需要你先全局安装它</li>
<li>总是使用最新版本：如果你没有在本地安装相应的npm package，npx会从npm的package仓库中下载并使用最新版，执行完之后再把包删掉</li>
<li>执行任意npm包：npx不仅可以执行在package.json的scripts部分定义的命令，还可以执行任何npm package，甚至可以执行GitHub gist或者其他公开的JavaScript文件</li>
</ol>
<aside>
💡 `npm ls -g` 查看全局安装的可执行文件，不加`-g`就是查看当前项目


</aside>

<p><strong>npm 和 npx 区别：</strong></p>
<ol>
<li><p>npx 侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令。它有两种使用场景：</p>
<ul>
<li><p>创建一个react项目，<code>npm install -g create-react-app</code> ，将该模块安装到全局之后才能执行 <code>create-react-app my-app</code>，这样的话会有两个问题：</p>
<ol>
<li>首先需要全局安装这个包占用磁盘空间</li>
<li>如果模块需要更新还得执行更新命令</li>
</ol>
<p>因此，使用npx不仅不占用磁盘空间，而且能保证执行的命令为最新版，但是每次执行都要等待它重新下载</p>
</li>
<li><p>在本地项目中执行vite，但是我全局并没有安装vite，仅在当前项目<code>npm i vite -D</code>安装了vite，由于当前项目没有配置环境变量，因此是无法直接执行该命令的，使用<code>npx vite</code> 可以直接运行未全局安装的npm包，因为npx 的运行规则和npm 是一样的，本地目录查找<code>.bin</code> ，如果没有就去全局的node_moduels 查找，如果还没有就去下载这个包然后运行命令，然后删除这个包</p>
</li>
</ul>
</li>
<li><p>npm侧重于安装或者卸载某个模块，重在安装，并不具备执行某个模块的功能。</p>
</li>
</ol>
<h3 id="发布NPM包"><a href="#发布NPM包" class="headerlink" title="发布NPM包"></a>发布NPM包</h3><p><strong>发布npm的包的好处是什么？</strong></p>
<ol>
<li>方便团队或者跨团队共享代码，使用npm包就可以方便的管理，并且还可以进行版本控制</li>
<li>做开源造轮子必备技术，否则你做完的轮子如何让别人使用难道是U盘拷贝？</li>
<li>增加个人IP 让更多的人知道你的技术能力和贡献</li>
</ol>
<p><strong>发布工作：</strong></p>
<ol>
<li><p>首先先检查一下是否是npm源然后<code>npm adduser</code>创建一个npm账号</p>
</li>
<li><p>创建完成之后使用<code>npm login</code> 登录账号，登录之前<code>npm get registry</code>检查一下使用的是否是npm官方正版源</p>
</li>
<li><p>登录完成之后使用<code>npm publish</code> 发布当前项目的npm包，发布规则：</p>
<ul>
<li>同个包的版本不能重复</li>
<li>不能和别人使用重复包名，否则会报403</li>
<li>可以在package.json中的files配置项中指定想要发布的文件</li>
</ul>
</li>
<li><p>发布成功</p>
</li>
<li><p>管理包权限</p>
<pre><code class="bash">npm owner ls &lt;package name&gt;
npm owner add &lt;user&gt; &lt;package name&gt; 
npm owner rm &lt;user&gt; &lt;package name&gt;
</code></pre>
</li>
</ol>
<h3 id="NPM搭建私服"><a href="#NPM搭建私服" class="headerlink" title="NPM搭建私服"></a>NPM搭建私服</h3><p>我们平时发布npm包是发在npm官方的镜像源上，npm的私服则是个人仓库，基本上每个公司都会有自己的npm私服，发布一些内部包。构建npm私服的优点：</p>
<ol>
<li>可以离线使用，你可以将npm私服部署到内网集群，这样离线也可以访问私有的包。</li>
<li>提高包的安全性，使用私有的npm仓库可以更好的管理你的包，避免在使用公共的npm包的时候出现漏洞。比如公共npm包如果出现了问题，私有仓库可以选择不进行同步，维持原来版本。</li>
<li>提高包的下载速度，使用私有 npm 仓库，你可以将经常使用的 npm 包缓存到本地，从而显著提高包的下载速度，减少依赖包的下载时间。这对于团队内部开发和持续集成、部署等场景非常有用。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://verdaccio.org/">如何搭建npm 私服</a></p>
<p>Verdaccio 是可以帮我们快速构建npm私服的一个工具，安装好依赖之后直接运行即可</p>
<pre><code class="jsx">npm install verdaccio -g
</code></pre>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7261872148213415994">具体过程参照</a></p>
<h2 id="什么是模块化？"><a href="#什么是模块化？" class="headerlink" title="什么是模块化？"></a><strong>什么是模块化？</strong></h2><p>概括：模块化的目的是当系统的规模和复杂度上升后，将代码拆分成多个独立、可重用的单元，<u>提升代码的复用性，避免全局变量污染</u></p>
<p>阐述：将一些共有或者私有的变量和方法封装为一个模块后导出，来让别的模块引用。每个模块都具有特定的功能和职责，并且可以与其他模块进行交互。</p>
<p>总结：一个模块的基本内容是：依赖的模块、自己要做的事情、要导出的变量&#x2F;方法</p>
<h3 id="es6和commonJS区别"><a href="#es6和commonJS区别" class="headerlink" title="es6和commonJS区别"></a>es6和commonJS区别</h3><p>ES6 module <u>静态编译时加载</u>，输出的是接口，CommonJS <u>动态运行时加载</u>，加载的是一个对象</p>
<p>ES6 module支持异步加载，浏览器中会用到该特性，而CommonJS是不支持异步的，因为服务器端不需要异步加载。所以CommonJS不可替代ES6 module，ES6 module可以替代CommonJS。</p>
<ol>
<li><p><strong>语法</strong>：</p>
<ul>
<li>ES6 使用 <code>import</code> 和 <code>export</code> 关键字来导入和导出模块，更简洁直观。</li>
<li>CommonJS 使用 <code>require()</code> 函数来导入模块，并使用 <code>module.exports</code> 或 <code>exports</code> 对象来导出模块。</li>
</ul>
</li>
<li><p><strong>静态与动态</strong>：</p>
<ul>
<li><p>ES6 模块是静态的，这意味着模块的依赖关系在编译时就确定了，模块会在文件执行之前被加载和执行。但 ES6 也支持异步加载（如动态 <code>import()</code>）。这意味着模块的加载不会阻塞后续代码的执行，而是会返回一个Promise，该Promise在模块加载完成后才会被解析，因此，它也可以实现类似 CommonJS 的实现方式。</p>
<pre><code class="jsx">import(&#39;./a.js&#39;).then(res=&gt;console.log(&quot;success&quot;))
</code></pre>
</li>
<li><p>CommonJS 模块是动态的，它在运行时解析模块的依赖关系，因此可能会导致一些运行时的开销。当一个模块被引入时，它会立即执行并且等待加载完成，然后才继续执行后续代码。比如，以下写法在 CommonJS 中是支持的：</p>
<pre><code class="jsx">if(true)&#123; require(&#39;./a.js&#39;) &#125;
</code></pre>
<p>但如果文件过大时，加载过多模块会导致下面的代码被阻塞。</p>
</li>
</ul>
</li>
<li><p><strong>缓存</strong>：</p>
<ul>
<li>ES6 模块的导入是单例模式，也就是说，一个模块只会被加载和执行一次，后续的导入都会返回同一个实例。</li>
<li>CommonJS 模块的导入是值拷贝，每次导入都会创建一个新的实例。</li>
</ul>
</li>
<li><p><strong>浏览器和Node.js兼容性</strong>：</p>
<ul>
<li>ES6 模块的兼容性在浏览器中逐渐提升，但在Node.js中还需要使用 <code>-experimental-modules</code> 标志启用（虽然现在Node.js已经支持ES6模块作为稳定特性）。</li>
<li>CommonJS 主要在Node.js环境中使用，并已被广泛接受和支持。</li>
</ul>
</li>
<li><p><strong>其他：</strong></p>
<ul>
<li>CommonJS 中顶层的 this 指向这个模块本身，而 ES6 中顶层 this 指向 undefined</li>
<li>CommonJS 是可以修改模块值的，esm值并且不可修改（可读的）</li>
<li>CommonJS 不可以tree shaking，esm支持tree shaking，因为在esm在编译阶段已经知道需要知道那些模块了。</li>
</ul>
</li>
</ol>
<h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><blockquote>
<p><em>将package.json中的<code>type</code>配置项设置为<code>commonjs</code>，表示支持该规范</em></p>
</blockquote>
<p><strong>模块引入：</strong></p>
<p>CommonJs规范引入模块（require）支持四种格式</p>
<ol>
<li><p>支持引入内置模块例如 <code>http</code> <code>os</code> <code>fs</code> <code>child_process</code> 等nodejs内置模块</p>
<pre><code class="jsx">const fs = require(&#39;node:fs&#39;)
</code></pre>
</li>
<li><p>支持引入第三方模块<code>express</code> <code>md5</code> <code>koa</code> 等</p>
<pre><code class="jsx">const md5 = require(&#39;md5&#39;)
md5(&#39;123&#39;) //加密
</code></pre>
</li>
<li><p>支持引入自己编写的模块，用路径形式 .&#x2F; ..&#x2F; 等引入</p>
<pre><code class="jsx">require(&#39;./test.js&#39;)
</code></pre>
</li>
<li><p>支持引入addon C++扩展模块 .node文件</p>
<pre><code>const nodeModule = require(&#39;./myModule.node&#39;);  // 导入扩展模块
</code></pre>
</li>
<li><p>支持引入JSON文件</p>
<pre><code class="jsx">const data = require(&#39;./data.json&#39;)
</code></pre>
</li>
</ol>
<p><strong>模块导出：</strong>   </p>
<p>使用<code>module.exports=&#123;&#125;</code>的形式将导出为一个对象                                                                                                                                                                                                                                                                                                                                                                           </p>
<pre><code>module.exports = &#123;
    success: 1,
    hello: function() &#123;
    console.log(&#39;Hello, world!&#39;);
  &#125;
&#125;;
</code></pre>
<p>可以使用es6的解构赋值，直接拿到对象中的属性或方法</p>
<pre><code class="jsx">const &#123;success&#125; = require(&#39;./test.js&#39;)
</code></pre>
<h3 id="ESM模块规范"><a href="#ESM模块规范" class="headerlink" title="ESM模块规范"></a>ESM模块规范</h3><blockquote>
<p><em>将package.json中的<code>type</code>配置项设置为<code>mo</code>dule，表示支持该规范</em></p>
</blockquote>
<p><strong>模块引入：</strong></p>
<ul>
<li><p>如果想查看模块内的全部内容，可以通过<code>as all</code>来加载模块的整体对象</p>
<pre><code>import * as all from &#39;xxx.js&#39;
</code></pre>
</li>
</ul>
<p>动态导入模块</p>
<p>import静态加载不支持掺杂在逻辑中如果想动态加载请使用import函数模式</p>
<pre><code>if(true)&#123;
    import(&#39;./test.js&#39;).then()
&#125;
</code></pre>
<p><strong>模块导出：</strong></p>
<ul>
<li>导出的默认对象只能有一个，不可重复export default</li>
</ul>
<pre><code>export default &#123;
    name: &#39;test&#39;
&#125;
</code></pre>
<ul>
<li>导出变量</li>
</ul>
<pre><code class="javascript">export const a = 1
</code></pre>

             -->
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2024/04/27/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/git.png" data-sizes="auto" alt="git使用指南" class="lazyload">
                    <h1>git使用指南</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年04月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 18 分钟</a>
        </div>
        
        <article>
            <!-- 
                <p><a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a>是目前世界上最先进的分布式版本控制系统：</p>
<ul>
<li><strong>版本控制系统：</strong> 记录文件的变化，以便进行追踪和管理</li>
<li><strong>分布式系统：</strong> 意味着包括版本历史的整个代码仓库不仅存储在中央服务器上，而且每个开发者的本地机器上也有完整的复制</li>
</ul>
<hr>
<h2 id="本地-Git-操作"><a href="#本地-Git-操作" class="headerlink" title="本地 Git 操作"></a>本地 Git 操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>当使用 <code>git init</code> 命令时，Git 会在当前目录下创建一个新的 <code>.git</code> 目录。这个目录是 Git 仓库的核心，包含了所有的版本控制信息，如提交历史、分支、标签等。并且默认进入 Git 仓库的master分支，即主分支。该分支为空，需要对文件手动进行追踪。</p>
<h3 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h3><p>Git 会跟踪你添加到仓库中的文件，你可以使用 <code>git add</code> 命令将文件添加到暂存区，然后使用 <code>git commit</code> 命令将暂存区的更改提交到仓库中。</p>
<ol>
<li><p><strong>跟踪与忽略</strong>：Git 默认会跟踪添加到暂存区的所有文件。但是，你可以通过 <code>.gitignore</code> 文件来指定 Git 应该忽略哪些文件或目录。这通常用于排除自动生成的文件、临时文件或敏感信息。</p>
</li>
<li><p><strong>未跟踪文件</strong>：对于你未使用 <code>git add</code> 添加的文件，Git 会将它们视为未跟踪文件。这些文件不会出现在 Git 的版本控制中，除非你显式地将它们添加到暂存区。</p>
</li>
<li><p><strong>已跟踪文件的更改</strong>：对于已经添加到 Git 仓库并被跟踪的文件，任何对它们的更改都会被 Git 记录下来。</p>
<ul>
<li><p><strong>查看工作目录与暂存区的差异</strong>：</p>
<pre><code class="bash">git status
</code></pre>
<p>该命令同时也可以查看该文件夹是否为Git仓库。</p>
</li>
<li><p><strong>查看工作目录与最后一次提交的差异</strong>：</p>
<pre><code class="bash">git diff HEAD
</code></pre>
</li>
<li><p><strong>查看暂存区与最后一次提交的差异</strong>：</p>
<pre><code class="bash">git diff --cached
</code></pre>
<p>或者在新版本的 Git 中，也可以使用：</p>
<pre><code class="bash">git diff --staged
</code></pre>
</li>
<li><p><strong>查看工作目录与远程仓库的差异</strong>：</p>
<p>如果你已经使用 <code>git fetch</code> 从远程仓库<code>origin</code>获取了最新更新的<code>master</code> 分支，但还没有合并或拉取这些更新到你的当前工作分支，并且你想要查看远程仓库和当前工作目录之间的差异，你可以使用 <code>git diff</code> 命令结合特定的引用。</p>
<pre><code class="bash">git diff origin/master
</code></pre>
<p>如果你想要比较的是你的当前分支（比如你本地的 <code>feature-branch</code>）和远程仓库的对应分支（比如 <code>origin/feature-branch</code>），你可以这样做：</p>
<pre><code class="bash">git diff feature-branch..origin/feature-branch
</code></pre>
<p>或者，如果你只关心哪些提交在远程分支上但不在你的当前分支上，你可以使用三个点的语法：</p>
<pre><code class="bash">git diff feature-branch...origin/feature-branch
</code></pre>
<p>这将显示 <code>origin/feature-branch</code> 上有而 <code>feature-branch</code> 上没有的提交所引入的更改。</p>
</li>
</ul>
</li>
</ol>
<h3 id="记录更改或版本回退"><a href="#记录更改或版本回退" class="headerlink" title="记录更改或版本回退"></a>记录更改或版本回退</h3><p>每次提交时，Git 都会记录你对文件的更改。这些更改以快照的形式保存，包含了文件在提交时的完整状态。</p>
<p>Git 提供了强大的历史查看功能，你可以使用 <code>git log</code> 命令查看提交历史，包括每次提交的哈希值、作者、日期、消息和更改的文件，通过历史记录可以进行版本回退。</p>
<ul>
<li><p><strong>查看历史</strong></p>
<p>如果你只想要显示每个提交的哈希值和提交信息，可以使用 <code>--oneline</code> 选项：</p>
<pre><code class="bash">git log --oneline
</code></pre>
</li>
<li><p><strong>搜索历史记录</strong></p>
<p>使用 <code>git log</code> 的搜索功能可以快速定位特定的提交。例如，在执行 <code>git commit -m</code> 命令时输入的提交信息通常与某个特定功能、修复或更改相关，搜索包含该信息的提交：</p>
<pre><code class="bash">git log --oneline --grep=&quot;your-search-text&quot;
</code></pre>
</li>
<li><p><strong>硬回退</strong></p>
<p>如果你想要完全回退到某个提交，并且丢弃该提交之后的所有更改，你可以使用 <code>git reset</code> 命令。这通常被称为“硬回退”，因为它会改变你的工作目录和暂存区以匹配目标提交，并且改变历史记录。</p>
<pre><code class="bash">git reset --hard &lt;commit-hash&gt;
</code></pre>
<aside>
💡 警告：这个操作会丢失目标提交之后的所有更改，所以请确保你真的想要这么做。

</aside>
</li>
<li><p><strong>软回退</strong></p>
<p>如果你想要创建一个新的提交来撤销之前的某个提交，但保留那个提交的历史记录，你可以使用 <code>git revert</code> 命令。这通常被称为“软回退”，因为它不会改变历史记录，而是添加一个新的提交来撤销之前的更改。</p>
<pre><code class="bash">git revert &lt;commit-hash&gt;
</code></pre>
<p>这将创建一个新的提交，该提交的内容是目标提交的反向更改。然后，你可以像平常一样提交这个新的更改。</p>
</li>
</ul>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a><strong>撤销操作</strong></h3><ul>
<li><p><strong>撤销暂存区的更改</strong></p>
<pre><code class="bash">git reset HEAD &lt;file&gt;
</code></pre>
<p>这里的 <code>&lt;file&gt;</code> 是你想要撤销暂存的文件名或目录名。这条命令会将指定的文件从暂存区移除，但保留在工作区中的更改（不改变当前工作目录中的内容）。之后，你可以再次对文件进行修改，然后使用 <code>git add</code> 命令重新将文件添加到暂存区。</p>
<p>如果你想要撤销所有暂存区的更改，可以使用：</p>
<pre><code class="bash">git reset HEAD
</code></pre>
<p>注意，这不会改变工作区中的文件，只会影响暂存区。</p>
</li>
<li><p><strong>版本回退</strong></p>
<p>另一个选择是使用 <code>git checkout</code> 命令，这个命令可以将文件恢复到最近一次提交的状态。</p>
<pre><code class="bash">git checkout -- &lt;file&gt;
</code></pre>
<p>这条命令会将指定的文件从暂存区和工作区都恢复到最近一次提交的状态，这会丢弃你对该文件的所有未提交更改。请小心使用此命令，因为它会丢失未提交的更改。</p>
</li>
<li><p><strong>恢复暂存区的文件</strong></p>
<p>如果你的 Git 版本是 2.23 或更高，可以使用 <code>git restore</code> 命令来恢复暂存区的文件。</p>
<pre><code class="bash">git restore --staged &lt;file&gt;
</code></pre>
<p>这条命令会将指定的文件从暂存区移除，但保留在工作区中的更改。与 <code>git reset</code> 的效果类似，但它提供了更清晰的语义。</p>
</li>
</ul>
<hr>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>首先，你必须要有一个远程仓库，一般在 GitHub、GitLab 或其他 Git 托管服务上，以Github为例，需要申请一个账户，如果以后我们要在 GitHub 上搭建自己的个人博客，其默认地址就是username.github.io。</p>
<h3 id="GitHub-术语解释"><a href="#GitHub-术语解释" class="headerlink" title="GitHub 术语解释"></a><strong>GitHub 术语解释</strong></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369486197">Repository</a>：简称Repo，可以理解为“仓库”，一个仓库存放一个项目。也就是说，如果我们想要建立项目，就得先建立仓库；有多个项目，就建立多个仓库。</p>
<p><strong>Issues</strong>：可以理解为“问题”，举一个简单的例子，如果我们开源一个项目，如果别人看了我们的项目，并且发现了bug，或者感觉那个地方有待改进，他就可以给我们提出Issue，等我们把Issues解决之后，就可以把这些Issues关闭；反之，我们也可以给他人提出Issue。</p>
<p><strong>Star</strong>：可以理解为“点赞”，当我们感觉某一个项目做的比较好之后，就可以为这个项目点赞，而且我们点赞过的项目，都会保存到我们的Star之中，方便我们随时查看。</p>
<p><strong>Fork</strong>：可以理解为“拉分支”，如果我们对某一个项目比较感兴趣，并且想在此基础之上开发新的功能，这时我们就可以Fork这个项目，这表示复制一个完全相同的项目到我们的 GitHub 账号之中，而且独立于原项目。之后，我们就可以在自己复制的项目中进行开发了。</p>
<p><strong>Pull Request</strong>：可以理解为“提交请求”，此功能是建立在Fork之上的，如果我们Fork了一个项目，对其进行了修改，而且感觉修改的还不错，我们就可以对原项目的拥有者提出一个Pull请求，等其对我们的请求审核，并且通过审核之后，就可以把我们修改过的内容合并到原项目之中，这时我们就成了该项目的贡献者。</p>
<p><strong>Merge：</strong>可以理解为“合并”，如果别人Fork了我们的项目，对其进行了修改，并且提出了Pull请求，这时我们就可以对这个Pull请求进行审核。如果这个Pull请求的内容满足我们的要求，并且跟我们原有的项目没有冲突的话，就可以将其合并到我们的项目之中。当然，是否进行合并，由我们决定。</p>
<p><strong>Watch：</strong>可以理解为“观察”，如果我们Watch了一个项目，之后，如果这个项目有了任何更新，我们都会在第一时候收到该项目的更新通知。</p>
<p><strong>Gist：</strong>Github中的Gist是一个子服务，它允许用户在线分享和存储较小的代码片段、笔记、错误信息等内容。例如，你正在解决一个具体的编程问题，并找到了一个简洁的代码片段来解决这个问题。你可以将这个代码片段复制并粘贴到Gist中，然后通过链接的方式分享给其他人。其他人可以直接点击链接查看你的代码片段，而无需下载整个项目或仓库。</p>
<h3 id="利用-SSH-完成-Git-与-GitHub-的绑定"><a href="#利用-SSH-完成-Git-与-GitHub-的绑定" class="headerlink" title="利用 SSH 完成 Git 与 GitHub 的绑定"></a><strong>利用 SSH 完成 Git 与 GitHub 的绑定</strong></h3><p><strong>第 1 步：生成 SSH key</strong></p>
<p>我们要想生成SSH key，首先就得先安装 SSH，对于 Linux 和 Mac 系统，其默认是安装 SSH 的，而对于 Windows 系统，其默认是不安装 SSH 的，不过由于我们安装了 Git Bash，应该也自带了 SSH。可以通过在 Git Bash 中输入<code>ssh</code>命令，查看本机是否安装 SSH。</p>
<p>接下来，输入<code>ssh-keygen -t rsa</code>命令，表示我们指定 RSA 算法生成密钥，之后就就会生成两个文件，分别为密钥id_rsa和公钥id_rsa.pub。</p>
<p><strong>第 2 步：添加 SSH key</strong></p>
<p>密钥和公钥生成之后，需要把公钥id_rsa.pub的内容添加到 GitHub的SSH keys中，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦。</p>
<p><strong>第 3 步：验证绑定是否成功</strong></p>
<p>在我们添加完SSH key之后，可以通过在 Git Bash 中输入<code>ssh -T git@github.com</code>进行测试，如果显示授权成功，则表示Git 与 GitHub 已经绑定，这意味着我们已经可以通过 Git 向 GitHub 提交代码啦！</p>
<p><strong>第 4 步：Git本地登录</strong></p>
<p>设置或切换本地登录的账号：</p>
<pre><code class="bash">git config --global user.name &quot;用户名&quot;
git config --global user.email &quot;邮箱&quot;
</code></pre>
<p>查看本地已登录的账号：</p>
<pre><code class="bash">git config --list
git config user.name
git config user.email
</code></pre>
<aside>
💡 当前版本的Github需要输入的密码不是用户登录密码，而是access tokens


</aside>

<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a><strong>分支操作</strong></h3><p>在进行任何的git操作之前，都得先切换到 Git 的仓库最顶层目录，然后从此目录中进入 Git Bash，这样之后的操作才能顺利进行。</p>
<ol>
<li><strong>查看分支</strong>：<ul>
<li><code>git branch</code>：查看当前仓库中的所有分支，以及当前所在的分支（显示为带有星号*的分支）。</li>
<li><code>git branch -r</code>：查看远程分支。</li>
<li><code>git branch -a</code>：查看本地和远程分支。</li>
</ul>
</li>
<li><strong>创建分支</strong>：<ul>
<li><code>git branch &lt;branch-name&gt;</code>：创建一个新的分支，将<code>&lt;branch-name&gt;</code>替换为您要创建的分支的名称。</li>
</ul>
</li>
<li><strong>切换分支</strong>：<ul>
<li><code>git checkout &lt;branch-name&gt;</code>：切换到新创建的分支，将<code>&lt;branch-name&gt;</code>替换为要切换的分支的名称。</li>
</ul>
</li>
<li><strong>删除分支</strong>：<ul>
<li><code>git branch -d &lt;branch-name&gt;</code>：删除本地分支，如果分支上有未合并的修改，Git会提示你进行确认。</li>
<li><code>git branch -D &lt;branch-name&gt;</code>：强制删除本地分支。</li>
<li><code>git push &lt;remote_name&gt; --delete &lt;branch_name&gt;</code>：删除远程分支，其中<code>&lt;remote_name&gt;</code>是你的远程仓库的名称，<code>&lt;branch_name&gt;</code>是你要删除的分支的名称。</li>
</ul>
</li>
<li><strong>合并分支</strong>：<ul>
<li><code>git merge &lt;branch-name&gt;</code>：将指定分支合并到当前分支。例如，如果你在master分支上，想要合并dev分支，可以使用<code>git merge dev</code>。</li>
<li>如果只想合并指定分支上的某个提交，可以使用<code>git cherry-pick &lt;commit-hash&gt;</code>。</li>
</ul>
</li>
</ol>
<h3 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h3><ol>
<li><p><strong>添加远程仓库：</strong>将文件添加到暂存区并提交暂存区中的更改后，想要推送到远程仓库，需要使用 <code>git remote add</code> 命令将Github远程仓库添加进来。</p>
<pre><code class="bash">git remote add origin &lt;repository-url&gt;
</code></pre>
<p>通常，<code>origin</code> 是远程仓库的默认名称。</p>
</li>
<li><p><strong>推送本地分支到远程仓库</strong>：</p>
<pre><code class="bash">git push -u origin master
</code></pre>
<p><code>-u</code> 或 <code>--set-upstream</code> 选项用于设置本地分支跟踪远程分支，这样在以后的推送和拉取操作中，Git 会知道对应的远程分支是什么。</p>
</li>
<li><p><strong>验证推送</strong>：</p>
<p>推送完成后，登录到你的远程仓库（<a target="_blank" rel="noopener" href="https://github.com/">GitHub</a> 或 <a target="_blank" rel="noopener" href="https://gitlab.com/">GitLab</a>），检查是否已经看到了你推送的代码。</p>
</li>
</ol>
<h3 id="合作开发"><a href="#合作开发" class="headerlink" title="合作开发"></a>合作开发</h3><p>加入一个项目后，需要先通过<code>git clone</code>命令克隆项目的远程仓库到本地，接下来通常需要执行以下步骤：</p>
<ol>
<li><p><strong>运行<code>npm install</code>来安装依赖</strong></p>
</li>
<li><p><strong>配置开发环境</strong>：根据项目需求，配置你的开发环境，比如设置环境变量、安装数据库、配置API密钥等。</p>
</li>
<li><p><strong>了解项目的分支策略</strong>：<code>git branch</code> 查看项目分支，通常会基于某个特定的分支（如<code>dev</code>或<code>feature</code>）创建一个新的功能分支来进行开发工作。</p>
</li>
<li><p><strong>创建并切换到新的分支</strong>：为了开发新功能或修复bug，你应该创建一个新的分支。这样做可以保持主分支的干净，并且允许你的工作在被合并之前进行审查和测试。</p>
<pre><code class="bash">git checkout -b feature/your-feature-name
</code></pre>
</li>
<li><p><strong>进行开发工作</strong></p>
</li>
<li><p><strong>提交更改</strong>：当你想要推送本地提交到远程仓库之前，需要确保你的本地仓库与远程仓库同步，以避免潜在的合并冲突。以下是推荐的步骤：</p>
<p><strong>第 1 步：更新本地仓库</strong></p>
<p>获取远程仓库的最新更改，防止覆盖别人的代码或者产生冲突。</p>
<pre><code class="bash">git pull origin feature
</code></pre>
<p><strong>第 2 步：解决冲突</strong></p>
<p>在当前目录中查看拉取到的代码，检查是否有冲突，如果存在冲突，解决之后需要使用<code>git add</code>和<code>git commit</code>重新提交。</p>
<p><strong>第 3步：推送更改到远程仓库</strong></p>
<pre><code class="bash">git push -u origin feature/your-feature-name
</code></pre>
</li>
<li><p><strong>创建合并请求（Pull Request）</strong>：</p>
<p>在你的代码推送到远程仓库后，你通常需要创建一个合并请求（Pull Request，简称PR），以便项目维护者可以审查你的代码并决定是否将其合并到主分支。</p>
</li>
<li><p><strong>参与代码审查</strong>：</p>
<p>等待其他开发者的反馈，并根据需要进行修改。这是一个协作过程，所以请保持开放和积极的态度对待他人的建议和评论。</p>
</li>
<li><p><strong>等待合并</strong>：</p>
<p>一旦你的PR通过了审查并且所有问题都得到了解决，项目维护者会将你的更改合并到主分支中。此时，你的贡献就已经成为了项目的一部分！</p>
</li>
</ol>
<hr>
<h2 id="Git相关错误处理"><a href="#Git相关错误处理" class="headerlink" title="Git相关错误处理"></a>Git相关错误处理</h2><h3 id="修改Git的网络设置"><a href="#修改Git的网络设置" class="headerlink" title="修改Git的网络设置"></a>修改Git的网络设置</h3><p>当我们访问GitHub的时候一般都会使用梯子，所以往上推代码的时候也是需要梯子，没有梯子推送成功概率很低，一般都会报错443超时，所以设置梯子提高访问成功率；这通常在你的<code>~/.gitconfig</code>文件中完成，或者你可以使用<code>git config</code>命令直接设置。</p>
<p>使用<code>git config</code>命令设置全局代理：</p>
<pre><code class="bash">git config --global http.proxy http://your-proxy-url:port
git config --global https.proxy https://your-proxy-url:port
# 比如git config --global https.proxy &#39;http://192.168.0.1:1080&#39;
</code></pre>
<p>取消代理是因为，访问 Gitee 或其他托管网站不需要梯子，所以要取消代理；</p>
<pre><code class="bash"># 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy

# 查看代理
git config --global --get http.proxy
git config --global --get https.proxy
</code></pre>
<h3 id="git-的-https-链接无法交互"><a href="#git-的-https-链接无法交互" class="headerlink" title="git 的 https 链接无法交互"></a>git 的 https 链接无法交互</h3><p>当出现<code>The requested URL returned error: 403</code>问题，可能是因为电脑缓存了github 用户名和密码，储存方式有缓存cache，保存在硬盘store，和钥匙串osxkeychain中。当想要使用别的Github账户时，就会出现报错的情况。因此需要清空配置，重新输入账户和密码。</p>
<pre><code class="bash">git config credential.helper //查看本机的credential 是否已经被清空。
</code></pre>
<p>如果输入了<code>git config credential.helper</code>命令之后还是出现了osxkeychain， store 或者 cache 等，说明 git 的配置还是没有被清空。使用以下命令查看 credential.helper 所在的文件目录，手动清空里面的内容。</p>
<pre><code class="bash">git config --show-origin --get credential.helper  
# 查看 credential.helper 所在的文件目录
</code></pre>
<p>如果都删除还是不行，找到缓存所在目录的.git-credentials 文件，删除，防止系统自动去那里寻找用户名密码。重新配置，配置成store：</p>
<pre><code class="bash">git  config --global  credential.helper  store 
</code></pre>
<p>再进行push时，会提示输入用户名密码，输入完成之后&#x2F;Users&#x2F;xxx&#x2F; 文件夹下会生成一个新的文件.git-credentials，里面保存了你的用户名密码等信息。</p>

             -->
        </article>
    </div>
    
</section>


        <div class="nexmoe-post-right">
          
            <div class="nexmoe-fixed">
              <div class="nexmoe-tool">
                <a href="#" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
              </div>
            </div>
          
        </div>
    </div>
  </div>
  <div id="nexmoe-pendant">
    <div class="nexmoe-drawer mdui-drawer nexmoe-pd" id="drawer">
        
            <div class="nexmoe-pd-item">
                <div class="clock">
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="needle" id="hours"></div>
        <div class="needle" id="minutes"></div>
        <div class="needle" id="seconds"></div>
        <div class="clock_logo">

        </div>

    </div>
<style>
    .clock {
        background-color: #ffffff;
        width: 70vw;
        height: 70vw;
        max-width: 70vh;
        max-height: 70vh;
        border: solid 2.8vw #242424;
        position: relative;
        overflow: hidden;
        border-radius: 50%;
        box-sizing: border-box;
        box-shadow: 0 1.4vw 2.8vw rgba(0, 0, 0, 0.8);
        zoom:0.2
    }

    .memory {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .memory:nth-child(1) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(0deg) translateY(-520%);
    }

    .memory:nth-child(2) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(6deg) translateY(-1461%);
    }

    .memory:nth-child(3) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(12deg) translateY(-1461%);
    }

    .memory:nth-child(4) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(18deg) translateY(-1461%);
    }

    .memory:nth-child(5) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(24deg) translateY(-1461%);
    }

    .memory:nth-child(6) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(30deg) translateY(-520%);
    }

    .memory:nth-child(7) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(36deg) translateY(-1461%);
    }

    .memory:nth-child(8) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(42deg) translateY(-1461%);
    }

    .memory:nth-child(9) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(48deg) translateY(-1461%);
    }

    .memory:nth-child(10) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(54deg) translateY(-1461%);
    }

    .memory:nth-child(11) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(60deg) translateY(-520%);
    }

    .memory:nth-child(12) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(66deg) translateY(-1461%);
    }

    .memory:nth-child(13) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(72deg) translateY(-1461%);
    }

    .memory:nth-child(14) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(78deg) translateY(-1461%);
    }

    .memory:nth-child(15) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(84deg) translateY(-1461%);
    }

    .memory:nth-child(16) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(90deg) translateY(-520%);
    }

    .memory:nth-child(17) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(96deg) translateY(-1461%);
    }

    .memory:nth-child(18) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(102deg) translateY(-1461%);
    }

    .memory:nth-child(19) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(108deg) translateY(-1461%);
    }

    .memory:nth-child(20) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(114deg) translateY(-1461%);
    }

    .memory:nth-child(21) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(120deg) translateY(-520%);
    }

    .memory:nth-child(22) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(126deg) translateY(-1461%);
    }

    .memory:nth-child(23) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(132deg) translateY(-1461%);
    }

    .memory:nth-child(24) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(138deg) translateY(-1461%);
    }

    .memory:nth-child(25) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(144deg) translateY(-1461%);
    }

    .memory:nth-child(26) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(150deg) translateY(-520%);
    }

    .memory:nth-child(27) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(156deg) translateY(-1461%);
    }

    .memory:nth-child(28) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(162deg) translateY(-1461%);
    }

    .memory:nth-child(29) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(168deg) translateY(-1461%);
    }

    .memory:nth-child(30) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(174deg) translateY(-1461%);
    }

    .memory:nth-child(31) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(180deg) translateY(-520%);
    }

    .memory:nth-child(32) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(186deg) translateY(-1461%);
    }

    .memory:nth-child(33) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(192deg) translateY(-1461%);
    }

    .memory:nth-child(34) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(198deg) translateY(-1461%);
    }

    .memory:nth-child(35) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(204deg) translateY(-1461%);
    }

    .memory:nth-child(36) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(210deg) translateY(-520%);
    }

    .memory:nth-child(37) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(216deg) translateY(-1461%);
    }

    .memory:nth-child(38) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(222deg) translateY(-1461%);
    }

    .memory:nth-child(39) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(228deg) translateY(-1461%);
    }

    .memory:nth-child(40) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(234deg) translateY(-1461%);
    }

    .memory:nth-child(41) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(240deg) translateY(-520%);
    }

    .memory:nth-child(42) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(246deg) translateY(-1461%);
    }

    .memory:nth-child(43) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(252deg) translateY(-1461%);
    }

    .memory:nth-child(44) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(258deg) translateY(-1461%);
    }

    .memory:nth-child(45) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(264deg) translateY(-1461%);
    }

    .memory:nth-child(46) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(270deg) translateY(-520%);
    }

    .memory:nth-child(47) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(276deg) translateY(-1461%);
    }

    .memory:nth-child(48) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(282deg) translateY(-1461%);
    }

    .memory:nth-child(49) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(288deg) translateY(-1461%);
    }

    .memory:nth-child(50) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(294deg) translateY(-1461%);
    }

    .memory:nth-child(51) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(300deg) translateY(-520%);
    }

    .memory:nth-child(52) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(306deg) translateY(-1461%);
    }

    .memory:nth-child(53) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(312deg) translateY(-1461%);
    }

    .memory:nth-child(54) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(318deg) translateY(-1461%);
    }

    .memory:nth-child(55) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(324deg) translateY(-1461%);
    }

    .memory:nth-child(56) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(330deg) translateY(-520%);
    }

    .memory:nth-child(57) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(336deg) translateY(-1461%);
    }

    .memory:nth-child(58) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(342deg) translateY(-1461%);
    }

    .memory:nth-child(59) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(348deg) translateY(-1461%);
    }

    .memory:nth-child(60) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(354deg) translateY(-1461%);
    }

    .needle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .needle#hours {
        background-color: #1f1f1f;
        width: 4%;
        height: 30%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#hours.moving {
        transition: transform 150ms ease-out;
    }

    .needle#hours:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#minutes {
        background-color: #1f1f1f;
        width: 2%;
        height: 45%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#minutes.moving {
        transition: transform 150ms ease-out;
    }

    .needle#minutes:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#seconds {
        background-color: #cb2f2f;
        width: 1%;
        height: 50%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#seconds.moving {
        transition: transform 150ms ease-out;
    }

    .needle#seconds:after {
        content: '';
        background-color: #cb2f2f;
        width: 2.5vw;
        height: 2.5vw;
        max-width: 2.5vh;
        max-height: 2.5vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }
    .clock_logo{
        width: 10vw;
        height: 10vw;
        max-width: 10vh;
        max-height: 10vh;
        position: absolute;
        top: 50%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
    @media (min-width: 100vh) {
        .clock {
            border: solid 2.8vh #242424;
            box-shadow: 0 1.4vh 2.8vh rgba(0, 0, 0, 0.8);
        }
    }

</style>





            </div>
        
            <div class="nexmoe-pd-item">
                <div class="qweather" >
    <div id="he-plugin-standard"></div>
    <div class="qweather-logo">

    </div>

</div>
<style>
    .qweather{
        position: relative;
    }
    .qweather-logo{
        position: absolute;
        right: 0;
        top: -15px;
        width: 40px;
        height: 40px;
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
</style>
<script>
  WIDGET = {
    "CONFIG": {
      "layout": "2",
      "width": "260",
      "height": "220",
      "background": "5",
      "dataColor": "e67249",
      "borderRadius": "15",
      "key": "f74d1e1690e6432d801e97fa2f05a162"
    }
  }
</script>
<script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script>

            </div>
        
</div>
<style>
    .nexmoe-pd {
        left: auto;
        top: 40px;
        right: 0;
    }
    .nexmoe-pd-item{
       display: flex;
        justify-content: center;
        margin-bottom: 30px;
    }
</style>

  </div>
  <script src="https://lib.baomitu.com/lazysizes/5.1.0/lazysizes.min.js"></script>
<script src="https://lib.baomitu.com/highlight.js/10.0.0/highlight.min.js"></script>
<script src="https://lib.baomitu.com/mdui/0.4.3/js/mdui.min.js"></script>

<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://lib.baomitu.com/jquery/3.5.1/jquery.slim.min.js"></script>
<script src="/lib/fancybox/js/jquery.fancybox.min.js"></script>


<script src="/js/app.js?v=1720102878667"></script>

<script src="https://lib.baomitu.com/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





<!-- hexo injector body_end start -->
<script src="/js/clock.js"></script>

<script src="https://lib.baomitu.com/clipboard.js/2.0.8/clipboard.min.js"></script>

<script src="/lib/codeBlock/codeBlockFuction.js"></script>

<script src="/lib/codeBlock/codeLang.js"></script>

<script src="/lib/codeBlock/codeCopy.js"></script>

<script src="/lib/codeBlock/codeShrink.js"></script>

<link rel="stylesheet" href="/lib/codeBlock/matery.css">

<script src="https://code.jquery.com/jquery-3.6.0.js"></script>

<script src="/js/search.js"></script>

<script src="/js/webapp.js"></script>
<!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"rect":{"opacity":0.7},"position":"relative","z-index":1,"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/250cb4aa.js","daovoice")</script>
<script>
  daovoice('init', {
    app_id: "250cb4aa"
  });
  daovoice('update');
</script>

