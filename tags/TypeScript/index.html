<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />
  <title>标签：TypeScript - 卷不过没事了</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

    <!-- Site Verification -->
    <meta name="baidu-site-verification" content="code-J1Qg17G6wT" />

  <link rel="shortcut icon" href="/images/head/head.jpg" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="卷不过没事了">
<meta property="og:url" content="http://example.com/tags/TypeScript/index.html">
<meta property="og:site_name" content="卷不过没事了">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Talita">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://lib.baomitu.com/highlight.js/9.15.8/styles/atom-one-dark.min.css" crossorigin>
  <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css">
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css">
  <link rel="stylesheet" href="/lib/fancybox/css/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://lib.baomitu.com/justifiedGallery/3.8.1/css/justifiedGallery.min.css">
  
    <link rel="stylesheet" href="//at.alicdn.com/t/font_2421060_8z08qcz5sq3.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1719645310161">
<meta name="generator" content="Hexo 7.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/background/xiaomai.png)"></div>
    <div class="nexmoe-small" style="background-image: url(/images/background/lihui.png)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Talita" class="mdui-btn mdui-btn-icon"><img src="/images/head/me.jpeg" alt="Talita"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Talita">
            <img src="/images/head/me.jpeg" alt="Talita" alt="Talita">
        </a>
    </div>
    <div class="nexmoe-count">
        <div class="nexmoe-count-item"><span>文章</span>7 <div class="item-radius"></div><div class="item-radius item-right"></div> </div>
        <div class="nexmoe-count-item"><span>标签</span>5<div class="item-radius"></div><div class="item-radius item-right"></div></div>
        <div class="nexmoe-count-item"><span>分类</span>5<div class="item-radius"></div><div class="item-radius item-right"></div></div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="首页">
            <i class="mdui-list-item-icon nexmoefont icon-meishi"></i>
            <div class="mdui-list-item-content">
                首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives.html" title="归档">
            <i class="mdui-list-item-icon nexmoefont icon-hanbao1"></i>
            <div class="mdui-list-item-content">
                归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于">
            <i class="mdui-list-item-icon nexmoefont icon-jiubei1"></i>
            <div class="mdui-list-item-content">
                关于
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/friend.html" title="友链">
            <i class="mdui-list-item-icon nexmoefont icon-cola"></i>
            <div class="mdui-list-item-content">
                友链
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/download.html" title="下载中心">
            <i class="mdui-list-item-icon nexmoefont icon-tangguo"></i>
            <div class="mdui-list-item-content">
                下载中心
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  
<!-- 站内搜索 -->

<div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search" >
        <form id="search-form">
            <label><input type="text" id="local-search-input" name="q" results="0" placeholder="站内搜索" class="input form-control" autocomplete="off" autocorrect="off"/></label>
            <!-- 清空/重置搜索框 -->
            <i class="fa fa-times" onclick="resetSearch()"></i>
        </form>
    </div>
    <div id="local-search-result"></div> <!-- 搜索结果区 -->
    <!-- <p class='no-result'></p> 无匹配时显示，注意在 CSS 中设置默认隐藏 -->
</div>


  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=2120252100&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(64, 196, 255);background-color: rgba(64, 196, 255, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="mailto:tangyuxian@vip.qq.com" target="_blank" mdui-tooltip="{content: 'mail'}" style="color: rgb(249,8,8);background-color: rgba(249,8,8,.1);">
            <i class="nexmoefont icon-mail-fill"></i>
        </a><a class="mdui-ripple" href="https://blog.csdn.net/qq_40621378?type=blog" target="_blank" mdui-tooltip="{content: 'CSDN'}" style="color: rgb(199,29,35);background-color: rgba(199,29,35,.1);">
            <i class="nexmoefont icon-csdn"></i>
        </a><a class="mdui-ripple" href="https://www.cnblogs.com/lovetangyuxian/" target="_blank" mdui-tooltip="{content: '博客园'}" style="color: rgb(66, 214, 29);background-color: rgba(66, 214, 29, .1);">
            <i class="nexmoefont icon-bokeyuan"></i>
        </a><a class="mdui-ripple" href="https://github.com/tangyuxian/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://gitee.com/tangyuxian" target="_blank" mdui-tooltip="{content: 'gitee'}" style="color: rgb(255, 255, 255);background-color: rgb(199,29,35);">
            <i class="nexmoefont icon-mayun"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JavaScript/">JavaScript</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Node-js/">Node.js</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/TypeScript/">TypeScript</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/react/">react</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/代码管理/">代码管理</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/node/" style="font-size: 20px;">node</a> <a href="/tags/react/" style="font-size: 10px;">react</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2024 Talita
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/tangyuxian/hexo-theme-tangyuxian" target="_blank">Tangyuxian</a><br/>
        <a href="http://beian.miit.gov.cn" target="_blank">辽ICP备2021002341号</a><br/>
        
        <div style="font-size: 12px">
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            本站总访问量  <a id="busuanzi_value_site_pv"></a> 次<br />
            本站访客数<a id="busuanzi_value_site_uv"></a>人次
        </div>
        
        
    </div>

</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2024/05/28/T1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 26.666666666666668%;">
                    <img data-src="/images/post/TypeScript.png" data-sizes="auto" alt="TypeScript介绍（一）" class="lazyload">
                    <h1>TypeScript介绍（一）</h1>
                </div>
            
        </a>
        
        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2024年05月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>7.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 34 分钟</a>
        </div>
        
        <article>
            <!-- 
                <h1 id="TypeScript基础语法"><a href="#TypeScript基础语法" class="headerlink" title="TypeScript基础语法"></a>TypeScript基础语法</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote>
<p><em>TypeScript是微软公司开发的一种基于JavaScript语言的编程语言，它的目的是增强 JavaScript 的功能， 可以看成是 JavaScript 的超集，即它继承了后者的全部语法，又增加了一些自己的语法，使其更适合多人合作的企业级项目。</em></p>
</blockquote>
<p>TypeScript 的主要功能是为 JavaScript 添加类型系统。在语法上，JavaScript 属于<strong>动态类型语言</strong>，声明一个变量后可以任意改变其类型，不具有很强的约束性。TypeScript 属于<strong>静态类型语言，</strong>类型错误时在开发阶段就会报错，有利于提早发现错误，避免使用时报错。</p>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p><strong>声明方式：</strong></p>
<p>类型声明为在标识符后面添加“<strong>冒号 + 类型</strong>”。<strong>函数参数</strong>和<strong>返回值</strong>，也是这样来声明类型。</p>
<pre><code class="tsx">let foo:string;

function toString(num:number):string &#123;
  return String(num);
&#125;
</code></pre>
<p><strong>使用规则：</strong></p>
<ol>
<li>类型声明并不是必需的，如果没有，<strong>TypeScript 会自己推断类型</strong>。如果变量更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</li>
<li>TypeScript 规定，<strong>变量只有赋值后才能使用</strong>，否则就会报错。而 JavaScript 允许这种行为，没有赋值的变量会返回<code>undefined</code>。</li>
<li>TypeScript 可以推断函数的返回值，因此<strong>函数返回值的类型通常是省略不写的。</strong></li>
</ol>
<h3 id="TypeScript-的编译"><a href="#TypeScript-的编译" class="headerlink" title="TypeScript 的编译"></a><strong>TypeScript 的编译</strong></h3><p>JavaScript 的运行环境（浏览器和 Node.js）不认识 TypeScript 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“编译”（compile）。</p>
<p>经过编译后，类型声明和类型相关的TypeScript代码将全部删除，只留下能运行的 JavaScript 代码。因此，TypeScript 的类型检查只是<strong>编译时的类型检查</strong>，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<p><strong>tsc 编译器：</strong></p>
<p>TypeScript 官方提供的编译器叫做 tsc，用于将 TypeScript 脚本编译成可供运行的 JavaScript 脚本。</p>
<p>tsc编译后，会在当前目录下生成一个同名的JavaScript脚本文件，这个脚本就完全是编译后生成的 JavaScript 代码，需要使用额外的命令来运行它。</p>
<pre><code class="bash">$ tsc app.ts 
$ node app.js
</code></pre>
<p>tsc的基本用法如下：</p>
<pre><code class="bash"># 使用 tsconfig.json 的配置
$ tsc
# 只编译 index.ts
$ tsc index.ts
# 编译 src 目录的所有 .ts 文件
$ tsc src/*.ts
# 指定编译配置文件
$ tsc --project tsconfig.production.json
# 只生成类型声明文件，不编译出 JS 文件
$ tsc index.js --declaration --emitDeclarationOnly
# 多个 TS 文件编译成单个 JS 文件
$ tsc app.ts util.ts --target esnext --outfile index.js --outDir dist
</code></pre>
<ol>
<li><code>--outFile</code>：使用该参数可将多个 TypeScript 脚本编译成一个 JavaScript 文件。</li>
<li><code>--outDir</code>：编译结果默认保存在当前目录，<code>--outDir</code>参数可以指定保存到其他目录。</li>
<li><code>--target</code>：为了保证编译结果能在各种 JavaScript 引擎运行，tsc 默认会将 TypeScript 代码编译成很低版本的 JavaScript，即3.0版本（以<code>es3</code>表示）。使用<code>--target</code>参数可以指定编译后的 JavaScript 版本。建议使用<code>es2015</code>，或者更新版本。</li>
<li><code>--noEmitOnError</code>：一旦报错就停止编译，不生成编译产物。</li>
<li><code>--noEmit</code>：只检查类型是否正确，不生成 JavaScript 文件。</li>
</ol>
<p>TypeScript 允许将<code>tsc</code>的编译参数，写在配置文件<code>tsconfig.json</code>。只要当前目录有这个文件，<code>tsc</code>就会自动读取，运行时不用再写各项参数。也可以在输入命令时通过<code>--project</code> 指定具体的编译配置文件。例如：</p>
<pre><code class="json">&#123;  
  &quot;files&quot;: [&quot;dd.ts&quot;, &quot;aa.ts&quot;],  
  &quot;compilerOptions&quot;: &#123;  
    &quot;outFile&quot;: &quot;dist/app.js&quot;  
  &#125;  
&#125;
</code></pre>
<p><code>tsconfig.json</code>的具体配置项参见<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-tsconfig.json.md">https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-tsconfig.json.md</a>。</p>
<p><strong>ts-node工具：</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">ts-node</a> 是一个需要安装的非官方 npm 模块，它允许你运行 TypeScript 代码而无需先编译它。使用时，可以<code>npm install -g ts-node</code>先全局安装它。安装后，就可以直接<code>ts-node script.ts</code>运行 TypeScript 编译后的脚本。</p>
<p>如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行输入代码运行。例如：</p>
<pre><code class="bash">$ ts-node
&gt; const twice = (x:string) =&gt; x + x;
&gt; twice(&#39;abc&#39;)
&#39;abcabc&#39;
&gt;
</code></pre>
<p>要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入<code>.exit</code>。</p>
<p>如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>TypeScript 继承了 JavaScript 的类型设计，将值分成8种类型：<code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code>、<code>undefined</code>、<code>null</code>。</p>
<aside>
💡 任意类型转boolean只要加`！！`即可


</aside>

<p>其中<code>undefined</code>和<code>null</code>是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p>
<p><strong>所有类型的名称都是小写字</strong>母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript 语言中是<strong>内置对象</strong>，提供了用于该对象的多种方法。例如，<code>Number.parseInt()</code>、<code>Number.parseFloat()</code>、<code>Number.isNaN()</code>。</p>
<p><strong>包装对象：</strong></p>
<p>在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。但类似<code>&#39;hello&#39;.charAt(1)</code> 这样的代码是可以运行的，因为在调用方法时，字符串会自动转为包装对象，<code>charAt()</code>方法其实是定义在包装对象上。这样的设计省去了将原始类型的值手动转成对象实例的麻烦。</p>
<p>五种基本类型中，除了symbol 类型和 bigint 类型外，都可以使用构造函数来获取包装对象。</p>
<p>在TypeScript中，大写类型同时包含<strong>包装对象和字面量</strong>（字面量表示固定的值）两种情况，小写类型<strong>只包含字面量</strong>，不包含包装对象。</p>
<p><strong>建议只使用小写类型，不使用大写类型。</strong></p>
<p>而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p>
<p><strong>bigint：</strong></p>
<p><code>bigint</code> 类型是 ES2020 标准引入的，且 <code>bigint</code> 与 <code>number</code> 类型不兼容。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数<code>target</code>不低于<code>es2020</code>）。</p>
<p><strong>undefined 和 null：</strong></p>
<p><code>undefined</code> 和 <code>null</code> 是所有类型的子类型，且各自都只有一个值，因此其他类型的变量都可以被赋值为<code>null</code> 和 <code>undefined</code> 。</p>
<p><code>undefined</code> 类型表示未定义（即还未给出定义，以后可能会有定义）。</p>
<p><code>null</code> 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p>
<h3 id="基本数据类型-Symbol"><a href="#基本数据类型-Symbol" class="headerlink" title="基本数据类型 Symbol"></a><strong>基本数据类型 Symbol</strong></h3><p><strong>Symbol的基本用法：</strong></p>
<p><code>Symbol</code>是ES6 新增的数据类型 ，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用<code>Symbol()</code>函数来创建一个<code>Symbol</code>实例。传入的可选的字符串参数，相当于给你创建的Symbol实例一个描述信息。</p>
<pre><code class="tsx">let s1 = Symbol()
let s2 = Symbol(&#39;another symbol&#39;)
</code></pre>
<p>如何理解Symbol的唯一性：</p>
<pre><code class="tsx">let s1 = Symbol()
let s2 = Symbol(&#39;another symbol&#39;)
let s3 = Symbol(&#39;another symbol&#39;)

s1 === s2 // false
s2 === s3 // false
</code></pre>
<p><strong>应用场景1：使用Symbol来作为对象属性名</strong></p>
<pre><code class="tsx">const PROP_NAME = Symbol()
const PROP_AGE = Symbol()

let obj = &#123;
    // 将Symbol作为对象属性名时，需要写在[]里
  [PROP_NAME]: &quot;一斤代码&quot;
&#125;
obj[PROP_AGE] = 18

obj[PROP_NAME] // &#39;一斤代码&#39;
obj[PROP_AGE] // 18
</code></pre>
<p>注意：<code>Symbol</code>类型的<code>key</code>不会被列举</p>
<pre><code class="tsx">let obj = &#123;
   [Symbol(&#39;name&#39;)]: &#39;一斤代码&#39;,
   age: 18,
   title: &#39;Engineer&#39;
&#125;

Object.keys(obj)   // [&#39;age&#39;, &#39;title&#39;]

for (let p in obj) &#123;
   console.log(p)   // 分别会输出：&#39;age&#39; 和 &#39;title&#39;
&#125;

Object.getOwnPropertyNames(obj)   // [&#39;age&#39;, &#39;title&#39;]

JSON.stringify(obj)  // &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125;
</code></pre>
<p>如果实在想获取以Symbol方式定义的对象属性，还是有一些专门针对Symbol的API的，比如：</p>
<pre><code class="tsx">// 使用Object的API
Object.getOwnPropertySymbols(obj) // [Symbol(name)]

// 使用新增的反射API
Reflect.ownKeys(obj) // [Symbol(name), &#39;age&#39;, &#39;title&#39;]
</code></pre>
<p><strong>应用场景2：使用Symbol来替代常量</strong></p>
<pre><code class="tsx">const TYPE_AUDIO = &#39;AUDIO&#39;
const TYPE_VIDEO = &#39;VIDEO&#39;
const TYPE_IMAGE = &#39;IMAGE&#39;
// 使用Symbol来替代常量(Symbol的唯一性)
const TYPE_AUDIO = Symbol()
const TYPE_VIDEO = Symbol()
const TYPE_IMAGE = Symbol()
</code></pre>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>大写的<code>Object</code>类型为原型链的最顶端，所有类型的父类型，代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，也就是说，<strong>原始类型值、对象、数组、函数</strong>都是合法的<code>Object</code>类型。</p>
<p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。另外，空对象<code>&#123;&#125;</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p>
<pre><code class="tsx">let obj:Object;
let obj:&#123;&#125;;

obj = undefined; // 报错
obj = null; // 报错
</code></pre>
<p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p>
<p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即<strong>只包含对象、数组和函数</strong>，不包括原始类型的值。所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p>
<p>注意：无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象<strong>原生的属性和方法</strong>，用户自定义的属性和方法都不存在于这两个类型之中。</p>
<pre><code class="tsx">const o1:Object = &#123; foo: 0 &#125;;
const o2:object = &#123; foo: 0 &#125;;

o1.toString() // 正确
o1.foo // 报错

o2.toString() // 正确
o2.foo // 报错
</code></pre>
<p>在TypeScript中，只有<code>toString()</code>是<code>object</code>对象的原生方法，可以正确访问。</p>
<p>非常麻烦，因此在实际开发中，尽量避免使用 <code>Object</code> 或 <code>object</code> 类型，除非有特定的原因。使用更具体的类型可以提供更好的类型安全性和可读性。</p>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2024/05/28/T1/Untitled.png" alt="Untitled" class="lazyload"></p>
<h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a><strong>any 类型</strong></h3><p>any 类型表示任意类型，一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查，即使有明显的类型错误。</p>
<pre><code class="tsx">let x:any = &#39;hello&#39;;

x(1) // 不报错
x.foo = 100; // 不报错
</code></pre>
<p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p>
<p>从集合论的角度看，<code>any</code>类型可以看成是“<strong>顶层类型</strong>”（top type），包含了一切可能的类型。</p>
<p><strong>类型推断为any：</strong></p>
<p>TypeScript 如果无法推断出类型，就会认为该变量的类型是<code>any</code>，后面就不再对其进行类型检查了。这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为<code>any</code>。</p>
<p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，只要推断出<code>any</code>类型就会报错。</p>
<pre><code class="bash">$ tsc --noImplicitAny app.ts
</code></pre>
<p>使用<code>let</code>和<code>var</code>声明变量时如果不赋值，也没有指定类型，TypeScript 会推断它们的类型为<code>any</code>。这时即使打开了<code>noImplicitAny</code>，也不会报错。</p>
<pre><code class="tsx">let x;

x = 123;
x = &#123; foo: &#39;hello&#39; &#125;;
</code></pre>
<p>因此使用<code>let</code>和<code>var</code>声明变量时，<strong>如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</strong></p>
<p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）。</p>
<p><strong>any的污染问题：</strong></p>
<p><code>any</code>类型可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量也被污染为<code>any</code>类型。</p>
<pre><code class="tsx">let x:any = &#39;hello&#39;;
let y:number;

y = x; // 不报错

y * 123 // 不报错
y.toFixed() // 不报错
</code></pre>
<p>由于TypeScript 检查不出错误，问题就这样留到运行时才会暴露，这就是不宜使用<code>any</code>类型的另一个主要原因。</p>
<h3 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a><strong>unknown 类型</strong></h3><ol>
<li><code>unknown</code><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">类型</a>是<code>any</code>的安全类型，但定义后变量将变成<code>private</code>，不能再赋值给别的变量，也不能直接调用。</li>
<li><code>unknown</code>类型只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符，其他运算都会报错。</li>
</ol>
<p>怎么才能取出<code>unknown</code>类型变量呢？</p>
<p>答案是“<strong>类型缩小</strong>”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p>
<pre><code class="tsx">let a:unknown = 1;
if (typeof a === &#39;number&#39;) &#123;
  let r = a + 10; // 正确
&#125;

let s:unknown = &#39;hello&#39;;
if (typeof s === &#39;string&#39;) &#123;
  s.length; // 正确
&#125;
</code></pre>
<p>只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p>
<p>一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p>
<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a><strong>never 类型</strong></h3><p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。它等同于空集，即不可能赋给它任何值，否则都会报错，但是可以赋值给任意其他类型。</p>
<p><code>never</code>类型的使用场景：</p>
<ol>
<li><p>在一些类型运算之中，保证类型运算的完整性</p>
</li>
<li><p>不可能返回值的函数，返回值的类型就可以写成<code>never</code></p>
<pre><code class="tsx">function f():never &#123;
  throw new Error(&#39;Error&#39;);
&#125;

let v1:number = f(); // 不报错
let v2:string = f(); // 不报错
let v3:boolean = f(); // 不报错
</code></pre>
</li>
<li><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。处理完所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p>
<pre><code class="tsx">function fn(x:string|number) &#123;
  if (typeof x === &#39;string&#39;) &#123;
    // ...
  &#125; else if (typeof x === &#39;number&#39;) &#123;
    // ...
  &#125; else &#123;
    x; // never 类型
  &#125;
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p><em>总之，TypeScript 有两个“顶层类型”（<code>any</code>和<code>unknown</code>），和一个“底层类型”<code>never</code>。</em></p>
</blockquote>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a><strong>值类型</strong></h3><p>TypeScript 规定，单个值也可以作为一种类型，称为“值类型”，即该变量只能取值为该值。</p>
<pre><code class="tsx">let x:&#39;hello&#39;;

x = &#39;hello&#39;; // 正确
x = &#39;world&#39;; // 报错
</code></pre>
<p>应用场景：TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码没有注明类型，就会推断该变量是值类型。</p>
<pre><code class="tsx">// x 的类型是 &quot;https&quot;
const x = &#39;https&#39;;

// y 的类型是 string
const y:string = &#39;https&#39;;
</code></pre>
<p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。但如果<code>const</code>赋值为对象，并不会推断为值类型。</p>
<pre><code class="tsx">// x 的类型是 &#123; foo: number &#125;
const x = &#123; foo: 1 &#125;;
</code></pre>
<p>这是因为 JavaScript 里面，<code>const</code>变量赋值为对象时，属性值是可以改变的。</p>
<p>值类型可能会出现一些很奇怪的报错，因为父类型不能赋值给子类型，等号右侧<code>4 + 1</code>的类型为<code>number</code>，等号左侧的类型为数值<code>5</code>，<code>number</code>是<code>5</code>的父类型，所以报错了。但是，反过来是可以的，子类型可以赋值给父类型。</p>
<pre><code class="tsx">let x:5 = 5;
let y:number = 4 + 1;

x = y; // 报错
y = x; // 正确
</code></pre>
<p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言。</p>
<p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a><strong>联合类型</strong></h3><p>联合类型指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p>
<p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p>
<pre><code class="tsx">let x:string|number;

x = 123; // 正确
x = &#39;abc&#39;; // 正确

let setting:true|false;

let gender:&#39;male&#39;|&#39;female&#39;;

let rainbowColor:&#39;赤&#39;|&#39;橙&#39;|&#39;黄&#39;|&#39;绿&#39;|&#39;青&#39;|&#39;蓝&#39;|&#39;紫&#39;;
</code></pre>
<p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p>
<pre><code class="tsx">let name:string|null;

name = &#39;John&#39;;
name = null;
</code></pre>
<p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p>
<pre><code class="tsx">let x:
  | &#39;one&#39;
  | &#39;two&#39;
  | &#39;three&#39;
  | &#39;four&#39;;
</code></pre>
<p>上面示例中，联合类型的第一个成员<code>one</code>前面，加上了竖杠。</p>
<p>如果使用了联合类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p>
<pre><code class="tsx">function printId(
  id:number|string
) &#123;
    console.log(id.toUpperCase()); // 报错
&#125;
</code></pre>
<p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p>
<pre><code class="tsx">function printId(
  id:number|string
) &#123;
  if (typeof id === &#39;string&#39;) &#123;
    console.log(id.toUpperCase());
  &#125; else &#123;
    console.log(id);
  &#125;
&#125;
</code></pre>
<p><strong>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。</strong></p>
<p>实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。下面是“类型缩小”的另一个例子。</p>
<pre><code class="tsx">function getPort(
  scheme: &#39;http&#39;|&#39;https&#39;
) &#123;
  switch (scheme) &#123;
    case &#39;http&#39;:
      return 80;
    case &#39;https&#39;:
      return 443;
  &#125;
&#125;
</code></pre>
<p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a><strong>交叉类型</strong></h3><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p>
<p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p>
<pre><code class="tsx">let x:number&amp;string;
</code></pre>
<p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是<code>never</code>。</p>
<p><strong>主要用途：</strong></p>
<ol>
<li><p>对象合成</p>
<pre><code class="tsx">let obj:
  &#123; foo: string &#125; &amp;
  &#123; bar: string &#125;;

obj = &#123;
  foo: &#39;hello&#39;,
  bar: &#39;world&#39;
&#125;;
</code></pre>
</li>
<li><p>为对象类型添加新属性</p>
<pre><code class="tsx">type A = &#123; foo: number &#125;;

type B = A &amp; &#123; bar: number &#125;;
</code></pre>
</li>
</ol>
<h2 id="数组和元祖"><a href="#数组和元祖" class="headerlink" title="数组和元祖"></a>数组和元祖</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><blockquote>
<p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p>
</blockquote>
<p>数组的类型有<strong>两种写法</strong>：</p>
<ol>
<li><p>在数组成员的类型后面，加上一对方括号</p>
<pre><code class="tsx">let arr:number[] = [1, 2, 3];
let arr:(number|string)[];
</code></pre>
</li>
<li><p>使用 TypeScript 内置的 Array 接口</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2, 3];
</code></pre>
</li>
</ol>
<aside>
💡 **注意：**由于数组成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。


</aside>

<h3 id="数组的类型推断"><a href="#数组的类型推断" class="headerlink" title="数组的类型推断"></a><strong>数组的类型推断</strong></h3><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。</p>
<p><strong>空数组的类型推断：</strong></p>
<p>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是<code>any[]</code>。后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p>
<pre><code class="tsx">const arr = [];
arr // 推断为 any[]

arr.push(123);
arr // 推断类型为 number[]

arr.push(&#39;abc&#39;);
arr // 推断类型为 (string|number)[]
</code></pre>
<p><strong>非空数组的类型推断：</strong></p>
<p>类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p>
<pre><code class="tsx">// 推断类型为 number[]
const arr = [123];

arr.push(&#39;abc&#39;); // 报错
</code></pre>
<h3 id="元祖概念"><a href="#元祖概念" class="headerlink" title="元祖概念"></a>元祖概念</h3><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有，它允许数组的各个成员的类型可以不同。</p>
<p><strong>使用规则：</strong></p>
<ol>
<li><p>由于成员的类型可以不一样，所以元组必须明确声明每个成员的类型。</p>
<pre><code class="tsx">const s:[string, string, boolean]
  = [&#39;a&#39;, &#39;b&#39;, true];
</code></pre>
<p>数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。TypeScript 的区分方法就是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p>
<p>使用元组时，必须明确给出类型声明，不能省略，否则 TypeScript 会把一个值自动推断为数组。</p>
<pre><code class="tsx">// a 的类型被推断为 (number | boolean)[]
let a = [1, true];
</code></pre>
</li>
<li><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>
<pre><code class="tsx">let a:[number, number?] = [1];
</code></pre>
<p>注意：所有可选成员必须在必选成员之后。</p>
</li>
<li><p>由于元组的成员数量是有限的，因此越界的成员会报错。</p>
<pre><code class="tsx">let x:[string, string] = [&#39;a&#39;, &#39;b&#39;];

x[2] = &#39;c&#39;; // 报错
</code></pre>
<p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p>
<pre><code class="tsx">type NamedNums = [
  string,
  ...number[]
];

const a:NamedNums = [&#39;A&#39;, 1, 2];
const b:NamedNums = [&#39;B&#39;, 1, 2, 3];
</code></pre>
<p>如果不确定元组成员的类型和数量，可以写成下面这样。</p>
<pre><code class="tsx">type Tuple = [...any[]];
</code></pre>
</li>
<li><p>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</p>
<pre><code class="tsx">type Color = [
  red: number,
  green: number,
  blue: number
];

const c:Color = [255, 255, 255];
</code></pre>
</li>
</ol>
<h3 id="扩展运算符与成员数量"><a href="#扩展运算符与成员数量" class="headerlink" title="扩展运算符与成员数量"></a><strong>扩展运算符与成员数量</strong></h3><p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量<strong>是不确定</strong>的，这导致如果函数调用时，使用扩展运算符传入函数参数，会发生参数数量与数组长度不匹配的报错。</p>
<pre><code class="tsx">const arr = [1, 2];

function add(x:number, y:number)&#123;
  // ...
&#125;

add(...arr) // 报错
</code></pre>
<p>如果函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p>
<p>解决这个问题的方法：</p>
<ol>
<li><p>把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p>
<pre><code class="tsx">const arr:[number, number] = [1, 2];

function add(x:number, y:number)&#123;
  // ...
&#125;

add(...arr) // 正确
</code></pre>
</li>
<li><p>使用<code>as const</code>断言</p>
<pre><code class="tsx">const arr = [1, 2] as const;
</code></pre>
</li>
</ol>
<h2 id="TypeScript-的函数类型"><a href="#TypeScript-的函数类型" class="headerlink" title="TypeScript 的函数类型"></a><strong>TypeScript 的函数类型</strong></h2><p>函数需要在声明时，给出<strong>参数的类型</strong>和<strong>返回值的类型（可选）</strong></p>
<p>函数的多种写法：</p>
<ol>
<li><p>普通函数</p>
<pre><code class="tsx">function add(a: number, b: number): number &#123;  
    return a + b;  
&#125;
const hello = function (txt:string) &#123;
  console.log(&#39;hello &#39; + txt);
&#125;
</code></pre>
</li>
<li><p>箭头函数</p>
<pre><code class="tsx">const add = (a: number, b: number): number =&gt; &#123;  
    return a + b;  
&#125;;  
  
// 简写形式（当函数体只有一条语句时）  
const add = (a: number, b: number): number =&gt; a + b;
</code></pre>
</li>
<li><p><strong>函数类型别名</strong></p>
<p>使用类型别名可以为函数的参数和返回值类型定义一个名字，然后在其他地方使用这个别名</p>
<pre><code class="tsx">type AddFunction = (a: number, b: number) =&gt; number;  
  
const add: AddFunction = (a, b) =&gt; a + b;
</code></pre>
</li>
<li><p><code>typeof</code>套用另一个函数类型</p>
<pre><code class="tsx">function add(x: number, y: number) &#123;
  return x + y;
&#125;

const myAdd: typeof add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
</li>
<li><p>函数类型的对象写法：<code>&#123;(参数列表): 返回值&#125;</code></p>
<pre><code class="tsx">let add: &#123;
  (x: number, y: number): number;
&#125;;

add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
<p>这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。</p>
<pre><code class="tsx">let foo: &#123;
  (x: number): void;
  version: string;
&#125; = f;
function f(x: number) &#123;
  console.log(x);
&#125;
f.version = &quot;1.0&quot;;
</code></pre>
</li>
<li><p>使用 <code>Interface</code> 来声明函数类型</p>
<pre><code class="tsx">interface myfn &#123;
  (a: number, b: number): number;
&#125;
var add: myfn = (a, b) =&gt; a + b;
</code></pre>
</li>
</ol>
<h3 id="其他常见写法"><a href="#其他常见写法" class="headerlink" title="其他常见写法"></a>其他常见写法</h3><ol>
<li><p><strong>可选参数：</strong>使用<code>?</code>来标记函数的某个参数是可选的</p>
<pre><code class="tsx">function greet(name?: string) &#123;  
    return name ? `Hello, $&#123;name&#125;!` : &#39;Hello, stranger!&#39;;  
&#125;
</code></pre>
<p>函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。</p>
</li>
<li><p><strong>默认参数：</strong>为函数的参数指定默认值</p>
<pre><code class="tsx">function greet(name: string = &#39;stranger&#39;) &#123;  
    return `Hello, $&#123;name&#125;!`;  
&#125;
</code></pre>
</li>
<li><p><strong>剩余参数：</strong>使用<code>...</code>语法来创建一个剩余参数，将剩余的参数收集到一个数组中</p>
<pre><code class="tsx">function sum(...numbers: number[]): number &#123;  
    return numbers.reduce((acc, val) =&gt; acc + val, 0);  
&#125;
</code></pre>
<p>这里的”剩余”指的是除了明确列出的参数之外的所有参数，如果剩下的所有参数类型相同，可以用数组，类型不同可以用元祖，元祖需要声明每一个剩余参数的类型</p>
<pre><code class="tsx">function f(
  ...args: [boolean, string?]
) &#123;&#125;
</code></pre>
<p>rest 参数还可以与变量解构结合使用：</p>
<pre><code class="tsx">function repeat(
  ...[str, times]: [string, number]
):string &#123;
  return str.repeat(times);
&#125;

// 等同于
function repeat(
  str: string,
  times: number
):string &#123;
  return str.repeat(times);
&#125;
</code></pre>
</li>
<li><p><strong>高阶函数：</strong>一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数</p>
<pre><code class="tsx">(someValue: number) =&gt; (multiplier: number) =&gt; someValue * multiplier;
</code></pre>
</li>
</ol>
<h3 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a><strong>参数解构</strong></h3><p>解构赋值是一种JavaScript表达式，它允许你从一个数组或对象中提取数据到不同的变量中。</p>
<p><strong>数组解构：</strong></p>
<p>假设你有一个函数，它期望一个包含两个元素的数组作为参数，并希望直接将这些元素分配给两个变量：</p>
<pre><code class="tsx">function processArray([first, second]: [number, string]) &#123;  
    console.log(first);  // 输出第一个数字  
    console.log(second); // 输出第二个字符串  
&#125;  
  
processArray([1, &quot;two&quot;]);
</code></pre>
<p><strong>对象解构：</strong></p>
<pre><code class="tsx">function processPerson(&#123; name, age &#125;: &#123; name: string, age: number &#125;) &#123;  
    console.log(name);  
    console.log(age);  
&#125;  
  
processPerson(&#123; name: &quot;Alice&quot;, age: 30 &#125;);
</code></pre>
<p><strong>可选和默认值：</strong></p>
<pre><code class="tsx">function processPerson(&#123; name = &quot;Anonymous&quot;, age = 0 &#125;: &#123; name?: string, age?: number &#125;) &#123;  
    console.log(name);  
    console.log(age);  
&#125;  
  
processPerson(&#123; age: 30 &#125;); // 输出 &quot;Anonymous&quot; 和 30
</code></pre>
<p><strong>剩余参数和解构：</strong></p>
<pre><code class="tsx">function processArray(...[first, ...rest]: [number, ...number[]]) &#123;  
    console.log(first);  
    console.log(rest); // rest 是一个数组  
&#125;  
  
processArray(1, 2, 3, 4); // 输出 1 和 [2, 3, 4]
</code></pre>
<p><strong>结合type：</strong></p>
<pre><code class="tsx">type ABC = &#123; a:number; b:number; c:number &#125;;

function sum(&#123; a, b, c &#125;:ABC) &#123;
  console.log(a + b + c);
&#125;
</code></pre>
<h3 id="返回值设置为void和never有什么区别？"><a href="#返回值设置为void和never有什么区别？" class="headerlink" title="返回值设置为void和never有什么区别？"></a><strong>返回值设置为void和never有什么区别？</strong></h3><p><code>void</code> 类型表示没有任何类型。</p>
<p>当你指定一个函数返回 <code>void</code> 类型时，意味着这个函数不返回任何值（或者更准确地说，它返回 <code>undefined</code>）。</p>
<p>在实际编程中，即使你指定函数返回 <code>void</code>，TypeScript仍然允许你隐式地返回 <code>undefined</code>（因为 <code>undefined</code> 是 <code>void</code> 类型的唯一有效值）。</p>
<p>示例：</p>
<pre><code class="tsx">function logMessage(message: string): void &#123;  
    console.log(message);  
    // 隐式返回 undefined  
&#125;  
const result = logMessage(&quot;Hello, world!&quot;); // result 将会是 undefined
</code></pre>
<p><code>never</code> 类型表示的是那些永不存在的值的类型，通常用于描述那些总是抛出错误或永远不返回的函数。</p>
<p><strong>示例1：总是抛出错误的函数</strong></p>
<pre><code class="tsx">function error(message: string): never &#123;  
    throw new Error(message);  
    // 这里不会执行到任何后续的代码，所以返回类型是 never  
&#125;
</code></pre>
<p><strong>示例2：永远不返回的函数（无限循环）</strong></p>
<pre><code class="tsx">function loopForever(): never &#123;  
    while (true) &#123;  
        // 这个循环永远不会结束，所以返回类型是 never  
    &#125;  
&#125;
</code></pre>
<p><strong>示例2：使用</strong> <code>never</code> <strong>类型的类型守卫</strong></p>
<p>使用 <code>never</code> 类型来创建一个类型守卫，该守卫可以确保某个条件总是为 <code>false</code>（这在某些高级类型操作中可能是有用的）。</p>
<pre><code class="tsx">function isNever(x: never): never &#123;  
    throw new Error(&quot;Unexpected object of type &#39;never&#39;.&quot;);  
&#125;  
  
// 这个函数永远不会被调用，因为没有任何值可以是 &#39;never&#39; 类型  
// 但它在这里作为一个示例来说明 `never` 类型的用法
</code></pre>
<p><strong>总结：</strong></p>
<ol>
<li><code>void</code> 表示函数不返回任何有用的值（或返回 <code>undefined</code>）。</li>
<li><code>never</code> 表示函数永不返回（或者总是抛出错误）。</li>
</ol>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。</p>
<p>这意味着，该函数内部有多套逻辑，根据参数类型的不同，分别执行对应的逻辑。这就叫“函数重载”。</p>
<p>TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。</p>
<pre><code class="tsx">function reverse(str:string):string;
function reverse(arr:any[]):any[];
function reverse(
  stringOrArray:string|any[]
):string|any[] &#123;
  if (typeof stringOrArray === &#39;string&#39;)
    return stringOrArray.split(&#39;&#39;).reverse().join(&#39;&#39;);
  else
    return stringOrArray.slice().reverse();
&#125;
</code></pre>
<p>上面示例中，前两行类型声明列举了重载的各种情况。第三行是函数本身的类型声明，它必须与前面已有的重载声明兼容。</p>
<p><strong>使用规则：</strong></p>
<ol>
<li><p>函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。</p>
</li>
<li><p>重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。</p>
<pre><code class="tsx">function f(x:any):number;
function f(x:string): 0|1;
function f(x:any):any &#123;
  // ...
&#125;

const a:0|1 = f(&#39;hi&#39;); // 报错
</code></pre>
</li>
<li><p>对象的方法也可以使用重载。</p>
<pre><code class="tsx">class StringBuilder &#123;
  #data = &#39;&#39;;

  add(num:number): this;
  add(bool:boolean): this;
  add(str:string): this;
  add(value:any): this &#123;
    this.#data += String(value);
    return this;
  &#125;

  toString() &#123;
    return this.#data;
  &#125;
&#125;
</code></pre>
</li>
<li><p>函数重载也可以用来精确描述函数参数与返回值之间的对应关系</p>
<pre><code class="tsx">function createElement(
  tag:&#39;a&#39;
):HTMLAnchorElement;
function createElement(
  tag:&#39;canvas&#39;
):HTMLCanvasElement;
function createElement(
  tag:&#39;table&#39;
):HTMLTableElement;
function createElement(
  tag:string
):HTMLElement &#123;
  // ...
&#125;
</code></pre>
<p>这个示例的函数重载，也可以用对象表示。</p>
<pre><code class="tsx">type CreateElement = &#123;
  (tag:&#39;a&#39;): HTMLAnchorElement;
  (tag:&#39;canvas&#39;): HTMLCanvasElement;
  (tag:&#39;table&#39;): HTMLTableElement;
  (tag:string): HTMLElement;
&#125;
</code></pre>
</li>
<li><p>由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载，除非多个参数之间、或者某个参数与返回值之间，存在对应关系。</p>
</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>JavaScript 语言使用构造函数，生成对象的实例。</p>
<p>构造函数的最大特点，就是必须使用<code>new</code>命令调用。</p>
<pre><code class="tsx">class Animal &#123;
  numLegs:number = 4;
&#125;

type AnimalConstructor = new () =&gt; Animal;

function create(c:AnimalConstructor):Animal &#123;
  return new c();
&#125;

const a = create(Animal);
</code></pre>
<p>上面示例中，类型<code>AnimalConstructor</code>就是一个构造函数，而函数<code>create()</code>需要传入一个构造函数。在 JavaScript 中，类（class）本质上是构造函数，所以<code>Animal</code>这个类可以传入<code>create()</code>。</p>
<p>构造函数还有另一种类型写法，就是采用对象形式。</p>
<pre><code class="tsx">type F = &#123;
  new (s:string): object;
&#125;;
</code></pre>
<p>上面示例中，类型 F 就是一个构造函数。类型写成一个可执行对象的形式，并且在参数列表前面要加上<code>new</code>命令。</p>
<p>某些函数既是构造函数，又可以当作普通函数使用，比如<code>Date()</code>。这时，类型声明可以写成下面这样。</p>
<pre><code class="tsx">type F = &#123;
  new (s:string): object;
  (n?:number): number;
&#125;
</code></pre>
<p>上面示例中，F 既可以当作普通函数执行，也可以当作构造函数使用。</p>

             -->
        </article>
    </div>
    
</section>


        <div class="nexmoe-post-right">
          
            <div class="nexmoe-fixed">
              <div class="nexmoe-tool">
                <a href="#" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
              </div>
            </div>
          
        </div>
    </div>
  </div>
  <div id="nexmoe-pendant">
    <div class="nexmoe-drawer mdui-drawer nexmoe-pd" id="drawer">
        
            <div class="nexmoe-pd-item">
                <div class="clock">
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="memory"></div>
        <div class="needle" id="hours"></div>
        <div class="needle" id="minutes"></div>
        <div class="needle" id="seconds"></div>
        <div class="clock_logo">

        </div>

    </div>
<style>
    .clock {
        background-color: #ffffff;
        width: 70vw;
        height: 70vw;
        max-width: 70vh;
        max-height: 70vh;
        border: solid 2.8vw #242424;
        position: relative;
        overflow: hidden;
        border-radius: 50%;
        box-sizing: border-box;
        box-shadow: 0 1.4vw 2.8vw rgba(0, 0, 0, 0.8);
        zoom:0.2
    }

    .memory {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .memory:nth-child(1) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(0deg) translateY(-520%);
    }

    .memory:nth-child(2) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(6deg) translateY(-1461%);
    }

    .memory:nth-child(3) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(12deg) translateY(-1461%);
    }

    .memory:nth-child(4) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(18deg) translateY(-1461%);
    }

    .memory:nth-child(5) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(24deg) translateY(-1461%);
    }

    .memory:nth-child(6) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(30deg) translateY(-520%);
    }

    .memory:nth-child(7) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(36deg) translateY(-1461%);
    }

    .memory:nth-child(8) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(42deg) translateY(-1461%);
    }

    .memory:nth-child(9) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(48deg) translateY(-1461%);
    }

    .memory:nth-child(10) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(54deg) translateY(-1461%);
    }

    .memory:nth-child(11) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(60deg) translateY(-520%);
    }

    .memory:nth-child(12) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(66deg) translateY(-1461%);
    }

    .memory:nth-child(13) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(72deg) translateY(-1461%);
    }

    .memory:nth-child(14) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(78deg) translateY(-1461%);
    }

    .memory:nth-child(15) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(84deg) translateY(-1461%);
    }

    .memory:nth-child(16) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(90deg) translateY(-520%);
    }

    .memory:nth-child(17) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(96deg) translateY(-1461%);
    }

    .memory:nth-child(18) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(102deg) translateY(-1461%);
    }

    .memory:nth-child(19) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(108deg) translateY(-1461%);
    }

    .memory:nth-child(20) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(114deg) translateY(-1461%);
    }

    .memory:nth-child(21) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(120deg) translateY(-520%);
    }

    .memory:nth-child(22) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(126deg) translateY(-1461%);
    }

    .memory:nth-child(23) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(132deg) translateY(-1461%);
    }

    .memory:nth-child(24) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(138deg) translateY(-1461%);
    }

    .memory:nth-child(25) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(144deg) translateY(-1461%);
    }

    .memory:nth-child(26) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(150deg) translateY(-520%);
    }

    .memory:nth-child(27) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(156deg) translateY(-1461%);
    }

    .memory:nth-child(28) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(162deg) translateY(-1461%);
    }

    .memory:nth-child(29) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(168deg) translateY(-1461%);
    }

    .memory:nth-child(30) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(174deg) translateY(-1461%);
    }

    .memory:nth-child(31) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(180deg) translateY(-520%);
    }

    .memory:nth-child(32) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(186deg) translateY(-1461%);
    }

    .memory:nth-child(33) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(192deg) translateY(-1461%);
    }

    .memory:nth-child(34) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(198deg) translateY(-1461%);
    }

    .memory:nth-child(35) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(204deg) translateY(-1461%);
    }

    .memory:nth-child(36) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(210deg) translateY(-520%);
    }

    .memory:nth-child(37) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(216deg) translateY(-1461%);
    }

    .memory:nth-child(38) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(222deg) translateY(-1461%);
    }

    .memory:nth-child(39) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(228deg) translateY(-1461%);
    }

    .memory:nth-child(40) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(234deg) translateY(-1461%);
    }

    .memory:nth-child(41) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(240deg) translateY(-520%);
    }

    .memory:nth-child(42) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(246deg) translateY(-1461%);
    }

    .memory:nth-child(43) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(252deg) translateY(-1461%);
    }

    .memory:nth-child(44) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(258deg) translateY(-1461%);
    }

    .memory:nth-child(45) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(264deg) translateY(-1461%);
    }

    .memory:nth-child(46) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(270deg) translateY(-520%);
    }

    .memory:nth-child(47) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(276deg) translateY(-1461%);
    }

    .memory:nth-child(48) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(282deg) translateY(-1461%);
    }

    .memory:nth-child(49) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(288deg) translateY(-1461%);
    }

    .memory:nth-child(50) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(294deg) translateY(-1461%);
    }

    .memory:nth-child(51) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(300deg) translateY(-520%);
    }

    .memory:nth-child(52) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(306deg) translateY(-1461%);
    }

    .memory:nth-child(53) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(312deg) translateY(-1461%);
    }

    .memory:nth-child(54) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(318deg) translateY(-1461%);
    }

    .memory:nth-child(55) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(324deg) translateY(-1461%);
    }

    .memory:nth-child(56) {
        background-color: #424242;
        width: 2%;
        height: 8%;
        transform: translate(-50%, -50%) rotate(330deg) translateY(-520%);
    }

    .memory:nth-child(57) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(336deg) translateY(-1461%);
    }

    .memory:nth-child(58) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(342deg) translateY(-1461%);
    }

    .memory:nth-child(59) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(348deg) translateY(-1461%);
    }

    .memory:nth-child(60) {
        background-color: #949494;
        width: 1%;
        height: 3%;
        transform: translate(-50%, -50%) rotate(354deg) translateY(-1461%);
    }

    .needle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center;
    }

    .needle#hours {
        background-color: #1f1f1f;
        width: 4%;
        height: 30%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#hours.moving {
        transition: transform 150ms ease-out;
    }

    .needle#hours:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#minutes {
        background-color: #1f1f1f;
        width: 2%;
        height: 45%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#minutes.moving {
        transition: transform 150ms ease-out;
    }

    .needle#minutes:after {
        content: '';
        background-color: #1f1f1f;
        width: 4vw;
        height: 4vw;
        max-width: 4vh;
        max-height: 4vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .needle#seconds {
        background-color: #cb2f2f;
        width: 1%;
        height: 50%;
        transform-origin: center 75%;
        transform: translate(-50%, -75%);
    }

    .needle#seconds.moving {
        transition: transform 150ms ease-out;
    }

    .needle#seconds:after {
        content: '';
        background-color: #cb2f2f;
        width: 2.5vw;
        height: 2.5vw;
        max-width: 2.5vh;
        max-height: 2.5vh;
        display: block;
        position: absolute;
        top: 75%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }
    .clock_logo{
        width: 10vw;
        height: 10vw;
        max-width: 10vh;
        max-height: 10vh;
        position: absolute;
        top: 50%;
        left: 50%;
        box-sizing: border-box;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
    @media (min-width: 100vh) {
        .clock {
            border: solid 2.8vh #242424;
            box-shadow: 0 1.4vh 2.8vh rgba(0, 0, 0, 0.8);
        }
    }

</style>





            </div>
        
            <div class="nexmoe-pd-item">
                <div class="qweather" >
    <div id="he-plugin-standard"></div>
    <div class="qweather-logo">

    </div>

</div>
<style>
    .qweather{
        position: relative;
    }
    .qweather-logo{
        position: absolute;
        right: 0;
        top: -15px;
        width: 40px;
        height: 40px;
        background-size: 100% 100%;
        background-repeat: no-repeat;
    }
</style>
<script>
  WIDGET = {
    "CONFIG": {
      "layout": "2",
      "width": "260",
      "height": "220",
      "background": "5",
      "dataColor": "e67249",
      "borderRadius": "15",
      "key": "f74d1e1690e6432d801e97fa2f05a162"
    }
  }
</script>
<script src="https://widget.qweather.net/standard/static/js/he-standard-common.js?v=2.0"></script>

            </div>
        
</div>
<style>
    .nexmoe-pd {
        left: auto;
        top: 40px;
        right: 0;
    }
    .nexmoe-pd-item{
       display: flex;
        justify-content: center;
        margin-bottom: 30px;
    }
</style>

  </div>
  <script src="https://lib.baomitu.com/lazysizes/5.1.0/lazysizes.min.js"></script>
<script src="https://lib.baomitu.com/highlight.js/10.0.0/highlight.min.js"></script>
<script src="https://lib.baomitu.com/mdui/0.4.3/js/mdui.min.js"></script>

<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://lib.baomitu.com/jquery/3.5.1/jquery.slim.min.js"></script>
<script src="/lib/fancybox/js/jquery.fancybox.min.js"></script>


<script src="/js/app.js?v=1719645310162"></script>

<script src="https://lib.baomitu.com/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





<!-- hexo injector body_end start -->
<script src="https://lib.baomitu.com/clipboard.js/2.0.8/clipboard.min.js"></script>

<script src="/lib/codeBlock/codeBlockFuction.js"></script>

<script src="/lib/codeBlock/codeLang.js"></script>

<script src="/lib/codeBlock/codeCopy.js"></script>

<script src="/lib/codeBlock/codeShrink.js"></script>

<link rel="stylesheet" href="/lib/codeBlock/matery.css">

<script src="/js/clock.js"></script>

<script src="https://code.jquery.com/jquery-3.6.0.js"></script>

<script src="/js/search.js"></script>

<script src="/js/webapp.js"></script>
<!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"rect":{"opacity":0.7},"position":"relative","z-index":1,"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/250cb4aa.js","daovoice")</script>
<script>
  daovoice('init', {
    app_id: "250cb4aa"
  });
  daovoice('update');
</script>

